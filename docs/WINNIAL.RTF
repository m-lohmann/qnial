{\rtf1\ansi\deff0
{\fonttbl{\f0\fswiss Arial;}{\f1\fdecor Courier New;}}
{\colortbl;\red0\green0\blue0;}
{\stylesheet{\fs24 \snext0 Normal;}
}\pard\plain
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0001}
{\up $}{\footnote\pard\plain{\up $} Project Overview}
{\up #}{\footnote\pard\plain{\up #} 10JX63N}
\pard\keepn\sb55\sl-235 {\up K}{\footnote\pard\plain{\up K} Project Overview}
\b\fs24 Projects Overview\fs18 
\par \pard\sa55\sl-215\li115 \plain\fs18 
\par \fs20 The Q\'92Nial Session Manager uses the concept of a Project to help you manage your programming tasks.  Projects allow you to save and restore most of the current Session Manager settings.  These settings include:
\par 
\par \tab Locations of all currently open windows
\par \tab Interpreter Settings for each of the open windows
\par \tab Interpreter Startup Settings
\par \tab Workspace to load upon startup and to save on exit
\par \tab The directory path to the Project Directory
\par 
\par The Session Manager can start up with a \uldb user specified project\plain\fs20 , or with a new project (default).  Projects can be auto-saved whenever the project is closed.   Projects are saved in binary files with the extension of \b .npj\plain\fs20 .\b   \plain\fs20 This is a required extension and the Session Manager enforces that it is used.
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0002}
{\up $}{\footnote\pard\plain{\up $} Project Basics}
{\up #}{\footnote\pard\plain{\up #} 11J.7K}
\pard\keepn\sb55\sl-235 {\up K}{\footnote\pard\plain{\up K} Project Basics}
\b\fs24 Project Basics
\par \pard\sa55\sl-215\li115 \plain\fs20 When Q\'92Nial for Windows is run without specifying a Project, or when a New project is created, the project name will be \i Untitled Project\plain\fs20 .  The user can specify an initial or startup Project in two ways:
\par 
\par \tab By supplying the name of the project file on the command line
\par \tab By setting the initial project in the \i File|Preferences|Startup\plain\fs20  Dialog Box
\par 
\par The first method allows you to create Program Manager or Explorer Icons that startup up specific projects or associations to allow \i .npj\plain\fs20  file to automatically start Q\'92Nial for Windows (Winnial.exe).  The second method allows the Session Manager to start with a specific project regardless of how or where the Session Manager is started from.
\par \pard\sa55\sl-215\li115 
\par A Project file can also be Dragged and Dropped onto the Winnial application and  be automatically loaded.
\par 
\par Projects help manage your Nial source code files, Interpreter Windows and Interpreter Settings.  The settings saved in a Project file allow each project to automatically load a particular workspace on startup, and to save the same workspace whenever the Project is closed.  An initial Nial Definition ( .ndf) file can also be specified to be loaded when the Project is loaded.  Other Interpreter Settings include the ability to specify an initial workspace size, and whether Interpreter execution can be interrupted.
\par \pard\sb235\sa55 {\up #}{\footnote\pard\plain{\up #} 695W4N}
\b Project Work Area
\par \pard\sa55\sl-215\li115 \plain\fs20 This is the background area where Interpreter Windows and Editor Windows are displayed.  The Windows and their Iconified forms are restricted to the Background area of the Session Manager.  The Popup menu for this area is the same as the Projects menu on the Main menu.\fs18  \fs20 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0003}
{\up #}{\footnote\pard\plain{\up #} 13DHUVJ}
\pard\keepn\sb55\sl-235 \b\fs24 New Project\fs18 
\par \pard\sa55\sl-215\li115 \plain\fs18 
\par \fs20 Newly created Projects start with only the Main Interpreter Window.  You are free to create more \uldb Interpreter Windows \plain\fs20 {\v 12R4VNF}and to open as many\uldb  Editor Windows\plain\fs20 {\v P_4MQN} as desired.  All new projects start with the name \i Untitled Project\plain\fs20 .   When you request a \i Save\plain\fs20  or \i Save As \plain\fs20 action for the Project you are asked to supply a name for the project.
\par 
\par The Main Interpreter is created with any \uldb Interpreter Preferences \plain\fs20 {\v NR1.E}that the user has previously set.  
\par \pard\sa55\sl-215\li115 
\par Opening a new Project will save the current workspace (if that \uldb option\plain\fs20 {\v E7AOKG} is set), then stop the Interpreter, and then restart the Interpreter with the \uldb startup options\plain\fs20 {\v 3QCZ0YS} for the new Project.
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0004}
{\up #}{\footnote\pard\plain{\up #} 35VR0IT}
\pard\keepn\sb55\sl-235 \b\fs24 Projects Saving/Loading 
\par \pard\sa55\sl-215\li115 \plain\fs18 
\par \fs20 A Project can be saved at any time except when the Interpreter is busy with an execution.   Similarly, a Project cannot be loaded when the Interpreter is busy with an execution.
\par 
\par Both saving and loading a Project can involve saving and loading of a particular workspace.   If you have specified both an Initial Workspace name and checked that you want it to be loaded when the Project is loaded, then the Interpreter attempts to load that workspace when starting the Project.  If the workspace fails to load, the Interpreter starts with a clear workspace.
\par \pard\sa55\sl-215\li115 
\par Additionally, if you have checked that you want the specified workspace to be saved when the project is closed, the Session Manager saves the workspace when the Project closes.
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0005}
{\up $}{\footnote\pard\plain{\up $} Project Properties}
{\up #}{\footnote\pard\plain{\up #} E7AOKG}
\pard\keepn\sb55\sl-235 {\up K}{\footnote\pard\plain{\up K} Project Properties;Properties;Settings}
\b\fs24 Project Properties
\par \pard\sa55\sl-215\li115 \plain\fs18 Each Project has an associated set of properties that are saved and restored with the Project. The following properties can be set in the Properties Dialog.  This Dialog can be accessed from the \i Project|Properties\plain\fs18  menu item or from the Popup menu in the background area of the Session Manager.\fs20 
\par 
\par \{bmc bm0.BMP\}
\par \pard\sb235\sa55 {\up #}{\footnote\pard\plain{\up #} 1.5SPX}
\b\fs24  Project Directory
\par \pard\sa55\sl-215\li115 \plain\fs20 Whenever a Project is created, the project directory is initially set to be the directory where you have specified the project file to be created.
\par 
\par The Project Directory is made the current directory when the Project is loaded.   The is done to allow consistent referencing of Nial source files from Interpreter Windows and to reduce the need to type long path names for source files while interacting with the Session Manager.  
\par 
\par The Project Directory is displayed in the Project Properties Dialog box, but cannot be changed.
\par \pard\sa55\sl-215\li115 
\par When you attempt to save a Project and there are Editor windows open, the paths to the files being edited are stored in the Project file in relative form from the Project directory.  This allows the copying of the Project file and Project Directory and all its contents to a different location.  The Project file can then be loaded and all files that were copied are properly located.
\par \pard\sb235\sa55 \b\fs24 Workspaces
\par \pard\sb55\sa55\sl-235\li115 {\up #}{\footnote\pard\plain{\up #} 3_QE_UR}
\fs20 Auto Load/Save\fs18 
\par \pard\sa55\sl-215\li115 \plain\fs20 By default, the Session Manager creates the initial workspace from internal data unless a \i clearws.nws\plain\fs20  file exists in the Project Directory, in which case it is loaded.  It is possible to specify the name of an initial workspace you wish to load into the Interpreter when a Project is loaded.  This can be convenient if you have a set of definitions and variables that you wish to use each time you load a particular project.  
\par 
\par It is also possible to request that the workspace be saved with the same name every time the Project is closed.  Using this feature preserves any changes in the workspace that occurred in the session, so that you can continue with the Project in the same state at a later time.
\par \pard\sb55\sa55\sl-235\li115 {\up #}{\footnote\pard\plain{\up #} TGF5KZ}
\b Size
\par \pard\sa55\sl-215\li115 \plain\fs20 The default size of the Interpreter workspace is 200000 words.  If you know or expect that you will need a bigger or smaller size, then a different initial size can be set.  By default, workspaces can expand transparently if necessary.
\par \pard\sb55\sa55\sl-235\li115 {\up #}{\footnote\pard\plain{\up #} ID106.}
\b\fs24 Expansion\fs18 
\par \pard\sa55\sl-215\li115 \plain\fs18 You can prevent the workspace from expanding from the initial size by using this option.\fs20 
\par \pard\sb235\sa55 {\up #}{\footnote\pard\plain{\up #} 4VRJKH}
\b\fs24 Initial Defs
\par \pard\sa55\sl-215\li115 \plain\fs20 You can specify a Nial definition file to be loaded when a Project is loaded.  This is only loaded when the Project is loaded, when a \i Project|Restart\plain\fs20  is selected from the main menu, or when \i Restart\plain\fs20  is typed in an Interpreter Window.
\par \pard\sb235\sa55 {\up #}{\footnote\pard\plain{\up #} 2QLQ_L7}
\b\fs24 Messages
\par \pard\sa55\sl-215\li115 \plain\fs20 By default the Interpreter outputs informative messages to the active interpreter window (or the Main Interpreter Window if a command was initiated from a menu or button).  These messages provide information to you during interactive development.  They may inform you of workspace expansions, stack warnings, and other non-critical Interpreter events.  Disable the display of messages if you do not want you Interpreter output to contain these messages.
\par \pard\sb235\sa55 {\up #}{\footnote\pard\plain{\up #} 15GRSDB}
{\up K}{\footnote\pard\plain{\up K} Performance}
\b\fs24 Debugging
\par \pard\sa55\sl-215\li115 \plain\fs20 The Interpreter has the ability to disable the Nial level debugging features.  This is desirable for production work because the Interpreter runs somewhat faster when debugging is disabled.
\par \pard\sb235\sa55 {\up #}{\footnote\pard\plain{\up #} 18UJU01}
{\up K}{\footnote\pard\plain{\up K} Performance}
\b\fs24 Break Checking
\par \pard\sa55\sl-215\li115 \plain\fs20 Break Checking provides the ability you to interrupt the Nial Interpreter while it is executing.  If Break Checking is turned on, you can break execution by using either the \i Interpreter|Break Execution\plain\fs20  menu item, the \i Break Execution\plain\fs20  menu item on the Interpreter Window Popup menu, or the Button Bar button \{bmc bm1.BMP\}.
\par \fs18 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0006}
{\up $}{\footnote\pard\plain{\up $} Project Preferences}
{\up #}{\footnote\pard\plain{\up #} 3QCZ0YS}
\pard\keepn\sb55\sl-235 {\up K}{\footnote\pard\plain{\up K} Preferences;Project Preferences}
\b\fs24 Project Preferences
\par \pard\sa55\sl-215\li115 \plain\fs20 All of the settings that you can adjusted for an existing Project (\uldb Properties\plain\fs20 {\v E7AOKG}), you can also set as defaults for new Projects.  You do this using the Preferences Dialog that is accessed from the \i File|Preferences|New Project Settings\plain\fs20  menu item. 
\par 
\par The Project Preferences Dialog has exactly the same form as the Project Properties Dialog.  The difference is that changes made to the Preferences Dialog are saved in the WINNIAL.INI (or the Registry), and do not affect the current Project.  All Subsequent Projects are created with the settings in the WINNIAL.INI file.
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0007}
{\up #}{\footnote\pard\plain{\up #} 53N7_V_}
\pard\keepn\sb55\sl-235 \b\fs24 Project Main Menu\fs18 
\par \pard\sa55\sl-215\li115 \plain\fs18 
\par \{bmc bm2.BMP\}
\par 
\par \fs20 The Project Menu allows you to create New Projects, to open existing Projects, or to save the current Project.  The \uldb Properties Dialog\plain\fs20 {\v E7AOKG} for the current Project can also be accessed from this menu.
\par \fs18 
\par \pard\sb235\sa55 \b Create New Project
\par \pard\sa55\sl-215\li115 \plain\fs20 The current project is closed (and \uldb possibly saved\plain\fs20 {\v 1AML.CO}), and a new project is created using the \uldb Project Preferences\plain\fs20 {\v 3QCZ0YS}. The project name will be \i Untitled Project\plain\fs20   and a Main Interpreter Window is created. 
\par \pard\sb235\sa55 \b Open Existing Project
\par \pard\sa55\sl-215\li115 \plain\fs20 You are prompted for a Project file name for an existing Project. The Project file you have selected is loaded after the current project is closed (and \uldb possibly saved\plain\fs20 {\v 1AML.CO} if you have set this option in your Startup Settings).
\par \pard\sb235\sa55 \b Save Current Project
\par \pard\sa55\sl-215\li115 \plain\fs20 Selecting this menu item saves all Project information to the current Project file.
\par \pard\sb235\sa55 \b Project Properties
\par \pard\sa55\sl-215\li115 \plain\fs20 This menu item provides an alternate way to activate the \uldb Project Properties Dialog\plain\fs20 {\v E7AOKG}.   Right Clicking on the background area of the Session Manager produces a Popup \uldb  menu\plain\fs20 {\v 1P760QK} that also has a Properties item on it.
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0001:0008}
{\up #}{\footnote\pard\plain{\up #} 1P760QK}
\pard\keepn\sb55\sl-235 \b\fs24 Project Popup Menu 
\par \pard\sa55\sl-215\li115 \plain\fs18 
\par \fs20 \{bmc bm3.BMP\}
\par 
\par The Project Popup menu is activated by right clicking the background area (not on an Interpreter or Editor Window) of the Session Manager.  This menu is the same as the \uldb Project Main Menu\plain\fs20 {\v 53N7_V_}.
\par \page
{\up $}{\footnote\pard\plain{\up $} Getting Online Language Help}
{\up #}{\footnote\pard\plain{\up #} idh_Language_Help}
\pard\keepn\sb55\sl-235 {\up K}{\footnote\pard\plain{\up K} Command Reference;Language Help;Reference}
\b\fs24 Getting Help in Q\'92Nial for Windows
\par \pard\sa55\sl-215\li115 \plain\fs20 
\par Q\'92Nial for Windows has an extensive help system. The Contents button provides access to a structured overview of the Help topics concerning the Session Manager.  The Index button provides a detailed list of all Help topics including help on Nial Language primitives, concepts and syntax.
\par 
\par Context sensitive Help is accessed via the \b F1\plain\fs20  key almost anywhere in the Session Manager.  
\par 
\par You can get Help on dialogs, menus, windows and window areas by simply moving your mouse cursor directly over the item of interest and then pressing the \b F1\plain\fs20  key.  The item of interest does not have to have the input focus or be selected.
\par \pard\sa55\sl-215\li115 
\par \b Help for Dialog Boxes
\par \plain\fs20 Placing you mouse cursor over individual item in a dialog box and pressing \b F1\plain\fs20  brings up the help for that particular item, whereas placing your mouse cursor over the background area of the dialog box and pressing \b F1\plain\fs20  supplies general help for the entire dialog.
\par 
\par \b Contextual Help for the Nial Language\plain\fs20 
\par Context sensitive help for Nial can also be accessed using the \b F1\plain\fs20  key.  Selecting a word or placing the edit cursor on a word and pressing the \b F1\plain\fs20  key displays help on the specified language topic.  If a word has been selected, the mouse cursor must remain in the window where the selection occurs while the \b F1\plain\fs20  key is being pressed.
\par \pard\sa55\sl-215\li115 
\par The help topics on the language are organized into classes such as: concept, syntax, control structures and various groupings of the language primitives.  If an exact match for the desired word is found that Help topic is displayed, otherwise the index is displayed starting at the nearest match. 
\par 
\par \b Links in the Help Topics\plain\fs20 
\par The Help topics for the language have been divided into Classes with the Class of each entry displayed at the top. If you click on the word \i Class\plain\fs20  you go to a list of all classes. If you click on the specific class, the list of topics in that class pops up. You can then click on any topic to bring up its help page. Most Help topics for the language also include \i See Also \plain\fs20 links that are used to find closely related topics.
\par \pard\sa55\sl-215\li115 
\par There are also many links joining related topics in the Help pages for the Session Manager.
\par \pard\sa55\sl-215 
\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0001}
{\up $}{\footnote\pard\plain{\up $} CLASSES}
{\up #}{\footnote\pard\plain{\up #} YHPG9B}
\pard\keepn \b\fs25\cf1\cb1 Index of Entry Classes\plain\cf1\cb1 
\par \pard \ul \ul\fs20 applicative transformer\plain\fs20\cf1\cb1 {\v applicative transformer} \line
\ul apply-by-partition transformer\plain\fs20\cf1\cb1 {\v apply-by-partition transformer} \line
\ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation} \line
\ul array generation operation\plain\fs20\cf1\cb1 {\v array generation operation} \line
\ul comparison operation\plain\fs20\cf1\cb1 {\v comparison operation} \line
\ul concept\plain\fs20\cf1\cb1 {\v concept} \line
\ul constant expression\plain\fs20\cf1\cb1 {\v constant expression} \line
\ul construction operation\plain\fs20\cf1\cb1 {\v construction operation} \line
\ul control structure\plain\fs20\cf1\cb1 {\v control structure} \line
\ul control structure transformer\plain\fs20\cf1\cb1 {\v control structure transformer} \line
\ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation} \line
\ul data rearrangement operation\plain\fs20\cf1\cb1 {\v data rearrangement operation} \line
\ul debugging command\plain\fs20\cf1\cb1 {\v debugging command} \line
\ul distributive transformer\plain\fs20\cf1\cb1 {\v distributive transformer} \line
\ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation} \line
\ul feature\plain\fs20\cf1\cb1 {\v feature} \line
\ul file expression\plain\fs20\cf1\cb1 {\v file expression} \line
\ul file operation\plain\fs20\cf1\cb1 {\v file operation} \line
\ul host direct access file operation\plain\fs20\cf1\cb1 {\v host direct access file operation} \line
\ul insertion operation\plain\fs20\cf1\cb1 {\v insertion operation} \line
\ul interactive input/output expression\plain\fs20\cf1\cb1 {\v interactive input/output expression} \line
\ul interactive input/output operation\plain\fs20\cf1\cb1 {\v interactive input/output operation} \line
\ul linear algebra operation\plain\fs20\cf1\cb1 {\v linear algebra operation} \line
\ul logic operation\plain\fs20\cf1\cb1 {\v logic operation} \line
\ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation} \line
\ul nesting restructuring operation\plain\fs20\cf1\cb1 {\v nesting restructuring operation} \line
\ul nial direct access file operation\plain\fs20\cf1\cb1 {\v nial direct access file operation} \line
\ul operation property\plain\fs20\cf1\cb1 {\v operation property} \line
\ul picture operation\plain\fs20\cf1\cb1 {\v picture operation} \line
\ul profiling expression\plain\fs20\cf1\cb1 {\v profiling expression} \line
\ul profiling operation\plain\fs20\cf1\cb1 {\v profiling operation} \line
\ul recursion transformer\plain\fs20\cf1\cb1 {\v recursion transformer} \line
\ul reduction transformer\plain\fs20\cf1\cb1 {\v reduction transformer} \line
\ul reshaping operation\plain\fs20\cf1\cb1 {\v reshaping operation} \line
\ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation} \line
\ul search operation\plain\fs20\cf1\cb1 {\v search operation} \line
\ul selection operation\plain\fs20\cf1\cb1 {\v selection operation} \line
\ul selection transformer\plain\fs20\cf1\cb1 {\v selection transformer} \line
\ul set-like operation\plain\fs20\cf1\cb1 {\v set-like operation} \line
\ul sorting operation\plain\fs20\cf1\cb1 {\v sorting operation} \line
\ul sorting transformer\plain\fs20\cf1\cb1 {\v sorting transformer} \line
\ul string manipulation operation\plain\fs20\cf1\cb1 {\v string manipulation operation} \line
\ul structure testing operation\plain\fs20\cf1\cb1 {\v structure testing operation} \line
\ul syntax\plain\fs20\cf1\cb1 {\v syntax} \line
\ul system constant\plain\fs20\cf1\cb1 {\v system constant} \line
\ul system expression\plain\fs20\cf1\cb1 {\v system expression} \line
\ul system operation\plain\fs20\cf1\cb1 {\v system operation} \line
\ul system transformer\plain\fs20\cf1\cb1 {\v system transformer} \line
\ul system variable\plain\fs20\cf1\cb1 {\v system variable} \line
\ul user defined expression\plain\fs20\cf1\cb1 {\v user defined expression} \line
\ul user defined operation\plain\fs20\cf1\cb1 {\v user defined operation}\page
{\up #}{\footnote\pard\plain{\up #} arithmetic operation}
\pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation}
\uldb abs\plain\fs20\cf1\cb1 {\v 1_E6Q6I} \uldb ceiling\plain\fs20\cf1\cb1 {\v 5G__UQ} \uldb divide\plain\fs20\cf1\cb1 {\v 6242D6P} \uldb floor\plain\fs20\cf1\cb1 {\v 7CICIH} \uldb minus\plain\fs20\cf1\cb1 {\v 7JFBOI} \uldb mod\plain\fs20\cf1\cb1 {\v 1_E72C0} \uldb opposite\plain\fs20\cf1\cb1 {\v 18Y3XQ} \uldb plus\plain\fs20\cf1\cb1 {\v 1CMG0JM} \uldb power\plain\fs20\cf1\cb1 {\v TVXJVX} \uldb product\plain\fs20\cf1\cb1 {\v 2H9LPX5} \uldb quotient\plain\fs20\cf1\cb1 {\v KJKAFK} \uldb reciprocal\plain\fs20\cf1\cb1 {\v AJCGJN} \uldb sum\plain\fs20\cf1\cb1 {\v 1_E78IC} \uldb times\plain\fs20\cf1\cb1 {\v 5JEP_NH} \page
{\up #}{\footnote\pard\plain{\up #} reduction transformer}
\pard {\up K}{\footnote\pard\plain{\up K} reduction transformer}
\uldb accumulate\plain\fs20\cf1\cb1 {\v 2_FBXZ} \uldb reduce\plain\fs20\cf1\cb1 {\v 2.MYRUF} \page
{\up #}{\footnote\pard\plain{\up #} recursion transformer}
\pard {\up K}{\footnote\pard\plain{\up K} recursion transformer}
\uldb across\plain\fs20\cf1\cb1 {\v G9ON74} \uldb down\plain\fs20\cf1\cb1 {\v 25VG_8X} \uldb recur\plain\fs20\cf1\cb1 {\v 7OB7OH} \page
{\up #}{\footnote\pard\plain{\up #} syntax}
\pard {\up K}{\footnote\pard\plain{\up K} syntax}
\uldb action\plain\fs20\cf1\cb1 {\v G9QH2Z} \uldb assign expression\plain\fs20\cf1\cb1 {\v LWL7E5} \uldb atlas\plain\fs20\cf1\cb1 {\v 3HB7_ZC} \uldb block\plain\fs20\cf1\cb1 {\v THUBTQ} \uldb bracket-comma notation\plain\fs20\cf1\cb1 {\v 1N.QYRT} \uldb cast\plain\fs20\cf1\cb1 {\v 1CM9ZHN} \uldb comment\plain\fs20\cf1\cb1 {\v 11TJ9BC} \uldb expression sequence\plain\fs20\cf1\cb1 {\v R9CDMG} \uldb external declaration\plain\fs20\cf1\cb1 {\v .O7OJC} \uldb infix notation\plain\fs20\cf1\cb1 {\v 50FXVP} \uldb juxtaposition\plain\fs20\cf1\cb1 {\v PU.YMO} \uldb operation form\plain\fs20\cf1\cb1 {\v B1O8VR} \uldb prefix notation\plain\fs20\cf1\cb1 {\v 16XL468} \uldb reserved words\plain\fs20\cf1\cb1 {\v 10F734O} \uldb strand notation\plain\fs20\cf1\cb1 {\v 1N9SB86} \uldb synonym\plain\fs20\cf1\cb1 {\v .DMN3Z} \uldb transformer form\plain\fs20\cf1\cb1 {\v 19VZZWW} \uldb variable\plain\fs20\cf1\cb1 {\v 4QO4_OO} \page
{\up #}{\footnote\pard\plain{\up #} concept}
\pard {\up K}{\footnote\pard\plain{\up K} concept}
\uldb address\plain\fs20\cf1\cb1 {\v 63.8K7} \uldb argument\plain\fs20\cf1\cb1 {\v C4.J_2} \uldb array\plain\fs20\cf1\cb1 {\v 28ZHDVT} \uldb by-variable\plain\fs20\cf1\cb1 {\v 700T8J} \uldb canonical\plain\fs20\cf1\cb1 {\v NZPQUY} \uldb clear workspace\plain\fs20\cf1\cb1 {\v 2R04_UA} \uldb conform\plain\fs20\cf1\cb1 {\v 11UCCF.} \uldb continue workspace\plain\fs20\cf1\cb1 {\v 29G9US} \uldb curried operation\plain\fs20\cf1\cb1 {\v 3NTT_IU} \uldb debugging\plain\fs20\cf1\cb1 {\v PP0_XH} \uldb definition\plain\fs20\cf1\cb1 {\v K9LSXA} \uldb dimensions\plain\fs20\cf1\cb1 {\v 12_I6ZM} \uldb equations\plain\fs20\cf1\cb1 {\v 6TVNM7} \uldb expression\plain\fs20\cf1\cb1 {\v FD5QFK} \uldb extent\plain\fs20\cf1\cb1 {\v KNQD25} \uldb fault triggering\plain\fs20\cf1\cb1 {\v 2JAK0C0} \uldb fault values\plain\fs20\cf1\cb1 {\v 2D_C0L1} \uldb functions in nial\plain\fs20\cf1\cb1 {\v 3V52_J2} \uldb global environment\plain\fs20\cf1\cb1 {\v 0.KANS} \uldb indexing\plain\fs20\cf1\cb1 {\v 2MDYZ6S} \uldb initial subdirectory\plain\fs20\cf1\cb1 {\v 1TS.2ZP} \uldb interrupt\plain\fs20\cf1\cb1 {\v 8EQO0LE} \uldb item\plain\fs20\cf1\cb1 {\v 40SC6R} \uldb level\plain\fs20\cf1\cb1 {\v TRNIVR} \uldb local environment\plain\fs20\cf1\cb1 {\v BN.OFR} \uldb nested definition\plain\fs20\cf1\cb1 {\v 1TSSBWU} \uldb numeric type hierarchy\plain\fs20\cf1\cb1 {\v 1_X9C7} \uldb operation\plain\fs20\cf1\cb1 {\v CQFG7.} \uldb operation composition\plain\fs20\cf1\cb1 {\v 1ZR4NW0} \uldb overflow\plain\fs20\cf1\cb1 {\v 1MYZ9HY} \uldb pervasive\plain\fs20\cf1\cb1 {\v 4E_0R6} \uldb prelattice of atoms\plain\fs20\cf1\cb1 {\v 1N6N36O} \uldb profiling\plain\fs20\cf1\cb1 {\v 1_IJW3H} \uldb program fragment\plain\fs20\cf1\cb1 {\v 1QC9YUE} \uldb regular expression notation\plain\fs20\cf1\cb1 {\v 6YYA_NK} \uldb role\plain\fs20\cf1\cb1 {\v QD__TZ} \uldb scope of a variable\plain\fs20\cf1\cb1 {\v 42GY_XT} \uldb standard definitions\plain\fs20\cf1\cb1 {\v AXO3EN} \uldb top level loop\plain\fs20\cf1\cb1 {\v 4CHEV95} \uldb transformer\plain\fs20\cf1\cb1 {\v 1VQL398} \page
{\up #}{\footnote\pard\plain{\up #} measurement operation}
\pard {\up K}{\footnote\pard\plain{\up K} measurement operation}
\uldb allbools\plain\fs20\cf1\cb1 {\v 211AO05} \uldb allchars\plain\fs20\cf1\cb1 {\v 7CQD_O4} \uldb allints\plain\fs20\cf1\cb1 {\v 6C8I_GF} \uldb allnumeric\plain\fs20\cf1\cb1 {\v LCHPGK} \uldb allreals\plain\fs20\cf1\cb1 {\v 21A7A05} \uldb axes\plain\fs20\cf1\cb1 {\v 40KG6X} \uldb depth\plain\fs20\cf1\cb1 {\v TJND0N} \uldb isboolean\plain\fs20\cf1\cb1 {\v 1VYX20O} \uldb ischar\plain\fs20\cf1\cb1 {\v 1ARLF.C} \uldb isfault\plain\fs20\cf1\cb1 {\v 1MY4M1D} \uldb isinteger\plain\fs20\cf1\cb1 {\v 23WZ8W4} \uldb isphrase\plain\fs20\cf1\cb1 {\v E7PW.M} \uldb isreal\plain\fs20\cf1\cb1 {\v OIOCOX} \uldb isstring\plain\fs20\cf1\cb1 {\v HCQ47O} \uldb numeric\plain\fs20\cf1\cb1 {\v K7MN2O} \uldb shape\plain\fs20\cf1\cb1 {\v TYQ56K} \uldb tally\plain\fs20\cf1\cb1 {\v 5JEH.UN} \uldb type\plain\fs20\cf1\cb1 {\v 25VWG1O} \uldb valence\plain\fs20\cf1\cb1 {\v MQJNXM} \page
{\up #}{\footnote\pard\plain{\up #} set-like operation}
\pard {\up K}{\footnote\pard\plain{\up K} set-like operation}
\uldb allin\plain\fs20\cf1\cb1 {\v 5J2S.RC} \uldb like\plain\fs20\cf1\cb1 {\v 40V8.J} \page
{\up #}{\footnote\pard\plain{\up #} logic operation}
\pard {\up K}{\footnote\pard\plain{\up K} logic operation}
\uldb and\plain\fs20\cf1\cb1 {\v 1_E6QB0} \uldb diverse\plain\fs20\cf1\cb1 {\v 19T6FZO} \uldb equal\plain\fs20\cf1\cb1 {\v TKZHRR} \uldb not\plain\fs20\cf1\cb1 {\v 1_E73CJ} \uldb or\plain\fs20\cf1\cb1 {\v RJ2SI6} \uldb unequal\plain\fs20\cf1\cb1 {\v LT7UC9} \page
{\up #}{\footnote\pard\plain{\up #} construction operation}
\pard {\up K}{\footnote\pard\plain{\up K} construction operation}
\uldb append\plain\fs20\cf1\cb1 {\v GFMD1P} \uldb cart\plain\fs20\cf1\cb1 {\v 1CM9ZGN} \uldb catenate\plain\fs20\cf1\cb1 {\v BNUIZP} \uldb hitch\plain\fs20\cf1\cb1 {\v TNRGTN} \uldb laminate\plain\fs20\cf1\cb1 {\v M19KO1} \uldb link\plain\fs20\cf1\cb1 {\v QD77W5} \uldb pair\plain\fs20\cf1\cb1 {\v QD0ZR.} \uldb single\plain\fs20\cf1\cb1 {\v 1KHWEG6} \uldb solitary\plain\fs20\cf1\cb1 {\v 2BGSG4Y} \page
{\up #}{\footnote\pard\plain{\up #} file operation}
\pard {\up K}{\footnote\pard\plain{\up K} file operation}
\uldb appendfile\plain\fs20\cf1\cb1 {\v 3AAL9Q} \uldb close\plain\fs20\cf1\cb1 {\v TIUC9K} \uldb filepath\plain\fs20\cf1\cb1 {\v 5IP8L} \uldb getfile\plain\fs20\cf1\cb1 {\v 45R7_SO} \uldb open\plain\fs20\cf1\cb1 {\v 25VR_QX} \uldb putfile\plain\fs20\cf1\cb1 {\v IMUFEL} \uldb readfile\plain\fs20\cf1\cb1 {\v 5JAWOA} \uldb writefile\plain\fs20\cf1\cb1 {\v 1DNB1GE} \page
{\up #}{\footnote\pard\plain{\up #} evaluation operation}
\pard {\up K}{\footnote\pard\plain{\up K} evaluation operation}
\uldb apply\plain\fs20\cf1\cb1 {\v TGYD34} \uldb assign\plain\fs20\cf1\cb1 {\v GIPGUZ} \uldb deepupdate\plain\fs20\cf1\cb1 {\v 5IR4_G} \uldb deparse\plain\fs20\cf1\cb1 {\v 15N2FZO} \uldb descan\plain\fs20\cf1\cb1 {\v 7ABG_7N} \uldb eval\plain\fs20\cf1\cb1 {\v 40OE2Q} \uldb execute\plain\fs20\cf1\cb1 {\v 3WULI4D} \uldb getdef\plain\fs20\cf1\cb1 {\v 2EC.B} \uldb getname\plain\fs20\cf1\cb1 {\v 2EM8IE} \uldb getsyms\plain\fs20\cf1\cb1 {\v 2ERPIS} \uldb parse\plain\fs20\cf1\cb1 {\v TVJF9K} \uldb scan\plain\fs20\cf1\cb1 {\v 1CMJ16H} \uldb update\plain\fs20\cf1\cb1 {\v 4AIR_VK} \uldb updateall\plain\fs20\cf1\cb1 {\v I.4L_C} \uldb value\plain\fs20\cf1\cb1 {\v 5JGH_30} \page
{\up #}{\footnote\pard\plain{\up #} scientific operation}
\pard {\up K}{\footnote\pard\plain{\up K} scientific operation}
\uldb arccos\plain\fs20\cf1\cb1 {\v 19QLAJD} \uldb arcsin\plain\fs20\cf1\cb1 {\v 2I99PH4} \uldb arctan\plain\fs20\cf1\cb1 {\v 1VZXQSO} \uldb cos\plain\fs20\cf1\cb1 {\v 1_E6SCI} \uldb cosh\plain\fs20\cf1\cb1 {\v 1CM0_HB} \uldb exp\plain\fs20\cf1\cb1 {\v 1_E6ULF} \uldb ln\plain\fs20\cf1\cb1 {\v RJ2SF2} \uldb log\plain\fs20\cf1\cb1 {\v 1_E71C_} \uldb sin\plain\fs20\cf1\cb1 {\v 1_E78_D} \uldb sinh\plain\fs20\cf1\cb1 {\v 1CMJ7CB} \uldb sqrt\plain\fs20\cf1\cb1 {\v 47GO_O8} \uldb tan\plain\fs20\cf1\cb1 {\v 1_E795D} \uldb tanh\plain\fs20\cf1\cb1 {\v 1CMJZCB} \page
{\up #}{\footnote\pard\plain{\up #} structure testing operation}
\pard {\up K}{\footnote\pard\plain{\up K} structure testing operation}
\uldb atomic\plain\fs20\cf1\cb1 {\v GJLKWO} \uldb empty\plain\fs20\cf1\cb1 {\v 7BJDNO} \uldb simple\plain\fs20\cf1\cb1 {\v 1KHVNG6} \page
{\up #}{\footnote\pard\plain{\up #} operation property}
\pard {\up K}{\footnote\pard\plain{\up K} operation property}
\uldb binary\plain\fs20\cf1\cb1 {\v 3YC1_U4} \uldb binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF} \uldb multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV} \uldb predicate\plain\fs20\cf1\cb1 {\v QJ_HSO} \uldb reductive\plain\fs20\cf1\cb1 {\v 7GGROL} \uldb unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7} \page
{\up #}{\footnote\pard\plain{\up #} nesting restructuring operation}
\pard {\up K}{\footnote\pard\plain{\up K} nesting restructuring operation}
\uldb blend\plain\fs20\cf1\cb1 {\v THU94J} \uldb cols\plain\fs20\cf1\cb1 {\v QCY_U_} \uldb content\plain\fs20\cf1\cb1 {\v 11UQ9BC} \uldb lower\plain\fs20\cf1\cb1 {\v TRXJVX} \uldb mix\plain\fs20\cf1\cb1 {\v 1_E72_N} \uldb raise\plain\fs20\cf1\cb1 {\v TXJ_9K} \uldb rows\plain\fs20\cf1\cb1 {\v 1CMI_LM} \uldb split\plain\fs20\cf1\cb1 {\v 5JDW.RI} \page
{\up #}{\footnote\pard\plain{\up #} system expression}
\pard {\up K}{\footnote\pard\plain{\up K} system expression}
\uldb break\plain\fs20\cf1\cb1 {\v 2V9T7BV} \uldb breaklist\plain\fs20\cf1\cb1 {\v 2JH0.LH} \uldb bye\plain\fs20\cf1\cb1 {\v 1ZNBR9K} \uldb callstack\plain\fs20\cf1\cb1 {\v MPTNH2} \uldb clearws\plain\fs20\cf1\cb1 {\v .C2G42} \uldb continue\plain\fs20\cf1\cb1 {\v 1FW5IX} \uldb dlllist\plain\fs20\cf1\cb1 {\v 1YSI_GC} \uldb exprs\plain\fs20\cf1\cb1 {\v 7BUDLI} \uldb help\plain\fs20\cf1\cb1 {\v 40R4_U} \uldb nialroot\plain\fs20\cf1\cb1 {\v K_TBJ1} \uldb no_expr\plain\fs20\cf1\cb1 {\v DRMT03} \uldb ops\plain\fs20\cf1\cb1 {\v 1_E74DI} \uldb restart\plain\fs20\cf1\cb1 {\v 3I4P_OP} \uldb status\plain\fs20\cf1\cb1 {\v .A2SLO} \uldb time\plain\fs20\cf1\cb1 {\v 25VW6YO} \uldb timestamp\plain\fs20\cf1\cb1 {\v 1XKI84P} \uldb toplevel\plain\fs20\cf1\cb1 {\v 3A08M4I} \uldb trs\plain\fs20\cf1\cb1 {\v 1_E79FI} \uldb vars\plain\fs20\cf1\cb1 {\v 1CMLZGM} \uldb watchlist\plain\fs20\cf1\cb1 {\v J.SR_V} \page
{\up #}{\footnote\pard\plain{\up #} system operation}
\pard {\up K}{\footnote\pard\plain{\up K} system operation}
\uldb breakin\plain\fs20\cf1\cb1 {\v 26_7_XB} \uldb calldllfun\plain\fs20\cf1\cb1 {\v 201S2GS} \uldb edit\plain\fs20\cf1\cb1 {\v 40O30Y} \uldb erase\plain\fs20\cf1\cb1 {\v 2V.T3TP} \uldb host\plain\fs20\cf1\cb1 {\v 25VK_53} \uldb library\plain\fs20\cf1\cb1 {\v 2B9L0GD} \uldb load\plain\fs20\cf1\cb1 {\v QD7_IY} \uldb loaddefs\plain\fs20\cf1\cb1 {\v RIAXFW} \uldb no_op\plain\fs20\cf1\cb1 {\v 7KL1IF} \uldb registerdllfun\plain\fs20\cf1\cb1 {\v R.9.XP} \uldb save\plain\fs20\cf1\cb1 {\v 25VUZ7O} \uldb see\plain\fs20\cf1\cb1 {\v 1ZNC7PK} \uldb seeprimcalls\plain\fs20\cf1\cb1 {\v 3_ALKA} \uldb seeusercalls\plain\fs20\cf1\cb1 {\v 1O05MSU} \uldb set\plain\fs20\cf1\cb1 {\v 1_E789J} \uldb setdeftrace\plain\fs20\cf1\cb1 {\v 1O7K0X3} \uldb setinterrupts\plain\fs20\cf1\cb1 {\v 36DY_X6} \uldb setlogname\plain\fs20\cf1\cb1 {\v H7O7NO} \uldb setprompt\plain\fs20\cf1\cb1 {\v H31IJ} \uldb settrigger\plain\fs20\cf1\cb1 {\v 16TEBGX} \uldb setwidth\plain\fs20\cf1\cb1 {\v 40KE5L} \uldb symbols\plain\fs20\cf1\cb1 {\v 1KUXMUU} \uldb topic\plain\fs20\cf1\cb1 {\v 7QLDC9} \uldb user primitives\plain\fs20\cf1\cb1 {\v DV7MJ4} \uldb watch\plain\fs20\cf1\cb1 {\v U2JGTN} \page
{\up #}{\footnote\pard\plain{\up #} apply-by-partition transformer}
\pard {\up K}{\footnote\pard\plain{\up K} apply-by-partition transformer}
\uldb bycols\plain\fs20\cf1\cb1 {\v 10XLMGD} \uldb byrows\plain\fs20\cf1\cb1 {\v 3.ITLBI} \uldb partition\plain\fs20\cf1\cb1 {\v KE6GMU} \uldb rank\plain\fs20\cf1\cb1 {\v QD.ZW5} \uldb reducecols\plain\fs20\cf1\cb1 {\v 2SIMTO} \uldb reducerows\plain\fs20\cf1\cb1 {\v 2SXN4O} \page
{\up #}{\footnote\pard\plain{\up #} applicative transformer}
\pard {\up K}{\footnote\pard\plain{\up K} applicative transformer}
\uldb bykey\plain\fs20\cf1\cb1 {\v 3HC._3I} \uldb converse\plain\fs20\cf1\cb1 {\v 1HS9GX} \uldb fold\plain\fs20\cf1\cb1 {\v QD1_TY} \uldb inner\plain\fs20\cf1\cb1 {\v TOWAVX} \uldb outer\plain\fs20\cf1\cb1 {\v TV3GVX} \uldb team\plain\fs20\cf1\cb1 {\v 1CMK36G} \page
{\up #}{\footnote\pard\plain{\up #} control structure}
\pard {\up K}{\footnote\pard\plain{\up K} control structure}
\uldb case-expr\plain\fs20\cf1\cb1 {\v 3BHT_IZ} \uldb for-loop\plain\fs20\cf1\cb1 {\v MT.6OU} \uldb if-expr\plain\fs20\cf1\cb1 {\v XKQ1M} \uldb repeat-loop\plain\fs20\cf1\cb1 {\v 12OGSY0} \uldb while-loop\plain\fs20\cf1\cb1 {\v TQAIFP} \page
{\up #}{\footnote\pard\plain{\up #} conversion operation}
\pard {\up K}{\footnote\pard\plain{\up K} conversion operation}
\uldb char\plain\fs20\cf1\cb1 {\v 40M72W} \uldb charrep\plain\fs20\cf1\cb1 {\v 2W9HDTD} \uldb fault\plain\fs20\cf1\cb1 {\v TLJI2Z} \uldb fromraw\plain\fs20\cf1\cb1 {\v 1IXHU.} \uldb gage\plain\fs20\cf1\cb1 {\v QD1ZOZ} \uldb phrase\plain\fs20\cf1\cb1 {\v 4.B5_UK} \uldb quiet_fault\plain\fs20\cf1\cb1 {\v 1EEKEB1} \uldb string\plain\fs20\cf1\cb1 {\v .ACHEC} \uldb tolower\plain\fs20\cf1\cb1 {\v 12BMVK4} \uldb tonumber\plain\fs20\cf1\cb1 {\v 1_RG0DJ} \uldb toraw\plain\fs20\cf1\cb1 {\v TZXES2} \uldb toupper\plain\fs20\cf1\cb1 {\v 12KNOK4} \page
{\up #}{\footnote\pard\plain{\up #} user defined expression}
\pard {\up K}{\footnote\pard\plain{\up K} user defined expression}
\uldb checkpoint\plain\fs20\cf1\cb1 {\v 4LLHD1P} \uldb latent\plain\fs20\cf1\cb1 {\v 4YEDEP} \page
{\up #}{\footnote\pard\plain{\up #} selection operation}
\pard {\up K}{\footnote\pard\plain{\up K} selection operation}
\uldb choose\plain\fs20\cf1\cb1 {\v 1XQ9M0F} \uldb cull\plain\fs20\cf1\cb1 {\v 40MD_Q} \uldb cut\plain\fs20\cf1\cb1 {\v 1_E6SIJ} \uldb cutall\plain\fs20\cf1\cb1 {\v 3ZO7_NR} \uldb drop\plain\fs20\cf1\cb1 {\v 5FYX_OT} \uldb dropright\plain\fs20\cf1\cb1 {\v H_F96H} \uldb except\plain\fs20\cf1\cb1 {\v 1_WLCKE} \uldb first\plain\fs20\cf1\cb1 {\v 7CFFMJ} \uldb front\plain\fs20\cf1\cb1 {\v 7COCHJ} \uldb last\plain\fs20\cf1\cb1 {\v 1CMBZHN} \uldb pick\plain\fs20\cf1\cb1 {\v 40Z84P} \uldb reach\plain\fs20\cf1\cb1 {\v TXN4TN} \uldb rest\plain\fs20\cf1\cb1 {\v 1CMI3HN} \uldb second\plain\fs20\cf1\cb1 {\v 1KDLMI5} \uldb sublist\plain\fs20\cf1\cb1 {\v 88JHY6} \uldb take\plain\fs20\cf1\cb1 {\v 25VVYWO} \uldb takeright\plain\fs20\cf1\cb1 {\v 149YX4U} \uldb third\plain\fs20\cf1\cb1 {\v 7QE_L0} \page
{\up #}{\footnote\pard\plain{\up #} profiling expression}
\pard {\up K}{\footnote\pard\plain{\up K} profiling expression}
\uldb clearprofile\plain\fs20\cf1\cb1 {\v 90MFAZ} \uldb profiletable\plain\fs20\cf1\cb1 {\v _8MA7D} \uldb profiletree\plain\fs20\cf1\cb1 {\v H3PT41} \page
{\up #}{\footnote\pard\plain{\up #} constant expression}
\pard {\up K}{\footnote\pard\plain{\up K} constant expression}
\uldb copyright\plain\fs20\cf1\cb1 {\v 2.MC.X4} \uldb false\plain\fs20\cf1\cb1 {\v 4WY._DU} \uldb null\plain\fs20\cf1\cb1 {\v 40XD_Q} \uldb pi\plain\fs20\cf1\cb1 {\v RJ2SIX} \uldb separator\plain\fs20\cf1\cb1 {\v 35WS3GL} \uldb system\plain\fs20\cf1\cb1 {\v .FDS.I} \uldb true\plain\fs20\cf1\cb1 {\v 5FZ__UI} \uldb version\plain\fs20\cf1\cb1 {\v 4NLJMF} \page
{\up #}{\footnote\pard\plain{\up #} array generation operation}
\pard {\up K}{\footnote\pard\plain{\up K} array generation operation}
\uldb count\plain\fs20\cf1\cb1 {\v TIXI4Z} \uldb grid\plain\fs20\cf1\cb1 {\v 40QA0I} \uldb random\plain\fs20\cf1\cb1 {\v X7KC2Y} \uldb seed\plain\fs20\cf1\cb1 {\v 25VV2QN} \uldb tell\plain\fs20\cf1\cb1 {\v 1CMK3AF} \page
{\up #}{\footnote\pard\plain{\up #} insertion operation}
\pard {\up K}{\footnote\pard\plain{\up K} insertion operation}
\uldb deepplace\plain\fs20\cf1\cb1 {\v 0UY7YL} \uldb place\plain\fs20\cf1\cb1 {\v TVU4TK} \uldb placeall\plain\fs20\cf1\cb1 {\v 1_2.DUD} \page
{\up #}{\footnote\pard\plain{\up #} picture operation}
\pard {\up K}{\footnote\pard\plain{\up K} picture operation}
\uldb diagram\plain\fs20\cf1\cb1 {\v G5WG1G} \uldb display\plain\fs20\cf1\cb1 {\v GH5A1S} \uldb paste\plain\fs20\cf1\cb1 {\v TVJG0K} \uldb picture\plain\fs20\cf1\cb1 {\v __8RKL} \uldb positions\plain\fs20\cf1\cb1 {\v 1AGU44_} \uldb setformat\plain\fs20\cf1\cb1 {\v 1S5YZUO} \uldb sketch\plain\fs20\cf1\cb1 {\v .86S0D} \page
{\up #}{\footnote\pard\plain{\up #} distributive transformer}
\pard {\up K}{\footnote\pard\plain{\up K} distributive transformer}
\uldb each\plain\fs20\cf1\cb1 {\v QCZZL2} \uldb eachall\plain\fs20\cf1\cb1 {\v LYL6P6} \uldb eachboth\plain\fs20\cf1\cb1 {\v 1R110IM} \uldb eachleft\plain\fs20\cf1\cb1 {\v BIN189} \uldb eachright\plain\fs20\cf1\cb1 {\v X9UDS7} \uldb leaf\plain\fs20\cf1\cb1 {\v 40V42K} \uldb twig\plain\fs20\cf1\cb1 {\v 25VWDUQ} \page
{\up #}{\footnote\pard\plain{\up #} nial direct access file operation}
\pard {\up K}{\footnote\pard\plain{\up K} nial direct access file operation}
\uldb eraserecord\plain\fs20\cf1\cb1 {\v LE6Z0M} \uldb filetally\plain\fs20\cf1\cb1 {\v 1E5.ZTN} \uldb readarray\plain\fs20\cf1\cb1 {\v 7HVXYZ} \uldb readrecord\plain\fs20\cf1\cb1 {\v 6J72_OO} \uldb writearray\plain\fs20\cf1\cb1 {\v 18CILAO} \uldb writerecord\plain\fs20\cf1\cb1 {\v V4AFRH} \page
{\up #}{\footnote\pard\plain{\up #} host direct access file operation}
\pard {\up K}{\footnote\pard\plain{\up K} host direct access file operation}
\uldb filelength\plain\fs20\cf1\cb1 {\v 34SOEI} \uldb readfield\plain\fs20\cf1\cb1 {\v 7MML9E} \uldb writefield\plain\fs20\cf1\cb1 {\v 3WBE_SO} \page
{\up #}{\footnote\pard\plain{\up #} file expression}
\pard {\up K}{\footnote\pard\plain{\up K} file expression}
\uldb filestatus\plain\fs20\cf1\cb1 {\v 0CG1FT} \page
{\up #}{\footnote\pard\plain{\up #} selection transformer}
\pard {\up K}{\footnote\pard\plain{\up K} selection transformer}
\uldb filter\plain\fs20\cf1\cb1 {\v 42BZPGX} \page
{\up #}{\footnote\pard\plain{\up #} search operation}
\pard {\up K}{\footnote\pard\plain{\up K} search operation}
\uldb find\plain\fs20\cf1\cb1 {\v QD17VY} \uldb findall\plain\fs20\cf1\cb1 {\v 1U9H6P6} \uldb in\plain\fs20\cf1\cb1 {\v RJ2SC2} \uldb notin\plain\fs20\cf1\cb1 {\v 7KLHCD} \uldb seek\plain\fs20\cf1\cb1 {\v 1CMJ30E} \page
{\up #}{\footnote\pard\plain{\up #} data rearrangement operation}
\pard {\up K}{\footnote\pard\plain{\up K} data rearrangement operation}
\uldb flip\plain\fs20\cf1\cb1 {\v QD10R0} \uldb fuse\plain\fs20\cf1\cb1 {\v 40PDDJ} \uldb pack\plain\fs20\cf1\cb1 {\v QD0ZL5} \uldb reverse\plain\fs20\cf1\cb1 {\v U_.PHW} \uldb rotate\plain\fs20\cf1\cb1 {\v 72C..35} \uldb transpose\plain\fs20\cf1\cb1 {\v 2UPAHZ} \page
{\up #}{\footnote\pard\plain{\up #} control structure transformer}
\pard {\up K}{\footnote\pard\plain{\up K} control structure transformer}
\uldb fork\plain\fs20\cf1\cb1 {\v 1CM__GE} \uldb iterate\plain\fs20\cf1\cb1 {\v 11O99LP} \page
{\up #}{\footnote\pard\plain{\up #} sorting transformer}
\pard {\up K}{\footnote\pard\plain{\up K} sorting transformer}
\uldb grade\plain\fs20\cf1\cb1 {\v 3HH5325} \uldb sort\plain\fs20\cf1\cb1 {\v 1CMJ_GN} \page
{\up #}{\footnote\pard\plain{\up #} sorting operation}
\pard {\up K}{\footnote\pard\plain{\up K} sorting operation}
\uldb gradeup\plain\fs20\cf1\cb1 {\v 32WH0Y0} \uldb sortup\plain\fs20\cf1\cb1 {\v ..CSLL} \page
{\up #}{\footnote\pard\plain{\up #} comparison operation}
\pard {\up K}{\footnote\pard\plain{\up K} comparison operation}
\uldb gt\plain\fs20\cf1\cb1 {\v RJ2SA8} \uldb gte\plain\fs20\cf1\cb1 {\v 1ZNBW4K} \uldb lt\plain\fs20\cf1\cb1 {\v RJ2SF8} \uldb lte\plain\fs20\cf1\cb1 {\v 1ZNC14K} \uldb match\plain\fs20\cf1\cb1 {\v TSJGTN} \uldb mate\plain\fs20\cf1\cb1 {\v 25VOZ5O} \uldb max\plain\fs20\cf1\cb1 {\v 1_E725N} \uldb min\plain\fs20\cf1\cb1 {\v 1_E72_D} \uldb up\plain\fs20\cf1\cb1 {\v RJ2SO4} \page
{\up #}{\footnote\pard\plain{\up #} linear algebra operation}
\pard {\up K}{\footnote\pard\plain{\up K} linear algebra operation}
\uldb innerproduct\plain\fs20\cf1\cb1 {\v QPKGRK} \uldb inverse\plain\fs20\cf1\cb1 {\v W4WJKP} \uldb solve\plain\fs20\cf1\cb1 {\v 5JDV_40} \page
{\up #}{\footnote\pard\plain{\up #} system variable}
\pard {\up K}{\footnote\pard\plain{\up K} system variable}
\uldb libpath\plain\fs20\cf1\cb1 {\v 2B9J0I3} \page
{\up #}{\footnote\pard\plain{\up #} reshaping operation}
\pard {\up K}{\footnote\pard\plain{\up K} reshaping operation}
\uldb list\plain\fs20\cf1\cb1 {\v 40V8DY} \uldb mold\plain\fs20\cf1\cb1 {\v QD8_TY} \uldb pass\plain\fs20\cf1\cb1 {\v 1CMFZHM} \uldb post\plain\fs20\cf1\cb1 {\v 1CMG_HN} \uldb reshape\plain\fs20\cf1\cb1 {\v 3I4D_MA} \uldb vacate\plain\fs20\cf1\cb1 {\v 4B0Q_VK} \uldb void\plain\fs20\cf1\cb1 {\v QDA_QY} \page
{\up #}{\footnote\pard\plain{\up #} feature}
\pard {\up K}{\footnote\pard\plain{\up K} feature}
\uldb log file\plain\fs20\cf1\cb1 {\v 0G8259} \page
{\up #}{\footnote\pard\plain{\up #} debugging command}
\pard {\up K}{\footnote\pard\plain{\up K} debugging command}
\uldb next\plain\fs20\cf1\cb1 {\v 40X4IY} \uldb resume\plain\fs20\cf1\cb1 {\v 1JE1SH6} \uldb step\plain\fs20\cf1\cb1 {\v 1CMJB0J} \uldb stepin\plain\fs20\cf1\cb1 {\v YJBNWZ} \uldb toend\plain\fs20\cf1\cb1 {\v 7QL9H0} \page
{\up #}{\footnote\pard\plain{\up #} system transformer}
\pard {\up K}{\footnote\pard\plain{\up K} system transformer}
\uldb no_tr\plain\fs20\cf1\cb1 {\v 7KL1NH} \page
{\up #}{\footnote\pard\plain{\up #} system constant}
\pard {\up K}{\footnote\pard\plain{\up K} system constant}
\uldb no_value\plain\fs20\cf1\cb1 {\v 1R1EBX3} \page
{\up #}{\footnote\pard\plain{\up #} profiling operation}
\pard {\up K}{\footnote\pard\plain{\up K} profiling operation}
\uldb profile\plain\fs20\cf1\cb1 {\v FHUFEL} \uldb setprofile\plain\fs20\cf1\cb1 {\v H2UBBE} \page
{\up #}{\footnote\pard\plain{\up #} interactive input/output operation}
\pard {\up K}{\footnote\pard\plain{\up K} interactive input/output operation}
\uldb read\plain\fs20\cf1\cb1 {\v QD_3IY} \uldb readscreen\plain\fs20\cf1\cb1 {\v F7V7GJ} \uldb write\plain\fs20\cf1\cb1 {\v 5JHY020} \uldb writechars\plain\fs20\cf1\cb1 {\v 30680BN} \uldb writescreen\plain\fs20\cf1\cb1 {\v 9TD.YB} \page
{\up #}{\footnote\pard\plain{\up #} interactive input/output expression}
\pard {\up K}{\footnote\pard\plain{\up K} interactive input/output expression}
\uldb readchar\plain\fs20\cf1\cb1 {\v RSJV13} \page
{\up #}{\footnote\pard\plain{\up #} user defined operation}
\pard {\up K}{\footnote\pard\plain{\up K} user defined operation}
\uldb recover\plain\fs20\cf1\cb1 {\v 7L0TNT} \page
{\up #}{\footnote\pard\plain{\up #} string manipulation operation}
\pard {\up K}{\footnote\pard\plain{\up K} string manipulation operation}
\uldb regexp\plain\fs20\cf1\cb1 {\v 1JDPCSA} \uldb regexp_match\plain\fs20\cf1\cb1 {\v 1ZS..XB} \uldb regexp_substitute\plain\fs20\cf1\cb1 {\v 16UK_E6} \uldb string_split\plain\fs20\cf1\cb1 {\v 52CEJJX} \uldb string_translate\plain\fs20\cf1\cb1 {\v 4K0T_WX} \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0002}
{\up $}{\footnote\pard\plain{\up $} abs}
{\up #}{\footnote\pard\plain{\up #} 1_E6Q6I}
\pard\keepn \b\fs25 abs\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} abs;arithmetic operation, abs}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 abs A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 opposite\plain\fs20\cf1\cb1 {\v 18Y3XQ}\line

\par The operation \i abs\plain\fs20\cf1\cb1  produces the following results when applied to atoms of the six types: 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 corresponding integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 absolute value \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 absolute value \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 \line

\par If the argument is the largest negative integer for the computer, the result is the corresponding positive real number because the corresponding positive integer is too large for representation as an integer.  
\par \pard\keep\sb95 \f1\fs16      abs  l  -2  3.5  `a  "abc  ??error \line
1 2 3.5 ?A ?A ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The operation \i abs\plain\fs20\cf1\cb1  can be used to convert a boolean value to an integer.  Its primary use is in the numeric domains, where it is used to give a positive number measuring the size of a number.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    abs abs A = abs A \line
   abs opposite A = abs A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0003}
{\up $}{\footnote\pard\plain{\up $} accumulate}
{\up #}{\footnote\pard\plain{\up #} 2_FBXZ}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 accumulate\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} accumulate;reduction transformer, accumulate}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul reduction transformer\plain\fs20\cf1\cb1 {\v reduction transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 ACCUMULATE f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 reduce\plain\fs20\cf1\cb1 {\v 2.MYRUF}\line

\par The transformer \i accumulate\plain\fs20\cf1\cb1  is similar to the concept of scan in APL.  It computes the partial reductions of the initial lists of the items of \i A\plain\fs20\cf1\cb1 , using \i reduce f\plain\fs20\cf1\cb1  (a right-to-left reduction) to compute each partial result.  (A reductive operation is one which when applied to an array having a number of items returns a single result.) \line

\par In the example below, the \b initial lists\plain\fs20\cf1\cb1  of \i Z\plain\fs20\cf1\cb1  are: 
\par \pard\keep\sb95 \f1\fs16      [13, 13 39, 13 39 92, 13 39 92 45];\plain\fs20\cf1\cb1 \line

\par \pard\sb95 and the right-to-left reduction of \i f\plain\fs20\cf1\cb1  on \i Z\plain\fs20\cf1\cb1  is equivalent to: 
\par \pard\keep\sb95 \f1\fs16      [f 13, 13 f 39, 13 f (39 f 92), 13 f (39 f ( 92 f 45))] \line
 \line
     Z := 13 39 92 45 ; \line
     ACCUMULATE pass Z \line
+--+-----+----------+---------------+ \line
|13|13 39|+--+-----+|+--+----------+| \line
|  |     ||13|39 92|||13|+--+-----+|| \line
|  |     |+--+-----+||  ||39|92 45||| \line
|  |     |          ||  |+--+-----+|| \line
|  |     |          |+--+----------+| \line
+--+-----+----------+---------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows that accumulate builds the result values with a right-to-left reduction.  
\par \pard\keep\sb95 \f1\fs16      ACCUMULATE max Z \line
13 39 92 92 \line
 \line
     ACCUMULATE min Z \line
13 13 13 13 \line
 \line
     ACCUMULATE sum (count 10) \line
1 3 6 10 15 21 28 36 45 55 \line
 \line
     ACCUMULATE minus (count 10) \line
1 -1 2 -2 3 -3 4 -4 5 -5\plain\fs20\cf1\cb1 \line

\par \pard\sb95 Useful applications of \i accumulate\plain\fs20\cf1\cb1  include the \i accumulate sum\plain\fs20\cf1\cb1  transform used to compute a running sum, and the \i accumulate minus\plain\fs20\cf1\cb1  transform which gives an alternating sum.  
\par \pard\keep\sb95 \f1\fs16      ACCUMULATE or oollooll \line
oollllll \line
 \line
     S := '  black and white' \line
  black and white \line
 \line
     B := not (S match ` ) \line
oolllllolllolllll \line
 \line
     ACCUMULATE or B sublist S \line
black and white\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The \i accumulate or\plain\fs20\cf1\cb1  transform produces a bitstring that can be used with \i sublist\plain\fs20\cf1\cb1  to drop leading items that fail to meet a predicate.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      ACCUMULATE IS TRANSFORMER f OPERATION A \{\- \line
        heads IS OPERATION A \{\- \line
           count tally A EACHLEFT take list A\'7d; \line
        EACH REDUCE f heads A \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape ACCUMULATE f A = shape A \line
   ACCUMULATE f solitary A = solitary A \line
   ACCUMULATE f single A = single A \line
   ACCUMULATE f Null = Null \line
   ACCUMULATE f[A,B,C]=[A,A f B,A f(B f C)] \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0004}
{\up $}{\footnote\pard\plain{\up $} across}
{\up #}{\footnote\pard\plain{\up #} G9ON74}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 across\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} across;recursion transformer, across}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul recursion transformer\plain\fs20\cf1\cb1 {\v recursion transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 ACROSS [endf, parta, joinf] A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 recur\plain\fs20\cf1\cb1 {\v 7OB7OH}, \uldb down\plain\fs20\cf1\cb1 {\v 25VG_8X}\line

\par ACROSS is a general recursion transformer for traversing the length of an array. It has three operation arguments: \i endf\plain\fs20\cf1\cb1  is applied to the end argument before starting to build the result, \i parta\plain\fs20\cf1\cb1  computes the left value from the argument, which is stacked, and \i joinf\plain\fs20\cf1\cb1  combines the left and right values as the recursion unwinds. 
\par \pard\keep\sb95 \f1\fs16      ACROSS [ 0 first, pass, plus ] 3 4 5 6 \line
18 \line
     reshape [ shape, ACROSS  [pass, pass, CONVERSE append ] ] 2 15 12 4 \line
4 12 15 2 \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16 ACROSS IS TRANSFORMER endf parta joinf OPERATION A \{\- \line
\tab A := list A; \line
   \tab Res := endf void last A; \line
   \tab FOR I WITH reverse tell tally A DO \line
     \tab \tab Res := parta A@I joinf Res \line
   \tab ENDFOR \'7d \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    ACROSS [endf, parta, joinf] A = RECUR [empty, endf, parta first, joinf, rest ] list A \line
   sum A = ACROSS [ 0 first, pass, plus ] A \line
   reverse A = reshape [ shape, ACROSS  [pass, pass, CONVERSE append ] ] A \line
   EACH f A = reshape [ shape, ACROSS [ Null first, f, hitch ] ] A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0005}
{\up $}{\footnote\pard\plain{\up $} action}
{\up #}{\footnote\pard\plain{\up #} G9QH2Z}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 action\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} action;syntax, action}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 definition\plain\fs20\cf1\cb1 {\v K9LSXA}, \uldb expression sequence\plain\fs20\cf1\cb1 {\v R9CDMG}, \uldb external declaration\plain\fs20\cf1\cb1 {\v .O7OJC}, \uldb comment\plain\fs20\cf1\cb1 {\v 11TJ9BC}\line

\par An \b action\plain\fs20\cf1\cb1  is the construct that is entered in the interactive loop of the Q'Nial interpreter or accepted as an input unit within the operation loaddefs: 
\par \pard\keep\sb95 \f1\fs16      action ::= definition-sequence \line
        | expression-sequence \line
        | external-declaration \line
        | remark \line
 \line
     definition-sequence ::= definition \line
        \{\- ; definition \'7d [ ; ] \line
 \line
     remark ::= # < any text >\plain\fs20\cf1\cb1 \line

\par \pard\sb95 If an action is a definition-sequence, its definitions are installed in the global environment.  \line

\par If an action is an expression-sequence, it is executed and a value is returned.  The value returned by an expression-sequence is displayed on the screen unless it is the fault ?noexpr.  \line

\par An external-declaration assigns a role to a name in the global environment so that the name can be used in other definitions before it is completely specified.  \line

\par A remark is an input to the Q'Nial interpreter that is not processed.  It begins with a line that has the symbol # as the first non-blank character in the line.  In direct input at the top level loop, a remark ends at the end of the line unless a backslash symbol ( \'5c ) is used to extend the line.  In a definition file, a remark ends at the first blank line.  A remark cannot appear within a definition or expression-sequence.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0006}
{\up $}{\footnote\pard\plain{\up $} address}
{\up #}{\footnote\pard\plain{\up #} 63.8K7}
\pard\keepn\sb95 \b\fs25 address\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} address;concept, address}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 array\plain\fs20\cf1\cb1 {\v 28ZHDVT}, \uldb pick\plain\fs20\cf1\cb1 {\v 40Z84P}, \uldb indexing\plain\fs20\cf1\cb1 {\v 2MDYZ6S}\line

\par An \b address\plain\fs20\cf1\cb1  is an integer or a list of integers describing the location of an item in an array. An address uses 0-origin counting, i.e. the first position in a list is at address 0. All the addresses of an array can be stored in an array of the same rectangular structure as the array itself.  Such an array is called the \b grid\plain\fs20\cf1\cb1  of an array.  Consider the following example:
\par \pard\keep\sb95 \f1\fs16              GRID OF THE ARRAY                 ARRAY \line
+-----+-----+-----+-----+-----+-----+ +---+---+---+---+---+---+ \line
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+| |499|434|122|770|733|890| \line
||0|0|||0|1|||0|2|||0|3|||0|4|||0|5|| +---+---+---+---+---+---+ \line
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+| |660|160| 32|808|240|584| \line
+-----+-----+-----+-----+-----+-----+ +---+---+---+---+---+---+ \line
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+| |473|235|164|496|808|966| \line
||1|0|||1|1|||1|2|||1|3|||1|4|||1|5|| +---+---+---+---+---+---+ \line
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+| |156|205| 34|576|236|454| \line
+-----+-----+-----+-----+-----+-----+ +---+---+---+---+---+---+ \line
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|  \line
||2|0|||2|1|||2|2|||2|3|||2|4|||2|5|| \line
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+| \line
+-----+-----+-----+-----+-----+-----+ \line
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+| \line
||3|0|||3|1|||3|2|||3|3|||3|4|||3|5|| \line
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+| \line
+-----+-----+-----+-----+-----+-----+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The array on the right is a 4 by 6 table of numbers.  It has 24 items arranged along two directions of length 4 and 6 respectively.  The address of 496 is [2,3].  \line

\par The addresses of a \i list\plain\fs20\cf1\cb1  are integers: 0, 1, etc.  For convenience, in situations where an address of a list is expected, a solitary integer is treated as an integer.  \line

\par The address of a \i single\plain\fs20\cf1\cb1  is the empty list \i Null\plain\fs20\cf1\cb1 .\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0007}
{\up $}{\footnote\pard\plain{\up $} allbools}
{\up #}{\footnote\pard\plain{\up #} 211AO05}
\pard\keepn\sb95 \b\fs25 allbools\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} allbools;measurement operation, allbools}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 allbools A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 allints\plain\fs20\cf1\cb1 {\v 6C8I_GF}, \uldb allreals\plain\fs20\cf1\cb1 {\v 21A7A05}, \uldb allchars\plain\fs20\cf1\cb1 {\v 7CQD_O4}, \uldb allnumeric\plain\fs20\cf1\cb1 {\v LCHPGK}\line

\par The operation \i allbools\plain\fs20\cf1\cb1  tests whether or not \i A\plain\fs20\cf1\cb1  is a nonempty array of boolean items.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is not empty and all the items of \i A\plain\fs20\cf1\cb1  are boolean atoms, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      allbools lool \line
l \line
     allbools 1 0 1 \line
o \line
     allbools Null \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 \line

\par allbools IS OPERATION A \{\- and EACH isboolean A and not empty A \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0008}
{\up $}{\footnote\pard\plain{\up $} allchars}
{\up #}{\footnote\pard\plain{\up #} 7CQD_O4}
\pard\keepn\sb95 \b\fs25 allchars\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} allchars;measurement operation, allchars}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 allchars A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 allbools\plain\fs20\cf1\cb1 {\v 211AO05}, \uldb allints\plain\fs20\cf1\cb1 {\v 6C8I_GF}, \uldb allreals\plain\fs20\cf1\cb1 {\v 21A7A05}, \uldb allnumeric\plain\fs20\cf1\cb1 {\v LCHPGK}\line

\par The operation \i allchars\plain\fs20\cf1\cb1  tests whether or not \i A\plain\fs20\cf1\cb1  is a nonempty array of character items.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is not empty and all the items of \i A\plain\fs20\cf1\cb1  are character atoms, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      allchars 'apple pie' \line
l \line
     allchars "today \line
o \line
     allchars Null \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 \line

\par allchars IS OPERATION A \{\- and EACH ischar A and not empty A \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0009}
{\up $}{\footnote\pard\plain{\up $} allin}
{\up #}{\footnote\pard\plain{\up #} 5J2S.RC}
\pard\keepn\sb95 \b\fs25 allin\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} allin;set-like operation, allin}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul set-like operation\plain\fs20\cf1\cb1 {\v set-like operation}
\par \pard\sb95 \b Properties:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}, \uldb predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A allin B   allin A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 in\plain\fs20\cf1\cb1 {\v RJ2SC2}, \uldb like\plain\fs20\cf1\cb1 {\v 40V8.J}, \uldb notin\plain\fs20\cf1\cb1 {\v 7KLHCD}\line

\par The operation \i allin\plain\fs20\cf1\cb1  tests whether or not all the items of array \i A\plain\fs20\cf1\cb1  are also items of array \i B\plain\fs20\cf1\cb1 .  The result is \i true\plain\fs20\cf1\cb1  if the test holds and \i false\plain\fs20\cf1\cb1  if it does not.  
\par \pard\keep\sb95 \f1\fs16      3 5 7 allin count 10 \line
l \line
     'ae' allin 'where are you?' \line
l \line
     'where' allin 'hear' \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The items of \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  are compared for exact equality, including type.  The items being compared may be atoms or they may be any other array.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      allin IS OPERATION A B \{\- and ( A EACHLEFT in B ) \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A allin B = (list A) allin (list B) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:000a}
{\up $}{\footnote\pard\plain{\up $} allints}
{\up #}{\footnote\pard\plain{\up #} 6C8I_GF}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 allints\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} allints;measurement operation, allints}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 allints A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 allbools\plain\fs20\cf1\cb1 {\v 211AO05}, \uldb allreals\plain\fs20\cf1\cb1 {\v 21A7A05}, \uldb allchars\plain\fs20\cf1\cb1 {\v 7CQD_O4}, \uldb allnumeric\plain\fs20\cf1\cb1 {\v LCHPGK}\line

\par The operation \i allints\plain\fs20\cf1\cb1  tests whether or not \i A\plain\fs20\cf1\cb1  is a nonempty array of integer items.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is not empty and all the items of \i A\plain\fs20\cf1\cb1  are integer atoms, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      allints lool \line
o \line
     allints 1 0 25 \line
l \line
     allints Null \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 \line

\par allints IS OPERATION A \{\- and EACH isinteger A and not empty A \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:000b}
{\up $}{\footnote\pard\plain{\up $} allnumeric}
{\up #}{\footnote\pard\plain{\up #} LCHPGK}
\pard\keepn\sb95 \b\fs25 allnumeric\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} allnumeric;measurement operation, allnumeric}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 allnumeric A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 allints\plain\fs20\cf1\cb1 {\v 6C8I_GF}, \uldb allreals\plain\fs20\cf1\cb1 {\v 21A7A05}, \uldb allbools\plain\fs20\cf1\cb1 {\v 211AO05}, \uldb numeric\plain\fs20\cf1\cb1 {\v K7MN2O}\line

\par The operation \i allnumeric\plain\fs20\cf1\cb1  tests whether or not \i A\plain\fs20\cf1\cb1  is a nonempty array with all atoms of the same numeric type.   It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is not empty and all items are boolean atoms, or all are integer atoms or all are real atoms, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      allnumeric 3.5 -2.97 \line
l \line
     allnumeric l 45 3.78 \line
o \line
     allnumeric Null \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 \line

\par allnumeric IS OPERATION A \{\- allbools A or allints A or allreals A \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:000c}
{\up $}{\footnote\pard\plain{\up $} allreals}
{\up #}{\footnote\pard\plain{\up #} 21A7A05}
\pard\keepn\sb95 \b\fs25 allreals\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} allreals;measurement operation, allreals}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 allreals A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 allbools\plain\fs20\cf1\cb1 {\v 211AO05}, \uldb allints\plain\fs20\cf1\cb1 {\v 6C8I_GF}, \uldb allchars\plain\fs20\cf1\cb1 {\v 7CQD_O4}, \uldb allnumeric\plain\fs20\cf1\cb1 {\v LCHPGK}\line

\par The operation \i allreals\plain\fs20\cf1\cb1  tests whether or not \i A\plain\fs20\cf1\cb1  is a nonempty array of real items.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is not empty and all the items of \i A\plain\fs20\cf1\cb1  are real atoms, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      allreals 2 2.5 47.9 \line
o \line
     allreals 2.5 -7.8 27.3 \line
l \line
     allreals Null \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 \line

\par allreals IS OPERATION A \{\- and EACH isreal A and not empty A \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:000d}
{\up $}{\footnote\pard\plain{\up $} and}
{\up #}{\footnote\pard\plain{\up #} 1_E6QB0}
\pard\keepn\sb95 \b\fs25 and\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} and;logic operation, and}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul logic operation\plain\fs20\cf1\cb1 {\v logic operation}
\par \pard\sb95 \b Properties:  \uldb \plain\uldb\fs20\cf1\cb1 multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}, \uldb reductive\plain\fs20\cf1\cb1 {\v 7GGROL}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 and A   A and B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 or\plain\fs20\cf1\cb1 {\v RJ2SI6}, \uldb not\plain\fs20\cf1\cb1 {\v 1_E73CJ}\line

\par The operation \i and\plain\fs20\cf1\cb1  applied to a boolean array \i A\plain\fs20\cf1\cb1  does the boolean product of its items.  If all items of \i A\plain\fs20\cf1\cb1  are \i true\plain\fs20\cf1\cb1 , the result is \i true\plain\fs20\cf1\cb1 ; otherwise it is \i false\plain\fs20\cf1\cb1 .  In binary form and implements the and-connective of logic.  \line

\par If \i A\plain\fs20\cf1\cb1  is a simple array and has a non-boolean item, the result is the logical fault \i ?L\plain\fs20\cf1\cb1 .  The operation extends to non-simple arrays by the multi pervasive mechanism.  
\par \pard\keep\sb95 \f1\fs16      l and l \line
l \line
 \line
     and llllloll \line
o \line
 \line
     lloo and lolo \line
looo\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \i And\plain\fs20\cf1\cb1  is a reductive operation in that it reduces an array of booleans to a single boolean.  If its argument is a pair of bitstrings or a list of bitstrings, \i and\plain\fs20\cf1\cb1  is applied to bits in corresponding positions of each item of the argument producing a bitstring of the same length as one of the items of its argument.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A and B = B and A \line
   not and A =f= or EACH not A \line
   and Null = True \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:000e}
{\up $}{\footnote\pard\plain{\up $} append}
{\up #}{\footnote\pard\plain{\up #} GFMD1P}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 append\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} append;construction operation, append}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul construction operation\plain\fs20\cf1\cb1 {\v construction operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A append B   append A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 hitch\plain\fs20\cf1\cb1 {\v TNRGTN}, \uldb link\plain\fs20\cf1\cb1 {\v QD77W5}\line

\par The operation \i append\plain\fs20\cf1\cb1  attaches \i B\plain\fs20\cf1\cb1  to the end of the list of items of \i A\plain\fs20\cf1\cb1 .  It returns a list of length one greater than the \i tally\plain\fs20\cf1\cb1  of \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      (2 3 4) append (5 6 7) \line
+-+-+-+-----+ \line
|2|3|4|5 6 7| \line
+-+-+-+-----+ \line
 \line
     append '' 'Wow' \line
+---+ \line
|Wow| \line
+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows list (5 6 7) appended to list (2 3 4).  The second example shows that if an array is appended to an empty list, the result is the solitary of the second argument.  If \i append\plain\fs20\cf1\cb1  is applied to an array that is not a pair, a fault is returned.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      append IS OPERATION A B \{\- A link solitary B \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A append B = ( list A ) append B \line
   Null append A = solitary A \line
   A append B = list (A append B) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:000f}
{\up $}{\footnote\pard\plain{\up $} appendfile}
{\up #}{\footnote\pard\plain{\up #} 3AAL9Q}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 appendfile\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} appendfile;file operation, appendfile}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul file operation\plain\fs20\cf1\cb1 {\v file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 appendfile Filename A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 putfile\plain\fs20\cf1\cb1 {\v IMUFEL}, \uldb getfile\plain\fs20\cf1\cb1 {\v 45R7_SO}\line

\par The operation \i appendfile\plain\fs20\cf1\cb1  writes a list of character arrays \i A\plain\fs20\cf1\cb1  to the end of the file named \i Filename\plain\fs20\cf1\cb1 , using one line of the file for each row in the items of \i A\plain\fs20\cf1\cb1 .  If the file does not exist, it is created by the operation.  The file must not be open.  \line

\par \i Appendfile\plain\fs20\cf1\cb1  is similar to operation \i putfile\plain\fs20\cf1\cb1  except that \i putfile\plain\fs20\cf1\cb1  overwrites an existing file.  \i Getfile\plain\fs20\cf1\cb1  reads a file containing text records.  
\par \pard\keep\sb95 \f1\fs16      putfile "Mailing ['1','2','3']; \line
     appendfile "Mailing ['Mr. Jones','123 Main St','New York NY 12345']; \line
     getfile "Mailing \line
+-+-+-+---------+-----------+-----------------+ \line
|1|2|3|Mr. Jones|123 Main St|New York NY 12345| \line
+-+-+-+---------+-----------+-----------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      appendfile IS OPERATION Filename A \{\- \line
        Fnum := open Filename "a ; \line
        ITERATE (Fnum writefile) (link EACH rows A) ; \line
        close Fnum ; \'7d\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0010}
{\up $}{\footnote\pard\plain{\up $} apply}
{\up #}{\footnote\pard\plain{\up #} TGYD34}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 apply\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} apply;evaluation operation, apply}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Op apply A   apply Op A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 eval\plain\fs20\cf1\cb1 {\v 40OE2Q}, \uldb execute\plain\fs20\cf1\cb1 {\v 3WULI4D}, \uldb value\plain\fs20\cf1\cb1 {\v 5JGH_30}, \uldb cast\plain\fs20\cf1\cb1 {\v 1CM9ZHN}\line

\par The operation \i apply\plain\fs20\cf1\cb1  carries out the application of the operation represented by the array \i Op\plain\fs20\cf1\cb1  to array \i A\plain\fs20\cf1\cb1 .  \i Op\plain\fs20\cf1\cb1  may be a phrase or string that names a predefined or user-defined operation or it may be the \i cast\plain\fs20\cf1\cb1  of an operation expression.  \line

\par If the operation is represented by a phrase or string giving its name, the name is sought in the environment where \i apply\plain\fs20\cf1\cb1  is being used.  
\par \pard\keep\sb95 \f1\fs16      apply "second (3 4 5) \line
4\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The operation to be applied may also be represented by the \i parse tree\plain\fs20\cf1\cb1  or \i cast\plain\fs20\cf1\cb1  for the operation expression.  If the cast is a name, it is sought in the environment where the cast appears.  In the following example, \i !first\plain\fs20\cf1\cb1  is the cast of the operation \i first\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      (!first apply 3 4 5) \line
3 \line
 \line
     apply !(first rest) (3 4 5) \line
4\plain\fs20\cf1\cb1 \line

\par \pard\sb95 As seen in the second example, an operation expression does not have to be named in order to be used with \i apply\plain\fs20\cf1\cb1 .  The entire first example is enclosed in parentheses to avoid conflict with the notation for executing a host command.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0011}
{\up $}{\footnote\pard\plain{\up $} arccos}
{\up #}{\footnote\pard\plain{\up #} 19QLAJD}
\pard\keepn\sb95 \b\fs25 arccos\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arccos;scientific operation, arccos}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 arccos A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 cos\plain\fs20\cf1\cb1 {\v 1_E6SCI}, \uldb cosh\plain\fs20\cf1\cb1 {\v 1CM0_HB}, \uldb arcsin\plain\fs20\cf1\cb1 {\v 2I99PH4}, \uldb pi\plain\fs20\cf1\cb1 {\v RJ2SIX}\line

\par The operation \i arccos\plain\fs20\cf1\cb1  is the inverse of \i cos\plain\fs20\cf1\cb1  in the numeric domain.  It produces the following results when applied to atoms of the six types: 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 arccosine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 arccosine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 the angle B in radians such that cos B = A, if A is in the range -1 to 1; otherwise the fault ?arccos \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?arccos \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?arccos \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      arccos l -2 0.35 \line
0. ?arccos 1.21323 \line
 \line
     arccos `a "abc ??error \line
?arccos ?arccos ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      arccos IS OPERATION A ( Pi / 2.0 - arcsin A )\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    cos arccos cos A = cos A (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0012}
{\up $}{\footnote\pard\plain{\up $} arcsin}
{\up #}{\footnote\pard\plain{\up #} 2I99PH4}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 arcsin\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arcsin;scientific operation, arcsin}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 arcsin A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 sin\plain\fs20\cf1\cb1 {\v 1_E78_D}, \uldb sinh\plain\fs20\cf1\cb1 {\v 1CMJ7CB}, \uldb arctan\plain\fs20\cf1\cb1 {\v 1VZXQSO}, \uldb pi\plain\fs20\cf1\cb1 {\v RJ2SIX}\line

\par The operation \i arcsin\plain\fs20\cf1\cb1  is the inverse of \i sin\plain\fs20\cf1\cb1  in the numeric domain.  It produces the following results when applied to atoms of the six types: 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 arcsine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 arcsine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 the angle B in radians such that sin B = A, if A is in the range -1 to 1; otherwise, the fault ?arcsin \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?arcsin \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?arcsin \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      arcsin l -2 0.35 \line
1.5708 ?arcsin 0.357571 \line
 \line
     arcsin `a "abc ??error \line
?arcsin ?arcsin ?error \line
 \line
     arcsin l 1 .5 \line
1.5708 1.5708 0.523599\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    sin arcsin sin A = sin A   (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0013}
{\up $}{\footnote\pard\plain{\up $} arctan}
{\up #}{\footnote\pard\plain{\up #} 1VZXQSO}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 arctan\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arctan;scientific operation, arctan}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 arctan A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 tan\plain\fs20\cf1\cb1 {\v 1_E795D}, \uldb tanh\plain\fs20\cf1\cb1 {\v 1CMJZCB}, \uldb arcsin\plain\fs20\cf1\cb1 {\v 2I99PH4}, \uldb pi\plain\fs20\cf1\cb1 {\v RJ2SIX}\line

\par The operation \i arctan\plain\fs20\cf1\cb1  is the inverse of \i tan\plain\fs20\cf1\cb1  in the numeric domain.  It produces the following results when applied to atoms of the six types: 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 arctangent of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 arctangent of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 angle B in radians where tan B = A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?arctan \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?arctan \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      arctan l -2 0.35 \line
0.785398 -1.10715 0.336675 \line
 \line
     arctan `a "abc ??error \line
?arctan ?arctan ?error \line
 \line
     arctan 2. l 1 .5 \line
1.10715 0.785398 0.785398 0.463648\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    tan arctan tan A = tan A   (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0014}
{\up $}{\footnote\pard\plain{\up $} argument}
{\up #}{\footnote\pard\plain{\up #} C4.J_2}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 argument\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} argument;concept, argument}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 operation\plain\fs20\cf1\cb1 {\v CQFG7.}\line

\par An \b argument\plain\fs20\cf1\cb1  is an array value supplied to an operation. All operations in Nial take a single array as the argument, but binary operations expect that argument to be a pair. When an operation is used in infix syntax, then the two array values on the left and right are combined into a pair to be supplied as the argument to the operation.\line

\par The argument to an operation-form is treated specially. If the operation-form has only one formal parameter then the argument is assigned to the parameter. If it has two or more formal parameters, then the argument is checked to see if it has the same number of items as there are parameters. If so, the items are assigned to the parameters. If not, the result is the fault \i ?op_parameter\plain\fs20\cf1\cb1 .\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0015}
{\up $}{\footnote\pard\plain{\up $} array}
{\up #}{\footnote\pard\plain{\up #} 28ZHDVT}
\pard\keepn\sb95 \b\fs25 array\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} array;concept, array}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 item\plain\fs20\cf1\cb1 {\v 40SC6R}, \uldb address\plain\fs20\cf1\cb1 {\v 63.8K7}, \uldb dimensions\plain\fs20\cf1\cb1 {\v 12_I6ZM}\line

\par The data objects of Nial are nested rectangular arrays. Atomic data objects such as numbers and characters are included within this description by virtue of an atom being considered as a self-containing array object with no dimensions.\line

\par \b Atomic Arrays\plain\fs20\cf1\cb1 \line

\par There are six types of atoms in Nial. They are \i boolean\plain\fs20\cf1\cb1 , \i integer\plain\fs20\cf1\cb1 , \i real\plain\fs20\cf1\cb1 , \i character\plain\fs20\cf1\cb1 , \i phrase\plain\fs20\cf1\cb1  and \i fault\plain\fs20\cf1\cb1 .  The first three are \b numeric\plain\fs20\cf1\cb1  types and are used for arithmetic operations. The last three are \b literal\plain\fs20\cf1\cb1  types and are used for text and symbol manipulation. All six types of atoms are used in comparisons.\line

\par \pard\sb95 \b Rectangularity Structure\plain\fs20\cf1\cb1 \line

\par An \b array\plain\fs20\cf1\cb1  is a collection of data objects having its \b items\plain\fs20\cf1\cb1  held at locations in a rectangular structure. The items are viewed as being at locations that are positioned relative to a set of directions at right angles to each other.  The items may be arranged along zero, one, two or more directions. For example, the following array is a 4 by 6 table of numbers. It has 24 items arranged along two directions of length 4 and 6 respectively.
\par \pard\keep\sb95 \f1\fs16                    +---+---+---+---+---+---+ \line
                   |499|434|122|770|733|890| \line
                   +---+---+---+---+---+---+ \line
                   |660| 32|808| 24|  5|473| \line
                   +---+---+---+---+---+---+ \line
                   |499|434|122|770|733|890| \line
                   +---+---+---+---+---+---+ \line
                   |660| 32|808| 24|  5|473| \line
                   +---+---+---+---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The items of an array are themselves arrays. Thus, an array can have an arbitrarily deep nesting structure.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0016}
{\up $}{\footnote\pard\plain{\up $} assign}
{\up #}{\footnote\pard\plain{\up #} GIPGUZ}
\pard\keepn\sb95 \b\fs25 assign\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} assign;evaluation operation, assign}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Nm assign A   assign Nm A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 update\plain\fs20\cf1\cb1 {\v 4AIR_VK}, \uldb place\plain\fs20\cf1\cb1 {\v TVU4TK}, \uldb value\plain\fs20\cf1\cb1 {\v 5JGH_30}, \uldb assign expression\plain\fs20\cf1\cb1 {\v LWL7E5}\line

\par The operation \i assign\plain\fs20\cf1\cb1  assigns the value of \i A\plain\fs20\cf1\cb1  to the variable named by \i Nm\plain\fs20\cf1\cb1 .  \i Nm\plain\fs20\cf1\cb1  may be a phrase or string (e.g.  \i "X\plain\fs20\cf1\cb1  or \i 'X'\plain\fs20\cf1\cb1 ), in which case the named variable is sought in the current environment; or it may be the cast of a name (e.g.  \i !X\plain\fs20\cf1\cb1 ), in which case it is sought in the environment in which it was cast.  If the variable is found, its value is replaced by the array \i A\plain\fs20\cf1\cb1 .  Otherwise, a variable with that name is created in the global environment and given \i A\plain\fs20\cf1\cb1  as its value.  \line

\par \pard\sb95 Any phrase may be used as a variable name with the operation \i assign\plain\fs20\cf1\cb1 .  Thus, it is possible to assign a value to names which are invalid identifiers.  The associated value can be retrieved using the operation \i value\plain\fs20\cf1\cb1 .  The result of the operation is \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      assign "X (2 3 4) \line
2 3 4 \line
 \line
     (!Var assign 2 3 4) \line
2 3 4\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the first example, the variable \i X\plain\fs20\cf1\cb1  is assigned the list 2 3 4.  If this is done in an environment where \i X\plain\fs20\cf1\cb1  is a local variable, the local variable is updated.  If \i X\plain\fs20\cf1\cb1  does not exist, it is created in the global environment.  \line

\par In the second example, a variable \i Var\plain\fs20\cf1\cb1  must exist in the environment where the cast is done.  The cast can be formed in a more global environment and passed into an operation as a parameter (This technique is called \b by-variable\plain\fs20\cf1\cb1  parameter passing).  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0017}
{\up $}{\footnote\pard\plain{\up $} assign expression}
{\up #}{\footnote\pard\plain{\up #} LWL7E5}
\pard\keepn\sb95 \b\fs25 assign expression\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} assign expression;syntax, assign expression}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 variable\plain\fs20\cf1\cb1 {\v 4QO4_OO}, \uldb expression\plain\fs20\cf1\cb1 {\v FD5QFK}, \uldb indexing\plain\fs20\cf1\cb1 {\v 2MDYZ6S}, \uldb assign\plain\fs20\cf1\cb1 {\v GIPGUZ}
\par \pard\keep\sb95 \f1\fs16      assign-expression ::= \line
        \{\- variable \'7d+ := expression \line
        | indexed-variable := expression\plain\fs20\cf1\cb1 \line

\par \pard\sb95 An \b assign-expression\plain\fs20\cf1\cb1  assigns an array value to one or more variables at the time of evaluation of the assign expression.  The semantics of an assign expression is interpreted in two stages: when the expression is analyzed (parsed) and when it is executed.  \line

\par During the parse of the assign-expression appearing in a block, each name on the variable list is sought in the local environment.  If the name exists in the local environment, the assignment affects the local association.  If a name does not exist in the local environment and no reference has been made to a nonlocal variable with the same name, a local variable is created in the block.  An assign-expression parsed in the global environment creates a global variable if a variable with that name does not already exist.  \line

\par \pard\sb95 When an assign expression is executed, the expression on the right of the assignment symbol ( := ) is evaluated.  If the variable list on the left has only one name, the value of the expression is assigned to that variable.  That is, the value is associated with that name.  \line

\par If the variable list has several names, the items of the value are assigned to the variables in the order in which they appear.  If the number of items does not match the number of variables, the fault ?assignment is returned as the value of the assign-expression.  Otherwise, the value of the assign-expression is the value of the expression on the right.  \line

\par \pard\sb95 When an indexed-variable is used on the left in an assign-expression, the parts of the array associated with the variable at the locations specified by the index are replaced by the values of the expression on the right.  \line

\par If the index expression for an indexed-variable assignment specifies a number of locations (at-all or slice indexing), there are two cases: if the value on the right is a single, the item of the single is placed in each location; otherwise, the value on the right must have the same number of items as the index expression indicates and the corresponding locations are updated with the items of the array value.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0018}
{\up $}{\footnote\pard\plain{\up $} atlas}
{\up #}{\footnote\pard\plain{\up #} 3HB7_ZC}
\pard\keepn\sb95 \b\fs25 atlas\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} atlas;syntax, atlas}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 operation\plain\fs20\cf1\cb1 {\v CQFG7.}
\par \pard\keep\sb95 \f1\fs16      atlas ::= [ operation-expression \{\- , operation-expression \'7d ]\plain\fs20\cf1\cb1 \line

\par \pard\sb95 An \b atlas\plain\fs20\cf1\cb1  is an operation made up of a list of component operations.  The result of applying an atlas is a list of the same length as the atlas.  Each operation in the atlas is applied in turn to the argument resulting in an array value that becomes the item of the result list in the corresponding position.  An atlas is used by the transformers \i FORK, INNER\plain\fs20\cf1\cb1  and \i TEAM\plain\fs20\cf1\cb1 .     \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0019}
{\up $}{\footnote\pard\plain{\up $} atomic}
{\up #}{\footnote\pard\plain{\up #} GJLKWO}
\pard\keepn\sb95 \b\fs25 atomic\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} atomic;structure testing operation, atomic}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul structure testing operation\plain\fs20\cf1\cb1 {\v structure testing operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 atomic A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 simple\plain\fs20\cf1\cb1 {\v 1KHVNG6}, \uldb leaf\plain\fs20\cf1\cb1 {\v 40V42K}\line

\par The operation \i atomic\plain\fs20\cf1\cb1  tests whether or not its argument is an atom.  It returns \i true\plain\fs20\cf1\cb1  if it is and \i false\plain\fs20\cf1\cb1  if it is not.  
\par \pard\keep\sb95 \f1\fs16      atomic 3.5 \line
l \line
     atomic "hello \line
l \line
     atomic 'hello' \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The examples illustrate that a number and a phrase are atoms and that a string is not an atom.  \line

\par An atom is a primitive concept in array theory and Nial.  Atoms are distinguished from other arrays by the property that they are self nesting.  The definition of atomic is based on this property.\line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      atomic IS OPERATION A \{\- first A = A \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    atomic A <==> single A equal A \line
   and EACH atomic A = simple A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:001a}
{\up $}{\footnote\pard\plain{\up $} axes}
{\up #}{\footnote\pard\plain{\up #} 40KG6X}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 axes\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} axes;measurement operation, axes}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 axes A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 valence\plain\fs20\cf1\cb1 {\v MQJNXM}, \uldb tell\plain\fs20\cf1\cb1 {\v 1CMK3AF}\line

\par The operation \i axes\plain\fs20\cf1\cb1  generates a list of axis numbers for the array \i A\plain\fs20\cf1\cb1  counting from zero.  
\par \pard\keep\sb95 \f1\fs16      axes tell 3 4 5 \line
0 1 2\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      axes IS OPERATION A \{\- tell valence A \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    tally axes A = tally shape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:001b}
{\up $}{\footnote\pard\plain{\up $} binary}
{\up #}{\footnote\pard\plain{\up #} 3YC1_U4}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 binary\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} binary;operation property, binary}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul operation property\plain\fs20\cf1\cb1 {\v operation property}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A f B   f A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}\line

\par An operation is said to \i binary\plain\fs20\cf1\cb1  if it must have exactly two items in its argument. Many of the built-in operations of Nial are binary. They can be used in both an infix and prefix manner.  If a binary operation \i f\plain\fs20\cf1\cb1  is used in infix syntax then the arguments on each side of \i f\plain\fs20\cf1\cb1  are treated as the two items of its argument.
\par \pard\keep\sb95 \f1\fs16      3 reshape 5\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In prefix usage, \i f\plain\fs20\cf1\cb1  can precede a single array with two items, or an explicit pair formed with strand notation or bracket-comma notation.
\par \pard\keep\sb95 \f1\fs16      X := 3 5; \line
     reshape X \line
5 5 5 \line
 \line
     reshape 3 5 \line
5 5 5 \line
 \line
     reshape [3,5] \line
5 5 5 \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:001c}
{\up $}{\footnote\pard\plain{\up $} binary pervasive}
{\up #}{\footnote\pard\plain{\up #} 1ML7BXF}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} binary pervasive;operation property, binary pervasive}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul operation property\plain\fs20\cf1\cb1 {\v operation property}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A f B   f A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}, \uldb unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}, \uldb multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}, \uldb pervasive\plain\fs20\cf1\cb1 {\v 4E_0R6}, \uldb eachboth\plain\fs20\cf1\cb1 {\v 1R110IM}, \uldb pack\plain\fs20\cf1\cb1 {\v QD0ZL5}\line

\par Each operation \i f\plain\fs20\cf1\cb1  in this class maps a pair of atoms to an atom.  \line

\par A binary pervasive operation maps two arrays having identical structure to one with the same structure, mapping each pair of corresponding atoms by the function's behaviour on pairs of atoms.  \line

\par All of the binary operations of arithmetic and logic are binary pervasive.  \line

\par \pard\sb95 If a binary pervasive operation is applied to a pair of arrays that do not have the same shape, the effect is to build a conformable pair by replicating an atom or solitary item of the pair to the shape of the other item.  If both items are of unequal shape and if both items are made up of more than one item, the fault \i ?conform\plain\fs20\cf1\cb1  is returned.  The replication of an argument with one item provides binary pervasive operations with a scalar extension capability.  For example, 
\par \pard\keep\sb95 \f1\fs16      3 4 5 6 - 5 = (3 4 5 6 - 5 5 5 5) \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 If a binary pervasive operation is applied to an array that is not a pair, a fault is returned.  \line

\par The following table lists the binary pervasive operations.
\par  \trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 \b Operation \cell\pard \pard\intbl\sb95 Function  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 divide \cell\pard \pard\intbl\sb95 division of numbers  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 gt \cell\pard \pard\intbl\sb95 greater than comparison  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 gte \cell\pard \pard\intbl\sb95 greater than or equal comparison  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 lt \cell\pard \pard\intbl\sb95 less than comparison  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 lte \cell\pard \pard\intbl\sb95 less than or equal comparison  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 match \cell\pard \pard\intbl\sb95 equality of atoms without type coercion  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 mate \cell\pard \pard\intbl\sb95 equality of atoms with type coercion  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 minus \cell\pard \pard\intbl\sb95 subtraction of numbers  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 mod \cell\pard \pard\intbl\sb95 remainder on division of integers  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 plus \cell\pard \pard\intbl\sb95 addition of numbers  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 quotient \cell\pard \pard\intbl\sb95 quotient on division of integers  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 times \cell\pard \pard\intbl\sb95 multiplication of numbers divide division of numbers  \cell\intbl\row
\pard\sb95 \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A f B = A EACHBOTH f B \line
   A f B = EACH f (A pack B) \line
   shape (A f B) = shape pack A B \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:001d}
{\up $}{\footnote\pard\plain{\up $} blend}
{\up #}{\footnote\pard\plain{\up #} THU94J}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 blend\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} blend;nesting restructuring operation, blend}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nesting restructuring operation\plain\fs20\cf1\cb1 {\v nesting restructuring operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A blend B   blend A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 split\plain\fs20\cf1\cb1 {\v 5JDW.RI}, \uldb mix\plain\fs20\cf1\cb1 {\v 1_E72_N}, \uldb rank\plain\fs20\cf1\cb1 {\v QD.ZW5}\line

\par The operation \i blend\plain\fs20\cf1\cb1  combines the top two levels of an array \i B\plain\fs20\cf1\cb1  into a single level blending the axes of the second level of \i B\plain\fs20\cf1\cb1  into the combined level according to the axis numbers given in \i A\plain\fs20\cf1\cb1 .  The items of \i B\plain\fs20\cf1\cb1  must be of the same shape.  \line

\par If the array \i B\plain\fs20\cf1\cb1  is equivalent to \i A split C\plain\fs20\cf1\cb1  for some array \i C\plain\fs20\cf1\cb1 , the result of \i A blend B\plain\fs20\cf1\cb1  is \i C\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 The tally of \i A\plain\fs20\cf1\cb1  is the valence of an item of \i B\plain\fs20\cf1\cb1 .  The items of \i A\plain\fs20\cf1\cb1  indicate where the axes of the items of \i B\plain\fs20\cf1\cb1  are placed in the shape of the result.  
\par \pard\keep\sb95 \f1\fs16      C := (2 4 3 reshape count 24) ; \line
     B := 2 0 split C \line
+----+----+----+-----+ \line
|1 13|4 16|7 19|10 22| \line
|2 14|5 17|8 20|11 23| \line
|3 15|6 18|9 21|12 24| \line
+----+----+----+-----+ \line
 \line
     C := 2 0 blend B \line
 1  2  3   13 14 15 \line
 4  5  6   16 17 18 \line
 7  8  9   19 20 21 \line
10 11 12   22 23 24\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the example, \i B\plain\fs20\cf1\cb1  is a list of four tables of shape 3 2 created by a \i 2 0 split\plain\fs20\cf1\cb1 .  The result of \i 2 0 blend B\plain\fs20\cf1\cb1  is the array of valence 3 that is the second argument to \i split\plain\fs20\cf1\cb1 .  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    SORT <= list I = axes A and not empty A ==> I blend (I split A) = A \line
   equal EACH shape A and not empty A ==> (valence A+axes first A) blend A = mix A \line
   A blend B =f= [Null,A] PARTITION first B \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:001e}
{\up $}{\footnote\pard\plain{\up $} block}
{\up #}{\footnote\pard\plain{\up #} THUBTQ}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 block\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} block;syntax, block}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 local environment\plain\fs20\cf1\cb1 {\v BN.OFR}, \uldb scope of a variable\plain\fs20\cf1\cb1 {\v 42GY_XT}, \uldb nested definition\plain\fs20\cf1\cb1 {\v 1TSSBWU}
\par \pard\keep\sb95 \f1\fs16      block ::= \line
        \{\- [ LOCAL \{\- identifier-sequence \'7d+ ; ] \line
     [ NONLOCAL \{\- identifier-sequence \'7d+ ; ] \line
     [ definition-sequence ; ] \line
       expression-sequence \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 A \b block\plain\fs20\cf1\cb1  is a scope-creating mechanism that permits an expression-sequence to be created so that it has local definitions and variables which are visible only inside the block.  A block may appear as a primary-expression or as the body of an operation-form.  \line

\par A local environment is a collection of associations that are known within a limited section of program text.  These limited sections are formed by blocks, operation-forms and transformer-forms.  A name that has a local association in one of these forms is said to have local scope.  \line

\par \pard\sb95 If the definition appears within a block, the association is made in the local environment.  Otherwise, the association is made in the global environment and assigns a role to the name as representing that kind of expression.  \line

\par If a block is used as a primary-expression, the local environment created by a block is determined by the block itself.  If it is the body of an operation-form, the local environment includes the formal parameter names of the operation-form as variables.  \line

\par \pard\sb95 \b Local and Nonlocal Declaration \plain\fs20\cf1\cb1 \line

\par The identifiers included in the local and nonlocal declarations are declared to be variables.  Both forms of declarations are optional, but if both are given, local declarations must be made first.  If the block is the body of a globally defined operation-form or expression, a nonlocal declaration effectively declares its variables as global ones.  \line

\par A block delimits a local environment.  It allows new uses of names which do not interfere with uses of those names outside the block.  For example, within a block, a predefined operation name can be redefined and used for a different purpose.  Only the reserved words of Q'Nial cannot be reused in this fashion.  \line

\par \pard\sb95 Definitions that appear within the block have local scope.  That is, the definitions can be referenced only in the body of the block.  Variables assigned within the block may or may not have local scope, depending on the appearance of a local and/or a nonlocal declaration.  If there is no declaration, all assigned variables have local scope.  Declaring some variables as local does not change the effect on undeclared variables that are used on the left of assignment.  They are automatically localized.  \line

\par \pard\sb95 If a nonlocal declaration is used, an assigned name that is on the nonlocal list is sought in surrounding scopes.  If the name is not found, a variable is created in the global environment.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:001f}
{\up $}{\footnote\pard\plain{\up $} bracket-comma notation}
{\up #}{\footnote\pard\plain{\up #} 1N.QYRT}
\pard\keepn\sb95 \b\fs25 bracket-comma notation\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} bracket-comma notation;syntax, bracket-comma notation}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 strand notation\plain\fs20\cf1\cb1 {\v 1N9SB86}\line

\par A list may be constructed directly by using \b bracket-comma\plain\fs20\cf1\cb1  notation.  In this notation, the items of a list are separated by commas and the list is bounded by square brackets.  If an item is omitted before or after a comma, then the fault value \i ?noexpr\plain\fs20\cf1\cb1  is used for the value of the missing item. The notation denotes the \i Null\plain\fs20\cf1\cb1  if their are no items, and a solitary if there is only one item.
\par \pard\keep\sb95 \f1\fs16      [2,3 4,5] \line
+-+---+-+ \line
|2|3 4|5| \line
+-+---+-+ \line
 \line
     [,4 5] \line
+-------+---+ \line
|?noexpr|4 5| \line
+-------+---+ \line
 \line
     [] = Null \line
l \line
 \line
     ['hello world'] \line
+-----------+ \line
|hello world| \line
+-----------+ \line
 \line
     [3,[4,5,6],7] \line
+-+-----+-+ \line
|3|4 5 6|7| \line
+-+-----+-+\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0020}
{\up $}{\footnote\pard\plain{\up $} break}
{\up #}{\footnote\pard\plain{\up #} 2V9T7BV}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 break\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} break;system expression, break}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Break    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 breakin\plain\fs20\cf1\cb1 {\v 26_7_XB}, \uldb debugging\plain\fs20\cf1\cb1 {\v PP0_XH}, \uldb callstack\plain\fs20\cf1\cb1 {\v MPTNH2}, \uldb step\plain\fs20\cf1\cb1 {\v 1CMJB0J}, \uldb next\plain\fs20\cf1\cb1 {\v 40X4IY}, \uldb resume\plain\fs20\cf1\cb1 {\v 1JE1SH6}\line

\par The execution of \i Break\plain\fs20\cf1\cb1  causes the interpreter to interrupt normal execution in an expression sequence and to display the current callstack. It then prompts for input with the prompt \i -->\plain\fs20\cf1\cb1  followed by the default command in brackets.  The visible environment is that of the expression in which the break occurs.  Thus, it is possible to examine the values of local variables in break mode.  \line

\par \pard\sb95 At a break you can type any expression to inspect the value of a variable or to see a portion of its value. The operation \i see\plain\fs20\cf1\cb1  can also be used to view any of the definitions in the environment.\line

\par The debugging capability allows one to step forward in expression sequences using commands \i step\plain\fs20\cf1\cb1 , \i stepin\plain\fs20\cf1\cb1 , \i next\plain\fs20\cf1\cb1  or \i toend\plain\fs20\cf1\cb1  to control whether you step into or over other definitions or to the end of a loop or a definition. The command \i resume\plain\fs20\cf1\cb1  ends the break and normal execution is restarted.\line

\par \pard\sb95 In console versions of Q'Nial, break mode can also be entered by typing <Ctrl B> in response to the prompt for a \i read\plain\fs20\cf1\cb1  or \i readscreen\plain\fs20\cf1\cb1  operation or \i Readchar\plain\fs20\cf1\cb1  expression when in windows mode.  In this case, after \i resume\plain\fs20\cf1\cb1  or \i step\plain\fs20\cf1\cb1  is entered, Q'Nial returns to the \i read\plain\fs20\cf1\cb1  or \i readscreen\plain\fs20\cf1\cb1  operation and awaits the user input.  Break mode cannot be entered by typing <Ctrl B> in \i editwindow\plain\fs20\cf1\cb1  or when \i setinterrupts\plain\fs20\cf1\cb1  has been used to inhibit interrupts.  
\par \pard\keep\sb95 \f1\fs16      foo is op A \{\- Break; A \'7d \line
     foo 3 \line
------------------------------------------------------------- \line
    Break debug loop: enter debug commands, expressions or  \line
      type: resume    to exit debug loop \line
      <Return> executes the indicated debug command \line
    current call stack : \line
foo \line
------------------------------------------------------------- \line
?.. A  \line
-->[stepv]\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the example, the operation \i foo\plain\fs20\cf1\cb1  has a \i Break\plain\fs20\cf1\cb1  which is executed when \i foo\plain\fs20\cf1\cb1  is applied to 3. If \i Return\plain\fs20\cf1\cb1  is pressed at the prompt the expression \i A\plain\fs20\cf1\cb1  is evaluated and 3 is displayed followed by another prompt.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0021}
{\up $}{\footnote\pard\plain{\up $} breakin}
{\up #}{\footnote\pard\plain{\up #} 26_7_XB}
\pard\keepn\sb95 \b\fs25 breakin\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} breakin;system operation, breakin}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 breakin Defname [Mode]    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 break\plain\fs20\cf1\cb1 {\v 2V9T7BV}, \uldb debugging\plain\fs20\cf1\cb1 {\v PP0_XH}, \uldb breaklist\plain\fs20\cf1\cb1 {\v 2JH0.LH}\line

\par The operation \i breakin\plain\fs20\cf1\cb1  installs a break point prior to the first executable expression in a definition named by the string or phrase \i Defname\plain\fs20\cf1\cb1 .  The named definition must be an expression or an operation form.  The effect is that when the definition is executed a break interrupt occurs prior to the execution of the first expression in the expression sequence in the body of the definition.  \line

\par \pard\sb95 The optional argument \i Mode\plain\fs20\cf1\cb1  is provided to set the internal flag explicitly.  If it is omitted, the internal flag value is toggled.  All breakin flags are initially \i false\plain\fs20\cf1\cb1 .  The value of the breakin flag is retained if the definition is replaced by a \i loaddefs\plain\fs20\cf1\cb1  so that editing a definition and reloading it does not change its breakin status.  However, if definitions are reloaded using a \i restart\plain\fs20\cf1\cb1  then the breakin status is set to \i false\plain\fs20\cf1\cb1 .\line

\par \pard\sb95 The operation returns the previous setting.  If the result of \i breakin\plain\fs20\cf1\cb1  is assigned to a variable, the previous setting can be restored later.  The names of definitions that have breakin set can be viewed by the expression \i Breaklist\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      library"labeltab \line
 \line
     see "labeltable\plain\fs20\cf1\cb1 
\par \f1\fs16 labeltable IS OPERATION Corner Rowlabel  \line
   Columnlabel Table \{\-  \line
   % Combine the corner label with the column  \line
      labels for first line;  \line
   Firstrow := Corner hitch Columnlabel;  \line
   % Hitch the row labels to the rows of  \line
      the table;  \line
   Labeledrows := Rowlabel EACHBOTH hitch  \line
      rows Table;  \line
   % Hitch the first row of labels to the labeled  \line
      rows and mix them;  \line
   mix (Firstrow hitch Labeledrows) \'7d \plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      X gets count 3 \line
1 2 3 \line
 \line
# execute labeltable without break;  \line
 \line
     labeltable "TIMES X X (X OUTER times X) \line
TIMES 1 2 3 \line
    1 1 2 3 \line
    2 2 4 6 \line
    3 3 6 9 \line
 \line
# set breakin and execute again  \line
 \line
     breakin "labeltable \line
o \line
 \line
     labeltable "TIMES X X (X OUTER times X) \line
 \line
------------------------------------------------------------- \line
    Break debug loop: enter debug commands, expressions or  \line
      type: resume    to exit debug loop \line
      <Return> executes the indicated debug command \line
    current call stack : \line
labeltable \line
------------------------------------------------------------- \line
?.. Firstrow := Corner hitch Columnlabel  \line
-->[stepv] TIMES 1 2 3 \line
?..   % Hitch the row labels to the rows of the table  \line
-->[stepv] resume \line
TIMES 1 2 3 \line
    1 1 2 3 \line
    2 2 4 6 \line
    3 3 6 9\plain\fs20\cf1\cb1 \line

\par \pard\sb95 To clear all breaks use: 
\par \pard\keep\sb95 \f1\fs16      EACH breakin Breaklist\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0022}
{\up $}{\footnote\pard\plain{\up $} breaklist}
{\up #}{\footnote\pard\plain{\up #} 2JH0.LH}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 breaklist\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} breaklist;system expression, breaklist}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Breaklist    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 break\plain\fs20\cf1\cb1 {\v 2V9T7BV}, \uldb breakin\plain\fs20\cf1\cb1 {\v 26_7_XB}, \uldb debugging\plain\fs20\cf1\cb1 {\v PP0_XH}\line

\par The execution of \i Breaklist\plain\fs20\cf1\cb1  prints out a list of the definition names for which the breakin flag has been set.  \line

\par Its main use is to assist in clearing the breaks as debugging proceeds.  
\par \pard\keep\sb95 \f1\fs16      Breaklist \line
labeltable\plain\fs20\cf1\cb1 \line

\par \pard\sb95 To clear all breaks use: 
\par \pard\keep\sb95 \f1\fs16      EACH breakin Breaklist\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0023}
{\up $}{\footnote\pard\plain{\up $} bycols}
{\up #}{\footnote\pard\plain{\up #} 10XLMGD}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 bycols\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} apply-by-partition transformer, bycols;bycols}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul apply-by-partition transformer\plain\fs20\cf1\cb1 {\v apply-by-partition transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 BYCOLS f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 rank\plain\fs20\cf1\cb1 {\v QD.ZW5}, \uldb partition\plain\fs20\cf1\cb1 {\v KE6GMU}\line

\par The transformer \i BYCOLS\plain\fs20\cf1\cb1  applies an operation \i f\plain\fs20\cf1\cb1  to the columns of a table \i A\plain\fs20\cf1\cb1 , where \i f\plain\fs20\cf1\cb1  is an operation that maps lists to lists.  
\par \pard\keep\sb95 \f1\fs16      setformat '%5.3f'; \line
     BYCOLS (SORT <=) (5 6 reshape random 30) \line
0.726 0.009 0.210 0.385 0.123 0.119 \line
0.851 0.448 0.384 0.476 0.193 0.384 \line
0.880 0.449 0.536 0.603 0.455 0.498 \line
0.882 0.729 0.631 0.819 0.639 0.521 \line
0.911 0.893 0.810 0.961 0.940 0.672\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The example generates a random table and then sorts each column.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      BYCOLS IS TRANSFORMER f OPERATION A \{\- transpose (1 RANK f transpose A) \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape f A = shape A ==> shape BYCOLS f A = shape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0024}
{\up $}{\footnote\pard\plain{\up $} bye}
{\up #}{\footnote\pard\plain{\up #} 1ZNBR9K}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 bye\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} bye;system expression, bye}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Bye    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 continue\plain\fs20\cf1\cb1 {\v 1FW5IX}, \uldb save\plain\fs20\cf1\cb1 {\v 25VUZ7O}, \uldb restart\plain\fs20\cf1\cb1 {\v 3I4P_OP}\line

\par The expression \i Bye\plain\fs20\cf1\cb1  is used to terminate a session of Q'Nial and to return to the host environment.  The current workspace is not saved.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0025}
{\up $}{\footnote\pard\plain{\up $} bykey}
{\up #}{\footnote\pard\plain{\up #} 3HC._3I}
\pard\keepn\sb95 \b\fs25 bykey\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} applicative transformer, bykey;bykey}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul applicative transformer\plain\fs20\cf1\cb1 {\v applicative transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 K BYKEY f A   BYKEY f K A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 each\plain\fs20\cf1\cb1 {\v QCZZL2}\line

\par The transformer \i BYKEY\plain\fs20\cf1\cb1  applies an operation \i f\plain\fs20\cf1\cb1  to lists gathered from \i A\plain\fs20\cf1\cb1 , where each list is made up of items of \i A\plain\fs20\cf1\cb1  that have the same value in the corresponding position in \i K\plain\fs20\cf1\cb1 .  The result is a list with as many items as there are unique items in \i K\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      Str := 'a stitch in time saves nine'; \line
 \line
     cull Str \line
a stichnmev \line
 \line
     Str BYKEY tally Str \line
2 5 3 2 4 1 1 3 1 3 1 \line
 \line
     Keys := 3 5 3 7 2 5 4 2 1 3 4; \line
     Data := 23.1 14.2 13.5 18.9 22. 98. 3.5 28.7 19.3 16.5 43.2; \line
 \line
     Keys BYKEY sum Data \line
53.1 112.2 18.9 50.7 46.7 19.3 \line
 \line
     average IS OP A \{\- sum A / tally A \'7d \line
 \line
     Keys BYKEY average Data \line
17.7 56.1 18.9 25.35 23.35 19.3\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the first example \i BYKEY tally\plain\fs20\cf1\cb1  is used to count the frequency of the letters in the string \i Str\plain\fs20\cf1\cb1 , giving the counts in the order of \i cull Str\plain\fs20\cf1\cb1 . In the remaining examples, the values in \i Data\plain\fs20\cf1\cb1  corresponding to equal items in \i Keys\plain\fs20\cf1\cb1  are added and averaged in the two uses of \i BYKEY\plain\fs20\cf1\cb1 .\line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      BYKEY IS TRANSFORMER f OPERATION K A \{\-  \line
        Keys gets cull A; \line
        IF simple Keys THEN \line
           Patterns := Keys EACHLEFT match A; \line
        ELSE \line
           Patterns := Keys EACHLEFT EACHRIGHT = A; \line
        ENDIF; \line
        EACH f (Patterns EACHLEFT sublist B) \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    tally BYKEY f K A = tally cull K \line
   valence BYKEY f K A = 1 \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0026}
{\up $}{\footnote\pard\plain{\up $} byrows}
{\up #}{\footnote\pard\plain{\up #} 3.ITLBI}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 byrows\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} apply-by-partition transformer, byrows;byrows}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul apply-by-partition transformer\plain\fs20\cf1\cb1 {\v apply-by-partition transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 BYROWS f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 bycols\plain\fs20\cf1\cb1 {\v 10XLMGD}, \uldb partition\plain\fs20\cf1\cb1 {\v KE6GMU}\line

\par The transformer \i BYROWS\plain\fs20\cf1\cb1  applies an operation \i f\plain\fs20\cf1\cb1  to the rows of a table \i A\plain\fs20\cf1\cb1 , where \i f\plain\fs20\cf1\cb1  is an operation that maps lists to lists.  
\par \pard\keep\sb95 \f1\fs16      BYROWS reverse (5 6 reshape count 30) \line
 6  5  4  3  2  1 \line
12 11 10  9  8  7 \line
18 17 16 15 14 13 \line
24 23 22 21 20 19 \line
30 29 28 27 26 25\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The example reverses the rows of the generated table.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      BYROWS IS TRANSFORMER f OPERATION A \{\- 1 RANK f A \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape f A = shape A ==> shape BYROWS f A = shape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0027}
{\up $}{\footnote\pard\plain{\up $} by-variable}
{\up #}{\footnote\pard\plain{\up #} 700T8J}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 by-variable\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} by-variable;concept, by-variable}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 argument\plain\fs20\cf1\cb1 {\v C4.J_2}, \uldb assign\plain\fs20\cf1\cb1 {\v GIPGUZ}\line

\par One use of the operation \i assign\plain\fs20\cf1\cb1  is to mimic a \b by-variable\plain\fs20\cf1\cb1  form of parameter passing in place of Nial's by-value form.  The result depends on what kind of name is provided, a phrase or a cast.  If the name is provided as a phrase, the variable that is selected is determined by \i assign\plain\fs20\cf1\cb1  when it does the assignment by looking first in the local environment and then in the surrounding ones.  If the name is provided as a cast, the variable selected is the one that exists at the point where the cast is formed.  Thus, by-variable parameter passing is achieved by using the cast of the variable as an argument in the call.  In the body of the operation the formal parameter is assigned using \i assign\plain\fs20\cf1\cb1  and evaluated using \i value\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      foo is op A Nm \{\- \line
       B := A + value Nm; \line
       Nm assign (B + sum count 5); \'7d \line
 \line
     X := 100; \line
     foo 1000 "X; \line
     X \line
1115\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0028}
{\up $}{\footnote\pard\plain{\up $} calldllfun}
{\up #}{\footnote\pard\plain{\up #} 201S2GS}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 calldllfun\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} calldllfun;system operation, calldllfun}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 calldllfun Nm Arg0 ... ArgN    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 registerdllfun\plain\fs20\cf1\cb1 {\v R.9.XP}, \uldb dlllist\plain\fs20\cf1\cb1 {\v 1YSI_GC}, \uldb user primitives\plain\fs20\cf1\cb1 {\v DV7MJ4}\line

\par A Prototype DLL calling interface has been added to the Windows versions of Q'Nial (Console, GUI and DLL version).  This ability allows NIAL code to call external routines in DLL libraries.  These libraries can be user written, part of the Operating System, or 3rd party DLLs.\line

\par The DLL interface routines manage an internal table that keeps track of the currently installed DLLs and their argument types and result type.  This table also tracks if the actual library has been loaded (by a call to \i calldllfun\plain\fs20\cf1\cb1 ).  The table is preserved as part of the workspace, and once DLL functions have been registered in a workspace,  they are still available if the workspace is saved and subsequently loaded.  The CallDLL facility assures that the DLL files are loaded and unloaded appropriately.  \line

\par \pard\sb95 Every time a workspace is saved all DLL libraries are unloaded and the internal table is adjusted to reflect that.  When a workspace is loaded, none of the DLL libraries will be loaded until a specific call to \i calldllfun\plain\fs20\cf1\cb1  brings in the DLL.  This process assures that resources are not wasted on registered DLL calls that are never used.  \line

\par The \i registerdllfun\plain\fs20\cf1\cb1  routine must always be called first to enter DLL function into the internal mapping table.  This table keeps track of the name and DLL file for the routine and all of the argument types and function results.  The DLL file is \b not\plain\fs20\cf1\cb1  loaded until the routine is called with the \i calldllfun\plain\fs20\cf1\cb1  routine.  So errors involving paths to the DLL file or other related problems are not reported until the first call to \i calldllfun\plain\fs20\cf1\cb1 .\line

\par \pard\sb95 The operation \i calldllfun\plain\fs20\cf1\cb1  provides an interface to an external routine implemented as a DLL for 32-bit Windows. The name \i Nm\plain\fs20\cf1\cb1  is the name associated with the routine when it was registered using \i registerdllfun\plain\fs20\cf1\cb1 . The use of the name with appropriate arguments causes the DLL routine to be executed and its result (if any) returned as a Nial array.\line

\par The arguments \i Arg0\plain\fs20\cf1\cb1  ... \i ArgN\plain\fs20\cf1\cb1  must agree in number and be compatible in type with the declarations made while registering the routine.\line

\par \pard\sb95 The details of argument passing and some examples are included in the entry for \i registerdllfun\plain\fs20\cf1\cb1 .\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0029}
{\up $}{\footnote\pard\plain{\up $} callstack}
{\up #}{\footnote\pard\plain{\up #} MPTNH2}
\pard\keepn\sb95 \b\fs25 callstack\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} callstack;system expression, callstack}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Callstack    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 break\plain\fs20\cf1\cb1 {\v 2V9T7BV}, \uldb debugging\plain\fs20\cf1\cb1 {\v PP0_XH}\line

\par The expression \i Callstack\plain\fs20\cf1\cb1  displays the sequence of active definition calls at the point it is invoked.  It is usually used in conjunction with \i Break\plain\fs20\cf1\cb1 .  \i Callstack\plain\fs20\cf1\cb1  can be used to see the execution path by which the computation reached the current state while computation is suspended during a break.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:002a}
{\up $}{\footnote\pard\plain{\up $} canonical}
{\up #}{\footnote\pard\plain{\up #} NZPQUY}
\pard\keepn\sb95 \b\fs25 canonical\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} canonical;concept, canonical}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 descan\plain\fs20\cf1\cb1 {\v 7ABG_7N}, \uldb execute\plain\fs20\cf1\cb1 {\v 3WULI4D}\line

\par There is a \b canonical\plain\fs20\cf1\cb1  way of displaying program text in Nial. This is done automatically by the routines \i descan\plain\fs20\cf1\cb1  and \i deparse\plain\fs20\cf1\cb1  used by \i see\plain\fs20\cf1\cb1 . The canonical form sets the case of all identifiers used in Nial program text according to their role in order to assist visual parsing of Nial text. The following table summarizes the rules:
\par  \trowd\trgaph175\trleft-6 \cellx1545\cellx5795\pard\intbl\sb95 \b Role \cell\pard \pard\intbl\sb95 Case rule \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1545\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 Variable \cell\pard \pard\intbl\sb95 first letter upper case, the rest lower case \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1545\cellx5795\pard\intbl\sb95 Expression \cell\pard \pard\intbl\sb95 first letter upper case, the rest lower case \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1545\cellx5795\pard\intbl\sb95 Operation \cell\pard \pard\intbl\sb95 all lower case \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1545\cellx5795\pard\intbl\sb95 Transformer \cell\pard \pard\intbl\sb95 all upper case \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1545\cellx5795\pard\intbl\sb95 Reserved Word \cell\pard \pard\intbl\sb95 all upper case \cell\intbl\row
\pard\sb95 \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      canonical IS link descan deparse parse scan\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:002b}
{\up $}{\footnote\pard\plain{\up $} cart}
{\up #}{\footnote\pard\plain{\up #} 1CM9ZGN}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 cart\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} cart;construction operation, cart}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul construction operation\plain\fs20\cf1\cb1 {\v construction operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 cart A   A cart B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 outer\plain\fs20\cf1\cb1 {\v TV3GVX}, \uldb tell\plain\fs20\cf1\cb1 {\v 1CMK3AF}\line

\par The operation \i cart\plain\fs20\cf1\cb1  corresponds to the cartesian product of set theory.  Its purpose is to form all possible combinations of the items of its argument and return them in a structured result having as many axes as the sum of the number of axes of the items of argument.  
\par \pard\keep\sb95 \f1\fs16      2 3 4 cart 5 6 \line
+---+---+ \line
|2 5|2 6| \line
+---+---+ \line
|3 5|3 6| \line
+---+---+ \line
|4 5|4 6| \line
+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the example above, the cart of a triple with a pair yields a table of shape 3 2 of pairs.  
\par \pard\keep\sb95 \f1\fs16      cart ['abc', 4 2 reshape count 8] \line
+---+---+  +---+---+  +---+---+ \line
|a 1|a 2|  |b 1|b 2|  |c 1|c 2| \line
+---+---+  +---+---+  +---+---+ \line
|a 3|a 4|  |b 3|b 4|  |c 3|c 4| \line
+---+---+  +---+---+  +---+---+ \line
|a 5|a 6|  |b 5|b 6|  |c 5|c 6| \line
+---+---+  +---+---+  +---+---+ \line
|a 7|a 8|  |b 7|b 8|  |c 7|c 8| \line
+---+---+  +---+---+  +---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the above example, the shape of the result is 3 4 2, getting an axis of length 3 from the first item and axes of length 4 and 2 from the second.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape cart A = link EACH shape A \line
   valence cart A = sum EACH valence A \line
   tally cart A = product EACH tally A \line
   equal EACH shape cart A = True \line
   A OUTER pair B = A cart B \line
   cart link A = EACH link cart EACH cart A \line
   cart EACH EACH f A = EACH EACH f cart A \line
   cart single A = EACH single A \line
   simple A ==> cart A = single A \line
   cart Null = single Null \line
   empty A ==> cart A = single A \line
   or EACH empty A ==> empty cart A \line
   not empty A and not empty cart A ==> shape first cart A = shape A \line
   not empty A and not empty cart A ==> first cart A = EACH first A \line
   isshape A ==> tell A = cart EACH tell A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:002c}
{\up $}{\footnote\pard\plain{\up $} case-expr}
{\up #}{\footnote\pard\plain{\up #} 3BHT_IZ}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 case-expr\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} case-expr;control structure, case-expr}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul control structure\plain\fs20\cf1\cb1 {\v control structure}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 CASE expression FROM C1: ES1 END ...  Cn: ESn END ELSE ESx ENDCASE    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 if-expr\plain\fs20\cf1\cb1 {\v XKQ1M}, \uldb fork\plain\fs20\cf1\cb1 {\v 1CM__GE}\line

\par The expression following case is evaluated.  If the result matches one of the constants, C1 ... Cn, the corresponding expression sequence is executed.  If the result does not match any constant, the expression sequence following else is executed.  \line

\par \b Example:\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      Month := 3 ; \line
     CASE Month FROM \line
        1:   Mname := 'January'; END \line
        2:   Mname := 'February'; END \line
        3:   Mname := 'March'; END \line
     ELSE   Mname := 'Year End'; \line
     ENDCASE ; \line
     Mname \line
March\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:002d}
{\up $}{\footnote\pard\plain{\up $} cast}
{\up #}{\footnote\pard\plain{\up #} 1CM9ZHN}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 cast\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} cast;syntax, cast}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}\line

\par \pard\sb95 A \i cast\plain\fs20\cf1\cb1  is an array expression that denotes an internal representation of a valid fragment of Q'Nial program text: 
\par \pard\keep\sb95 \f1\fs16      cast ::= ! identifier \line
        | ! ( expression-sequence) \line
        | ! ( operation-expression ) \line
        | ! ( transformer-expression )\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The use of the exclamation symbol \i !\plain\fs20\cf1\cb1  before an identifier causes Q'Nial to select the internal representation for the identifier rather than the value of the array associated with the identifier.  Its use before a parenthesized program fragment selects the internal representation of the program fragment.  \line

\par The major use of casts is in conjunction with the operations assign and apply.  These operations mimic the Q'Nial constructs for assignment to a variable and application of an operation to an array.  Casts permit passing an argument to an operation by variable name rather than by value.  They also permit evaluation of a program fragment that has been stored in its internal form using the operation eval rather than requiring the use of the operation execute on the corresponding program text stored as a string.  
\par \pard\keep\sb95 \f1\fs16      Salary := 90000. \line
     A gets 'Salary > 100000.' ; \line
     Rule1 := execute A \line
o \line
     Rule1 := eval !A \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The details of the internal representation is not specified as part of the Nial language.  \line

\par The cast notation \i !Name\plain\fs20\cf1\cb1  is used to denote the parse tree that represents the name.  At the top level loop, parentheses must be included around the use of the cast notation, e.g.  \i (!Name)\plain\fs20\cf1\cb1 , to avoid ambiguity with the use of \i !\plain\fs20\cf1\cb1  to indicate a host command.  \line

\par The cast, because it is analyzed in the context in which it appears, refers to a variable or definition in a static way.  \line

\par \pard\sb95 Q'Nial contains operations that mimic the underlying meaning of variables, expressions and operations in Q'Nial.  The operations use strings, phrases or casts to represent the name of the object under consideration (except that see and getdef do not take casts).  
\par  \trowd\trgaph175\trleft-6 \cellx1885\cellx5795\pard\intbl\sb95 \b Operation \cell\pard \pard\intbl\sb95 Action \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1885\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 value A \cell\pard \pard\intbl\sb95 Return the value of a variable named by string, phrase or cast \i A\plain\fs20\cf1\cb1 . \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1885\cellx5795\pard\intbl\sb95 A assign B \cell\pard \pard\intbl\sb95 Assign the array \i B\plain\fs20\cf1\cb1  to the variable named by string, phrase or cast \i A\plain\fs20\cf1\cb1 ; return \i B\plain\fs20\cf1\cb1 . \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1885\cellx5795\pard\intbl\sb95 A apply B \cell\pard \pard\intbl\sb95 Apply the operation named by string, phrase or cast \i A\plain\fs20\cf1\cb1  to array \i B\plain\fs20\cf1\cb1 ; return the result of the operation. \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1885\cellx5795\pard\intbl\sb95 getdef A \cell\pard \pard\intbl\sb95 Return the parse tree associated with the definition named by string or phrase \i A\plain\fs20\cf1\cb1 . \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1885\cellx5795\pard\intbl\sb95 see A \cell\pard \pard\intbl\sb95 Display the definition named by the string or phrase \i A\plain\fs20\cf1\cb1 . \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1885\cellx5795\pard\intbl\sb95 update P A B \cell\pard \pard\intbl\sb95 Put array \i B\plain\fs20\cf1\cb1  at address \i A\plain\fs20\cf1\cb1  in the variable named by the phrase, string or cast \i P\plain\fs20\cf1\cb1 ; return the new value of \i P\plain\fs20\cf1\cb1 . \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1885\cellx5795\pard\intbl\sb95 updateall P A B \cell\pard \pard\intbl\sb95 Put items of \i B\plain\fs20\cf1\cb1  at addresses \i A\plain\fs20\cf1\cb1  in the variable named by the phrase, string or cast \i P\plain\fs20\cf1\cb1 ; return the new value of the variable named by \i P\plain\fs20\cf1\cb1 . \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1885\cellx5795\pard\intbl\sb95 deepupdate P A B \cell\pard \pard\intbl\sb95 Put array \i B\plain\fs20\cf1\cb1  at path \i A\plain\fs20\cf1\cb1  in variable named by the string, phrase or cast \i P\plain\fs20\cf1\cb1 ; return new value of the variable named by \i P\plain\fs20\cf1\cb1 . \cell\intbl\row
\pard \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:002e}
{\up $}{\footnote\pard\plain{\up $} catenate}
{\up #}{\footnote\pard\plain{\up #} BNUIZP}
\pard\keepn\sb95 \b\fs25 catenate\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} catenate;construction operation, catenate}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul construction operation\plain\fs20\cf1\cb1 {\v construction operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 I catenate A   catenate I A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 link\plain\fs20\cf1\cb1 {\v QD77W5}, \uldb laminate\plain\fs20\cf1\cb1 {\v M19KO1}\line

\par The operation \i catenate\plain\fs20\cf1\cb1  joins the items of \i A\plain\fs20\cf1\cb1  along axis \i I\plain\fs20\cf1\cb1 .  The items of \i A\plain\fs20\cf1\cb1  must conform in all other axes.  
\par \pard\keep\sb95 \f1\fs16      1 catenate (tell 2 3) (count 2 5) \line
+---+---+---+---+---+---+---+---+ \line
|0 0|0 1|0 2|1 1|1 2|1 3|1 4|1 5| \line
+---+---+---+---+---+---+---+---+ \line
|1 0|1 1|1 2|2 1|2 2|2 3|2 4|2 5| \line
+---+---+---+---+---+---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The example joins two tables along the rows.  Each table has two rows.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      catenate IS OPERATION I A \{\- \line
        % "push down" I axis of items of A; \line
        B := EACH ( I split ) A ; \line
        IF equal EACH shape B THEN \line
           I blend EACH link pack B \line
        ELSE \line
           fault '?conform error in catenate' \line
        ENDIF \'7d\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:002f}
{\up $}{\footnote\pard\plain{\up $} ceiling}
{\up #}{\footnote\pard\plain{\up #} 5G__UQ}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 ceiling\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, ceiling;ceiling}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 ceiling A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 floor\plain\fs20\cf1\cb1 {\v 7CICIH}, \uldb mod\plain\fs20\cf1\cb1 {\v 1_E72C0}, \uldb quotient\plain\fs20\cf1\cb1 {\v KJKAFK}\line

\par The operation ceiling produces the following results when applied to atoms of the six types: 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 corresponding integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 argument \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 next higher integer or the fault ?A, if the result is outside the range of integers \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 \line

\par \b Examples\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      ceiling  l  -2  3.5 \line
1 -2 4 \line
     ceiling  `a  "abc  ??error \line
 ?A ?A ?error \line
     ceiling  3.5  -4.6  7.0  25.3e20 \line
4 -4 7 ?A\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      ceiling IS OPERATION A \{\- \line
        opposite floor opposite A \'7d\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0030}
{\up $}{\footnote\pard\plain{\up $} char}
{\up #}{\footnote\pard\plain{\up #} 40M72W}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 char\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} char;conversion operation, char}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 char N    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 charrep\plain\fs20\cf1\cb1 {\v 2W9HDTD}, \uldb ischar\plain\fs20\cf1\cb1 {\v 1ARLF.C}, \uldb isinteger\plain\fs20\cf1\cb1 {\v 23WZ8W4}, \uldb isstring\plain\fs20\cf1\cb1 {\v HCQ47O}\line

\par The operation \i char\plain\fs20\cf1\cb1  is used to convert an integer in the range 0 to 255 to the character that has the integer as its internal representation.  The result is system dependent.  
\par \pard\keep\sb95 \f1\fs16      char 66 \line
B \line
     char 66 67 68 69 \line
BCDE\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The major purpose of \i char\plain\fs20\cf1\cb1  is to create special characters for a specific system.  For example, the characters that control cursor motion differ from one terminal to another.  Programs using \i char\plain\fs20\cf1\cb1  may not be portable.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    N in tell 256 ==> charrep char N = N \line
   ischar C ==> char charrep C = C \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0031}
{\up $}{\footnote\pard\plain{\up $} charrep}
{\up #}{\footnote\pard\plain{\up #} 2W9HDTD}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 charrep\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} charrep;conversion operation, charrep}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 charrep C    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 char\plain\fs20\cf1\cb1 {\v 40M72W}, \uldb isinteger\plain\fs20\cf1\cb1 {\v 23WZ8W4}, \uldb ischar\plain\fs20\cf1\cb1 {\v 1ARLF.C}, \uldb isstring\plain\fs20\cf1\cb1 {\v HCQ47O}\line

\par The operation \i charrep\plain\fs20\cf1\cb1  is used to convert a character to its internal representation as an integer.  This operation is system dependent.  
\par \pard\keep\sb95 \f1\fs16      charrep `A \line
65 \line
     charrep 'hello' \line
104 101 108 108 111\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The major purpose of \i charrep\plain\fs20\cf1\cb1  is to permit determination of special characters for a specific system.  For example, the characters that control cursor motion differ from one terminal to another.  \line

\par Programs using charrep may not be portable.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    N in tell 256 ==> charrep char N = N \line
   ischar C ==> char charrep C = C \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0032}
{\up $}{\footnote\pard\plain{\up $} checkpoint}
{\up #}{\footnote\pard\plain{\up #} 4LLHD1P}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 checkpoint\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} checkpoint;user defined expression, checkpoint}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul user defined expression\plain\fs20\cf1\cb1 {\v user defined expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Checkpoint    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 save\plain\fs20\cf1\cb1 {\v 25VUZ7O}, \uldb load\plain\fs20\cf1\cb1 {\v QD7_IY}, \uldb latent\plain\fs20\cf1\cb1 {\v 4YEDEP}\line

\par \i Checkpoint\plain\fs20\cf1\cb1  is a user defined expression executed after a \i save\plain\fs20\cf1\cb1 .  \line

\par When a \i save\plain\fs20\cf1\cb1  is executed, the current computation is ended and the \i Checkpoint\plain\fs20\cf1\cb1  is done in the top level environment.  \line

\par If a workspace being saved contains an expression named \i Checkpoint\plain\fs20\cf1\cb1 , the expression is executed following the saving of the workspace and prior to restarting the top level loop.  It can be used to restart a computational loop after an intermediate dump of the workspace.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0033}
{\up $}{\footnote\pard\plain{\up $} choose}
{\up #}{\footnote\pard\plain{\up #} 1XQ9M0F}
\pard\keepn\sb95 \b\fs25 choose\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} choose;selection operation, choose}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 I choose A   choose I A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 pick\plain\fs20\cf1\cb1 {\v 40Z84P}, \uldb take\plain\fs20\cf1\cb1 {\v 25VVYWO}, \uldb takeright\plain\fs20\cf1\cb1 {\v 149YX4U}, \uldb reach\plain\fs20\cf1\cb1 {\v TXN4TN}\line

\par The operation \i choose\plain\fs20\cf1\cb1  is used to select a subarray from array \i A\plain\fs20\cf1\cb1  specified by the array of addresses \i I\plain\fs20\cf1\cb1 .  The result is an array of the same shape as \i I\plain\fs20\cf1\cb1  with items chosen from \i A\plain\fs20\cf1\cb1 .  If an item of \i I\plain\fs20\cf1\cb1  is not an address of \i A\plain\fs20\cf1\cb1 , the corresponding position in the result is the fault \i ?address\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 The operation \i choose\plain\fs20\cf1\cb1  is related to the \i at all\plain\fs20\cf1\cb1  notation \i V#I\plain\fs20\cf1\cb1 , which selects items from the array associated with the variable \i V\plain\fs20\cf1\cb1 .  The differences are that \i choose\plain\fs20\cf1\cb1  may select from an array that has not been assigned to a variable and that it handles out-of-range in a different manner.  
\par \pard\keep\sb95 \f1\fs16      3 1 0 1 3 4 choose 'range' \line
garage\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The following example shows that the \i valence\plain\fs20\cf1\cb1  of the array of addresses can be higher than that of the array from which the selection is made.  
\par \pard\keep\sb95 \f1\fs16      I gets (2 4 reshape tell 8) \line
0 1 2 3 \line
4 5 6 7 \line
     I choose 'some words as a string' \line
some \line
 wor\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      choose IS OPERATION I A \{\- I EACHLEFT pick A \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape (I choose A) = shape I \line
   J choose (I choose A) = (J choose I) choose A \line
   tell shape A choose A = A \line
   (list I) choose A = list (I choose A) \line
   (EACH list I) choose A = I choose A \line
   I allin grid A ==> EACH f (I choose A) = I choose EACH f A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0034}
{\up $}{\footnote\pard\plain{\up $} clear workspace}
{\up #}{\footnote\pard\plain{\up #} 2R04_UA}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 clear workspace\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} clear workspace;concept, clear workspace}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 continue workspace\plain\fs20\cf1\cb1 {\v 29G9US}, \uldb standard definitions\plain\fs20\cf1\cb1 {\v AXO3EN}, \uldb save\plain\fs20\cf1\cb1 {\v 25VUZ7O}, \uldb load\plain\fs20\cf1\cb1 {\v QD7_IY}, \uldb symbols\plain\fs20\cf1\cb1 {\v 1KUXMUU}, \uldb clearws\plain\fs20\cf1\cb1 {\v .C2G42}, \uldb restart\plain\fs20\cf1\cb1 {\v 3I4P_OP}\line

\par Q'Nial organizes the data and code objects available for use into a logical structure called a \b workspace\plain\fs20\cf1\cb1 . It consists of a symbol table to hold associations between names and the predefined and user defined objects, a heap to store data and parse trees, a stack used to hold values temporarily during execution, and an atom table for uniquely storing phrases and faults.\line

\par \pard\sb95 When Q'Nial is invoked it starts the session with a clear workspace unless a specific saved workspace is requested or there is a \i continue.nws\plain\fs20\cf1\cb1  file in the local directory. The clear workspace is either found in the local directory, in the directory pointed at by \i Nialroot\plain\fs20\cf1\cb1 . The name of the clear workspace is \i clearws.nhs\plain\fs20\cf1\cb1 . If it is not found, then Q'Nial creates an internal clear workspace using its initialization process. A message indicates whether a clear workspace was loaded or created.\line

\par \pard\sb95 A user can tailor the initial state of Nial for their own purposes by saving a workspace with definitions in place as \i clearws.nws\plain\fs20\cf1\cb1  using \i save\plain\fs20\cf1\cb1 .\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0035}
{\up $}{\footnote\pard\plain{\up $} clearprofile}
{\up #}{\footnote\pard\plain{\up #} 90MFAZ}
\pard\keepn\sb95 \b\fs25 clearprofile\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} clearprofile;profiling expression, clearprofile}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul profiling expression\plain\fs20\cf1\cb1 {\v profiling expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Clearprofile    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 profile\plain\fs20\cf1\cb1 {\v FHUFEL}, \uldb setprofile\plain\fs20\cf1\cb1 {\v H2UBBE}, \uldb profiletable\plain\fs20\cf1\cb1 {\v _8MA7D}, \uldb profiletree\plain\fs20\cf1\cb1 {\v H3PT41}, \uldb profiling\plain\fs20\cf1\cb1 {\v 1_IJW3H}\line

\par The expression \i Clearprofile\plain\fs20\cf1\cb1  is used to clear the internal data structures that are used in the gathering of profiling statistics.  It should be called when one profiling session has been completed and \i profile\plain\fs20\cf1\cb1  has been called, before starting another one.  \line

\par A detailed explanation of the profiling mechanism is given in the help entry on profiling.  \line

\par \pard\sb95 \b Example\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      Clearprofile\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0036}
{\up $}{\footnote\pard\plain{\up $} clearws}
{\up #}{\footnote\pard\plain{\up #} .C2G42}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 clearws\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} clearws;system expression, clearws}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Clearws    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 restart\plain\fs20\cf1\cb1 {\v 3I4P_OP}, \uldb load\plain\fs20\cf1\cb1 {\v QD7_IY}, \uldb save\plain\fs20\cf1\cb1 {\v 25VUZ7O}\line

\par The expression \i Clearws\plain\fs20\cf1\cb1  clears the current workspace, erasing all variables and user definitions.  It can cause loss of valuable information.  The operation \i save\plain\fs20\cf1\cb1  should be used prior to using \i Clearws\plain\fs20\cf1\cb1  if the information in the workspace will be needed again.  \line

\par The expression \i Restart\plain\fs20\cf1\cb1  is similar to \i Clearws\plain\fs20\cf1\cb1  except \i Restart\plain\fs20\cf1\cb1  re-initializes the interpreter according to the initial options given on the command line in a console version or set as defaults in a GUI version.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0037}
{\up $}{\footnote\pard\plain{\up $} close}
{\up #}{\footnote\pard\plain{\up #} TIUC9K}
\pard\keepn\sb95 \b\fs25 close\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} close;file operation, close}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul file operation\plain\fs20\cf1\cb1 {\v file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 close Fd    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 open\plain\fs20\cf1\cb1 {\v 25VR_QX}, \uldb filestatus\plain\fs20\cf1\cb1 {\v 0CG1FT}\line

\par The operation \i close\plain\fs20\cf1\cb1  is used to close a file previously opened with the \i open\plain\fs20\cf1\cb1  operation.  The argument is the file designator, an integer returned previously by \i open\plain\fs20\cf1\cb1  for that file.  \line

\par The result of \i close\plain\fs20\cf1\cb1  is the fault \i ?noexpr\plain\fs20\cf1\cb1  or a fault message indicating an error.  
\par \pard\keep\sb95 \f1\fs16      Fd := open "foo "w \line
3 \line
     close Fd \line
     close Fd \line
?file is not open\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the examples above, the first use of \i close\plain\fs20\cf1\cb1  was successful.  The second attempt to close the file resulted in the fault message.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0038}
{\up $}{\footnote\pard\plain{\up $} cols}
{\up #}{\footnote\pard\plain{\up #} QCY_U_}
\pard\keepn\sb95 \b\fs25 cols\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} cols;nesting restructuring operation, cols}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nesting restructuring operation\plain\fs20\cf1\cb1 {\v nesting restructuring operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 cols A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 rows\plain\fs20\cf1\cb1 {\v 1CMI_LM}, \uldb split\plain\fs20\cf1\cb1 {\v 5JDW.RI}, \uldb raise\plain\fs20\cf1\cb1 {\v TXJ_9K}, \uldb rank\plain\fs20\cf1\cb1 {\v QD.ZW5}\line

\par The operation \i cols\plain\fs20\cf1\cb1  rearranges the axes of a table of shape \i M\plain\fs20\cf1\cb1  by \i N\plain\fs20\cf1\cb1  to form a list of length \i N\plain\fs20\cf1\cb1  of the columns of length \i M\plain\fs20\cf1\cb1  of the table.  \i Cols\plain\fs20\cf1\cb1  is generalized to arrays of all valences as follows: if \i A\plain\fs20\cf1\cb1  is a list or a single, the result is \i single A\plain\fs20\cf1\cb1 ; if \i A\plain\fs20\cf1\cb1  has valence three or higher, the result is an array of valence one less than the valence of \i A\plain\fs20\cf1\cb1  with the second last axis pushed down.
\par \pard\keep\sb95 \f1\fs16      A := 3 4 reshape count 12 \line
1  2  3  4 \line
5  6  7  8 \line
9 10 11 12 \line
 \line
     cols A \line
+-----+------+------+------+ \line
|1 5 9|2 6 10|3 7 11|4 8 12| \line
+-----+------+------+------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 If only column \i I\plain\fs20\cf1\cb1  of a table is needed, it can be selected by \i I pick cols A\plain\fs20\cf1\cb1  or by \i A|[,I]\plain\fs20\cf1\cb1  using the \i at slice\plain\fs20\cf1\cb1  indexing notation.  The second way is more efficient for large arrays because it avoids restructuring the array.  If a table \i A\plain\fs20\cf1\cb1  has no columns, \i cols A\plain\fs20\cf1\cb1  results in the empty list \i Null\plain\fs20\cf1\cb1 .  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      cols IS OPERATION A \{\- \line
        IF valence A = 0 THEN single A \line
        ELSE \line
           valence A - 2 max 0 split A \line
        ENDIF \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    valence A = 2 and not empty A ==> cols A = pack rows A \line
   valence A = 2 and not empty A ==> cols A = rows transpose A \line
   valence A = 2 and not empty A ==> mix cols A = transpose A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0039}
{\up $}{\footnote\pard\plain{\up $} comment}
{\up #}{\footnote\pard\plain{\up #} 11TJ9BC}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 comment\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} comment;syntax, comment}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 action\plain\fs20\cf1\cb1 {\v G9QH2Z}
\par \pard\keep\sb95 \f1\fs16      comment ::= \line
        % <any text excluding a semicolon> ; \line
 \line
     remark ::= # < any text >\plain\fs20\cf1\cb1 \line

\par \pard\sb95 A \b comment\plain\fs20\cf1\cb1  is a brief section of text included in a program fragment to assist readability.  Comments may be placed anywhere in a block before or after declarations, definitions or expressions.  Their purpose is to provide an explanation of the program fragment for the programmer who may be required to modify the program at a later date.  The value of a comment as an expression is the \i ?noexpr\plain\fs20\cf1\cb1  fault.  Comments are retained when a definition is translated into internal form and they appear in its creation in the canonical form used by the operations see and defedit.  \line

\par \pard\sb95 A \b remark\plain\fs20\cf1\cb1  is an input to the Q'Nial interpreter that is not processed.  It begins with a line that has the symbol # as the first non-blank character in the line.  In direct input at the top level loop, a remark ends at the end of the line unless a backslash symbol ( \'5c ) is used to extend the line.  In a definition file, a remark ends at the first blank line.  A remark cannot appear within a definition or expression-sequence.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:003a}
{\up $}{\footnote\pard\plain{\up $} conform}
{\up #}{\footnote\pard\plain{\up #} 11UCCF.}
\pard\keepn\sb95 \b\fs25 conform\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, conform;conform}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 pack\plain\fs20\cf1\cb1 {\v QD0ZL5}, \uldb binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}, \uldb multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}\line

\par The operation pack is used in evaluating binary pervasive and multi pervasive operations. Its task is to interchange the top two levels of the argument to such operations if the items of the argument \b conform\plain\fs20\cf1\cb1 . For the binary case there are two items; they conform if the items have the same shape, or if one or both items have only one item. In the latter case, the item with only one item is replicated to the shape of the other item.\line

\par \pard\sb95 For the multi pervasive case, all the items that do not have only one item must be of the same shape and all the items with one item are replicated to that shape.
\par \pard\keep\sb95 \f1\fs16      pack [2 3 4,10 11 12] \line
+----+----+----+ \line
|2 10|3 11|4 12| \line
+----+----+----+ \line
 \line
     pack [2 3,10 11 12] \line
?conform \line
 \line
     pack [3 4 5,3,10 11 12,[4]] \line
+--------+--------+--------+ \line
|3 3 10 4|4 3 11 4|5 3 12 4| \line
+--------+--------+--------+ \line
 \line
     pack [tell 4 5,count 4 5] \line
+---------+---------+---------+---------+---------+ \line
|+---+---+|+---+---+|+---+---+|+---+---+|+---+---+| \line
||0 0|1 1|||0 1|1 2|||0 2|1 3|||0 3|1 4|||0 4|1 5|| \line
|+---+---+|+---+---+|+---+---+|+---+---+|+---+---+| \line
+---------+---------+---------+---------+---------+ \line
|+---+---+|+---+---+|+---+---+|+---+---+|+---+---+| \line
||1 0|2 1|||1 1|2 2|||1 2|2 3|||1 3|2 4|||1 4|2 5|| \line
|+---+---+|+---+---+|+---+---+|+---+---+|+---+---+| \line
+---------+---------+---------+---------+---------+ \line
|+---+---+|+---+---+|+---+---+|+---+---+|+---+---+| \line
||2 0|3 1|||2 1|3 2|||2 2|3 3|||2 3|3 4|||2 4|3 5|| \line
|+---+---+|+---+---+|+---+---+|+---+---+|+---+---+| \line
+---------+---------+---------+---------+---------+ \line
|+---+---+|+---+---+|+---+---+|+---+---+|+---+---+| \line
||3 0|4 1|||3 1|4 2|||3 2|4 3|||3 3|4 4|||3 4|4 5|| \line
|+---+---+|+---+---+|+---+---+|+---+---+|+---+---+| \line
+---------+---------+---------+---------+---------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      conform IS OP A \{\- \line
         equal EACH shape  \line
           (not (EACH tally A match 1) sublist A) \'7d\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:003b}
{\up $}{\footnote\pard\plain{\up $} content}
{\up #}{\footnote\pard\plain{\up #} 11UQ9BC}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 content\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} content;nesting restructuring operation, content}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nesting restructuring operation\plain\fs20\cf1\cb1 {\v nesting restructuring operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 content A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 link\plain\fs20\cf1\cb1 {\v QD77W5}, \uldb list\plain\fs20\cf1\cb1 {\v 40V8DY}, \uldb in\plain\fs20\cf1\cb1 {\v RJ2SC2}, \uldb solitary\plain\fs20\cf1\cb1 {\v 2BGSG4Y}\line

\par The operation \i content\plain\fs20\cf1\cb1  returns the list of atoms of \i A\plain\fs20\cf1\cb1 .  The effect of content is to remove all structure from an array, returning a list of the atoms in a depth first, row-major order.  The effect on an atom is to produce the solitary of the atom.
\par \pard\keep\sb95 \f1\fs16      A := (2 3) (4 5 (6 7)) \line
+---+---------+ \line
|2 3|+-+-+---+| \line
|   ||4|5|6 7|| \line
|   |+-+-+---+| \line
+---+---------+ \line
 \line
     content A \line
2 3 4 5 6 7\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      content IS OPERATION A \{\- \line
        IF atomic A THEN \line
           list A \line
        ELSE \line
           link EACH content A \line
        ENDIF \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    content A = list content A \line
   content A = content list A \line
   content A = link EACH content A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:003c}
{\up $}{\footnote\pard\plain{\up $} continue}
{\up #}{\footnote\pard\plain{\up #} 1FW5IX}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 continue\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} continue;system expression, continue}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Continue    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 bye\plain\fs20\cf1\cb1 {\v 1ZNBR9K}, \uldb load\plain\fs20\cf1\cb1 {\v QD7_IY}, \uldb save\plain\fs20\cf1\cb1 {\v 25VUZ7O}\line

\par The expression \i Continue\plain\fs20\cf1\cb1  terminates a session of Q'Nial and returns control to the host environment.  The workspace is saved in file \i continue.nws\plain\fs20\cf1\cb1  and is reloaded when Q'Nial is invoked at a later session using the same current directory.  \line

\par If a \i Restart\plain\fs20\cf1\cb1  is executed in a session that began with a continue workspace, the current workspace will be reset to the continue workspace.  If a session that began with a continue is terminated with \i Continue\plain\fs20\cf1\cb1 , the file continue.nws is updated with the current workspace.  If it is terminated with \i Bye\plain\fs20\cf1\cb1 , the file \i continue.nws\plain\fs20\cf1\cb1  is deleted.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:003d}
{\up $}{\footnote\pard\plain{\up $} continue workspace}
{\up #}{\footnote\pard\plain{\up #} 29G9US}
\pard\keepn\sb95 \b\fs25 continue workspace\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, continue workspace;continue workspace}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 continue\plain\fs20\cf1\cb1 {\v 1FW5IX}, \uldb clear workspace\plain\fs20\cf1\cb1 {\v 2R04_UA}\line

\par The file \i continue.nws\plain\fs20\cf1\cb1  is a workspace file that is created when a session is ended with the expression \i Continue\plain\fs20\cf1\cb1 .  When Q'Nial is invoked from the same directory, it will use \i continue.nws\plain\fs20\cf1\cb1  rather than \i clearws.nws\plain\fs20\cf1\cb1  as the initial workspace.  If the Q'Nial invocation names a workspace, that workspace will take precedence over the continue workspace.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:003e}
{\up $}{\footnote\pard\plain{\up $} converse}
{\up #}{\footnote\pard\plain{\up #} 1HS9GX}
\pard\keepn\sb95 \b\fs25 converse\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} applicative transformer, converse;converse}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul applicative transformer\plain\fs20\cf1\cb1 {\v applicative transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A CONVERSE f B   CONVERSE f A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 fold\plain\fs20\cf1\cb1 {\v QD1_TY}\line

\par The transformer \i CONVERSE\plain\fs20\cf1\cb1  is used with a binary operation \i f\plain\fs20\cf1\cb1  and applies \i f\plain\fs20\cf1\cb1  to the pair formed by reversing the arguments of \i CONVERSE f\plain\fs20\cf1\cb1 .
\par \pard\keep\sb95 \f1\fs16      at IS CONVERSE pick \line
     'abcde' at 2 \line
c \line
 \line
     holds IS CONVERSE in \line
     count 20 holds 5 \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the above examples, \i at\plain\fs20\cf1\cb1  and \i holds\plain\fs20\cf1\cb1  are defined in terms of \i pick\plain\fs20\cf1\cb1  and \i in\plain\fs20\cf1\cb1 , respectively.  The first example shows that \i 'abcde' at 2\plain\fs20\cf1\cb1  gives the result expected for \i 2 pick 'abcde'\plain\fs20\cf1\cb1 .  The second example shows that \i count 20 holds 5\plain\fs20\cf1\cb1  gives the same result as \i 5 in (count 20)\plain\fs20\cf1\cb1 .  Thus, \i at\plain\fs20\cf1\cb1  and \i holds\plain\fs20\cf1\cb1  do the same work as \i pick\plain\fs20\cf1\cb1  and \i in\plain\fs20\cf1\cb1 ; the former operations simply use their arguments in the reverse order.  \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      CONVERSE IS TRANSFORMER f OPERATION A B \{\- \line
        B f A \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A CONVERSE CONVERSE f B = A f B \line
   A EACHLEFT f B = B EACHRIGHT CONVERSE f A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:003f}
{\up $}{\footnote\pard\plain{\up $} copyright}
{\up #}{\footnote\pard\plain{\up #} 2.MC.X4}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 copyright\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} constant expression, copyright;copyright}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul constant expression\plain\fs20\cf1\cb1 {\v constant expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Copyright    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 system\plain\fs20\cf1\cb1 {\v .FDS.I}, \uldb version\plain\fs20\cf1\cb1 {\v 4NLJMF}\line

\par The expression \i Copyright\plain\fs20\cf1\cb1  returns a message specifying ownership of the rights to Q'Nial by Queen's University at Kingston, Canada (K7L 3N6).  
\par \pard\keep\sb95 \f1\fs16      Copyright \line
Copyright (c) Queen's University 1983-97\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0040}
{\up $}{\footnote\pard\plain{\up $} cos}
{\up #}{\footnote\pard\plain{\up #} 1_E6SCI}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 cos\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} cos;scientific operation, cos}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 cos A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 sin\plain\fs20\cf1\cb1 {\v 1_E78_D}, \uldb cosh\plain\fs20\cf1\cb1 {\v 1CM0_HB}, \uldb pi\plain\fs20\cf1\cb1 {\v RJ2SIX}\line

\par The operation \i cos\plain\fs20\cf1\cb1  implements the cosine function of mathematics.  It produces the following results when applied to atoms of the six types: 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 cosine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 cosine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 cosine of angle A given in radians \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?cos \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?cos \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      cos  l  -1  0.5  `a  "abc  ??error \line
0.54030 0.54030 0.87758 ?cos ?cos ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    cos opposite A = cos A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0041}
{\up $}{\footnote\pard\plain{\up $} cosh}
{\up #}{\footnote\pard\plain{\up #} 1CM0_HB}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 cosh\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} cosh;scientific operation, cosh}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 cosh A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 sinh\plain\fs20\cf1\cb1 {\v 1CMJ7CB}, \uldb cos\plain\fs20\cf1\cb1 {\v 1_E6SCI}, \uldb pi\plain\fs20\cf1\cb1 {\v RJ2SIX}\line

\par The operation \i cosh\plain\fs20\cf1\cb1  implements the hyperbolic cosine function of mathematics.  It produces the following results when applied to atoms of the six types: 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 hyperbolic cosine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 hyperbolic cosine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 hyperbolic cosine of angle A given in radians \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?cosh \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?cosh \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      cosh  l  -1  0.5 \line
1.54308 1.54308 1.12763 \line
 \line
     cosh `a  "abc  ??error \line
?cosh ?cosh ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    cosh opposite A = cosh A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0042}
{\up $}{\footnote\pard\plain{\up $} count}
{\up #}{\footnote\pard\plain{\up #} TIXI4Z}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 count\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} array generation operation, count;count}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul array generation operation\plain\fs20\cf1\cb1 {\v array generation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 count N    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 tell\plain\fs20\cf1\cb1 {\v 1CMK3AF}\line

\par The operation \i count\plain\fs20\cf1\cb1  generates a list of integers starting at 1 and going up to and including \i N\plain\fs20\cf1\cb1 .  It differs from \i tell\plain\fs20\cf1\cb1  by counting from 1 instead of from 0.  
\par \pard\keep\sb95 \f1\fs16      count 5 \line
1 2 3 4 5 \line
 \line
     .1 times count 5 \line
0.1 0.2 0.3 0.4 0.5\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows \i count\plain\fs20\cf1\cb1  generating the sequence of integers from 1 to 5.  The second example shows how \i count\plain\fs20\cf1\cb1  can be used to generate a sequence of five real numbers with an interval of .1 between each number.  
\par \pard\keep\sb95 \f1\fs16      count 2 3 \line
+---+---+---+ \line
|1 1|1 2|1 3| \line
+---+---+---+ \line
|2 1|2 2|2 3| \line
+---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The third example shows how \i count\plain\fs20\cf1\cb1  generalizes to other arguments in the same manner as the operation \i tell\plain\fs20\cf1\cb1 .  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      count IS OPERATION A \{\- 1 + tell A \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    isshape A ==> shape count A = A \line
   isshape A ==> count A = cart EACH count A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0043}
{\up $}{\footnote\pard\plain{\up $} cull}
{\up #}{\footnote\pard\plain{\up #} 40MD_Q}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 cull\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} cull;selection operation, cull}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 cull A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 except\plain\fs20\cf1\cb1 {\v 1_WLCKE}, \uldb diverse\plain\fs20\cf1\cb1 {\v 19T6FZO}, \uldb bykey\plain\fs20\cf1\cb1 {\v 3HC._3I}\line

\par The operation \i cull\plain\fs20\cf1\cb1  returns a list whose items are those of \i A\plain\fs20\cf1\cb1  with duplicates removed.  The order of the items is maintained.  
\par \pard\keep\sb95 \f1\fs16      cull 3 5 4 3 5 2 4 \line
3 5 4 2 \line
 \line
     cull 'a few letters with duplicates' \line
a fewltrsihdupc\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      cull IS OPERATION A \{\- \line
        grid A EACHLEFT in (A EACHLEFT find A) sublist A \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    cull A = list cull A \line
   diverse A <==> cull A = list A \line
   sortup cull A = cull sortup A \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Pragmatics\plain\fs20\cf1\cb1 \line

\par The operation \i cull\plain\fs20\cf1\cb1  executes faster when a large array has been sorted, hence if the ordering of the result is unimportant it is better to use \i sortup\plain\fs20\cf1\cb1  to order the array prior to applying \i cull\plain\fs20\cf1\cb1 .  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0044}
{\up $}{\footnote\pard\plain{\up $} curried operation}
{\up #}{\footnote\pard\plain{\up #} 3NTT_IU}
\pard\keepn\sb95 \b\fs25 curried operation\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, curried operation;curried operation}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 apply\plain\fs20\cf1\cb1 {\v TGYD34}, \uldb operation composition\plain\fs20\cf1\cb1 {\v 1ZR4NW0}\line

\par A \i curried-operation\plain\fs20\cf1\cb1  is an operation in which the left item of a two-item argument is combined with a given operation to form an operation expression.  Examples are: \i 1+\plain\fs20\cf1\cb1  and \i 3 reshape\plain\fs20\cf1\cb1 .\line

\par A curried operation can be named or grouped in parentheses as an argument to a transformer.  
\par \pard\keep\sb95 \f1\fs16      incr IS 1+ \line
 \line
     EACH (5 take) Lines\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In general, the syntax of a curried operation is: 
\par \pard\keep\sb95 \f1\fs16        curried-operation ::= simple-expression simple-operation\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The result of applying a curried-operation is determined by applying the simple-operation to the pair formed from the simple-expression and the argument to the curried-operation.  Thus, 
\par \pard\keep\sb95 \f1\fs16      (1+) 5 \line
6\plain\fs20\cf1\cb1 \line

\par \pard\sb95 is interpreted as 
\par \pard\keep\sb95 \f1\fs16      + (1 5) \line
6\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0045}
{\up $}{\footnote\pard\plain{\up $} cut}
{\up #}{\footnote\pard\plain{\up #} 1_E6SIJ}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 cut\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} cut;selection operation, cut}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 B cut A   cut B A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 cutall\plain\fs20\cf1\cb1 {\v 3ZO7_NR}\line

\par The operation \i cut\plain\fs20\cf1\cb1  converts an array \i A\plain\fs20\cf1\cb1  into a list of items formed from the items of \i A\plain\fs20\cf1\cb1  according to the bitstring \i B\plain\fs20\cf1\cb1 .  The list of items is divided where true values occur in the corresponding positions in the bitstring \i B\plain\fs20\cf1\cb1 .  The items of \i A\plain\fs20\cf1\cb1  where the divisions occur are not included in the items of the result and any empty segments are not included. 
\par \pard\keep\sb95 \f1\fs16      A := 'The boy stood   on the burning deck' ; \line
     `  match A cut A \line
+---+---+-----+--+---+-------+----+ \line
|The|boy|stood|on|the|burning|deck| \line
+---+---+-----+--+---+-------+----+ \line
 \line
     B := 'Formula 1: 3,5,7,,,9'; \line
 \line
     `, match B cut B \line
+------------+-+-+-+ \line
|Formula 1: 3|5|7|9| \line
+------------+-+-+-+ \line
 \line
     EACH equal tell 4 4 cut tell 4 4 \line
+-----------------+-----------------+-----------------+ \line
|+---+---+---+---+|+---+---+---+---+|+---+---+---+---+| \line
||0 1|0 2|0 3|1 0|||1 2|1 3|2 0|2 1|||2 3|3 0|3 1|3 2|| \line
|+---+---+---+---+|+---+---+---+---+|+---+---+---+---+| \line
+-----------------+-----------------+-----------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \i Cut\plain\fs20\cf1\cb1  can be used to cut a string into a list of substrings.  In the first example, the string is cut at blank characters.  Several adjacent blanks are treated as one blank character.  In the second example, the cut is done where commas occur.  The third example shows that the items of \i A\plain\fs20\cf1\cb1  do not have to be atoms.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      cut IS OPERATION B A \{\- \line
        C := EACH rest (B cutall A); \line
        not EACH empty C sublist C \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    B cut A = (shape A reshape B) cut A \line
   list (B cut A) = B cut A \line
   B cut list A = B cut A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0046}
{\up $}{\footnote\pard\plain{\up $} cutall}
{\up #}{\footnote\pard\plain{\up #} 3ZO7_NR}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 cutall\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} cutall;selection operation, cutall}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 B cutall A   cutall B A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 cut\plain\fs20\cf1\cb1 {\v 1_E6SIJ}\line

\par The operation \i cutall\plain\fs20\cf1\cb1  converts an array \i A\plain\fs20\cf1\cb1  into a list of items formed from the items of \i A\plain\fs20\cf1\cb1  according to the bitstring \i B\plain\fs20\cf1\cb1 .  The list of items is divided where true values occur in the corresponding positions in the bitstring \i B\plain\fs20\cf1\cb1 .  The items where the divisions occur are kept as the first item of each group.  
\par \pard\keep\sb95 \f1\fs16      A := 'The boy stood on the deck' ; \line
     `  match A cutall A \line
+---+----+------+---+----+-----+ \line
|The| boy| stood| on| the| deck| \line
+---+----+------+---+----+-----+ \line
 \line
     B := 'Formula 1: 3,5,7,,,9'; \line
     `, match B cutall B \line
+------------+--+--+-+-+--+ \line
|Formula 1: 3|,5|,7|,|,|,9| \line
+------------+--+--+-+-+--+ \line
 \line
     EACH equal tell 4 4 cutall tell 4 4 \line
+---------------------+---------------------+---------------------+-----+ \line
|+---+---+---+---+---+|+---+---+---+---+---+|+---+---+---+---+---+|+---+| \line
||0 0|0 1|0 2|0 3|1 0|||1 1|1 2|1 3|2 0|2 1|||2 2|2 3|3 0|3 1|3 2|||3 3|| \line
|+---+---+---+---+---+|+---+---+---+---+---+|+---+---+---+---+---+|+---+| \line
+---------------------+---------------------+---------------------+-----+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    tally (B cutall A) = sum (shape A reshape B) \line
   B cutall A = (shape A reshape B) cutall A \line
   list (B cutall A) = B cutall A \line
   B cutall list A = B cutall A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0047}
{\up $}{\footnote\pard\plain{\up $} debugging}
{\up #}{\footnote\pard\plain{\up #} PP0_XH}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 debugging\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, debugging;debugging}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 breakin\plain\fs20\cf1\cb1 {\v 26_7_XB}, \uldb watch\plain\fs20\cf1\cb1 {\v U2JGTN}\line

\par \b Debugging Definitions \plain\fs20\cf1\cb1 \line

\par The Q'Nial system provides an optional debugging facility that aids interactive debugging of definitions.  It is active by default, but can be turned off for running production applications.  See the detailed documentation for the various versions on how to turn off debugging.  \line

\par The debugging system is based on the idea of placing breaks in the code and stepping through the program code in a number of different ways.  Due to constraints in the way Q'Nial is implemented, debugging is always done in the context of an expression sequence.  A break point occurs either before the execution of the expression sequence in a definition, or at an explicit break expression within an expression sequence.  There is also a watch mechanism that executes a defined action whenever the value of a variable changes, and an ability monitor all use of user defined objects and of the predefined operations.  \line

\par \pard\sb95 \b Defining a Break Point \plain\fs20\cf1\cb1 \line

\par There are two ways to cause a break in a Nial definition: by using the expression \i Break\plain\fs20\cf1\cb1  in an expression sequence, or by using the operation \i breakin\plain\fs20\cf1\cb1  to set a break on entry to the operation.  The following table summarizes the break related primitives:
\par  \trowd\trgaph175\trleft-6 \cellx1775\cellx5795\pard\intbl\sb95 \b Expression \cell\pard \pard\intbl\sb95 Action \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1775\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 Break \cell\pard \pard\intbl\sb95 Suspend evaluation of the expression and pass control to an evaluation loop in the environment at the point of the break. Variables accessible at that point can be displayed. This loop recognizes a number of commands described below. \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1775\cellx5795\pard\intbl\sb95 breakin Nm [M] \cell\pard \pard\intbl\sb95 Set or rest an internal break flag for the definition of \i Nm\plain\fs20\cf1\cb1 . If the boolean value \i M\plain\fs20\cf1\cb1  is omitted, the flag is toggled. If set, a break occurs before the execution of the expression sequence of the definition.  The \i Nm\plain\fs20\cf1\cb1  must be the name of a defined expression or a defined operation using the operation form style of operation expression. \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1775\cellx5795\pard\intbl\sb95 Breaklist \cell\pard \pard\intbl\sb95 Display the list of names of definitions with break flag set. \cell\intbl\row
\pard \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0048}
{\up $}{\footnote\pard\plain{\up $} deepplace}
{\up #}{\footnote\pard\plain{\up #} 0UY7YL}
\pard\keepn\sb95 \b\fs25 deepplace\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} deepplace;insertion operation, deepplace}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul insertion operation\plain\fs20\cf1\cb1 {\v insertion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 B P deepplace A   deepplace (B P) A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 place\plain\fs20\cf1\cb1 {\v TVU4TK}, \uldb placeall\plain\fs20\cf1\cb1 {\v 1_2.DUD}, \uldb deepupdate\plain\fs20\cf1\cb1 {\v 5IR4_G}\line

\par The operation \i deepplace\plain\fs20\cf1\cb1  returns an array the same as \i A\plain\fs20\cf1\cb1  except that the array at path \i P\plain\fs20\cf1\cb1  is replaced by \i B\plain\fs20\cf1\cb1 .  It is the insertion operation corresponding to the selection operation \i reach\plain\fs20\cf1\cb1  and generalizes the operation \i place\plain\fs20\cf1\cb1  from addresses to paths.  
\par \pard\keep\sb95 \f1\fs16      A1 := 1 2 (3 4 (5 6 (7 (8 9)))) \line
+-+-+-------------------+ \line
|1|2|+-+-+-------------+| \line
| | ||3|4|+-+-+-------+|| \line
| | || | ||5|6|+-+---+||| \line
| | || | || | ||7|8 9|||| \line
| | || | || | |+-+---+||| \line
| | || | |+-+-+-------+|| \line
| | |+-+-+-------------+| \line
+-+-+-------------------+ \line
     A1 := "M (2 2 2 0) deepplace A1 \line
+-+-+-------------------+ \line
|1|2|+-+-+-------------+| \line
| | ||3|4|+-+-+-------+|| \line
| | || | ||5|6|+-+---+||| \line
| | || | || | ||M|8 9|||| \line
| | || | || | |+-+---+||| \line
| | || | |+-+-+-------+|| \line
| | |+-+-+-------------+| \line
+-+-+-------------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The array 7 is replaced with \i M\plain\fs20\cf1\cb1 .  Since the result of the insertion is assigned to variable A1, the insertion of M is retained.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      deepplace IS OPERATION C A \{\-  \line
        B Path := C ;  \line
        IF empty Path THEN  \line
           B  \line
        ELSE  \line
           I := first Path ;  \line
           ((B (rest Path)) deepplace (I pick A)) I place A  \line
        ENDIF \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    Path a valid path into A ==> ( Path reach A ) Path deepplace A = A \line
   B Null deepplace A = B, I in grid A ==> B \'5c[I] deepplace A = B I place A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0049}
{\up $}{\footnote\pard\plain{\up $} deepupdate}
{\up #}{\footnote\pard\plain{\up #} 5IR4_G}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 deepupdate\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} deepupdate;evaluation operation, deepupdate}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 deepupdate Nm P A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 update\plain\fs20\cf1\cb1 {\v 4AIR_VK}, \uldb updateall\plain\fs20\cf1\cb1 {\v I.4L_C}, \uldb deepplace\plain\fs20\cf1\cb1 {\v 0UY7YL}\line

\par The operation \i deepupdate\plain\fs20\cf1\cb1  provides the semantics of the \i Nm@@P := A\plain\fs20\cf1\cb1  form of assignment expression.  \i Nm\plain\fs20\cf1\cb1  must be an existing variable represented by a string, phrase or a cast; \i P\plain\fs20\cf1\cb1  is the path of addresses to the location to be updated; and \i A\plain\fs20\cf1\cb1  is the array to be placed in the variable.  
\par \pard\keep\sb95 \f1\fs16      Array1 := (1 2(3 4 (5 6 (7 (8 9))))) \line
+-+-+-------------------+ \line
|1|2|+-+-+-------------+| \line
| | ||3|4|+-+-+-------+|| \line
| | || | ||5|6|+-+---+||| \line
| | || | || | ||7|8 9|||| \line
| | || | || | |+-+---+||| \line
| | || | |+-+-+-------+|| \line
| | |+-+-+-------------+| \line
+-+-+-------------------+ \line
 \line
     deepupdate "Array1 (2 2 2 1 0) "Tom \line
+-+-+---------------------+ \line
|1|2|+-+-+---------------+| \line
| | ||3|4|+-+-+---------+|| \line
| | || | ||5|6|+-+-----+||| \line
| | || | || | ||7|Tom 9|||| \line
| | || | || | |+-+-----+||| \line
| | || | |+-+-+---------+|| \line
| | |+-+-+---------------+| \line
+-+-+---------------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The major purpose of \i deepupdate\plain\fs20\cf1\cb1  is to allow a selective update with a path on a global variable without forcing a copy.  By passing the name of the variable to the operation that is doing the update, rather than its value, no sharing of the internal data is made and hence the update can be made "in place".  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:004a}
{\up $}{\footnote\pard\plain{\up $} definition}
{\up #}{\footnote\pard\plain{\up #} K9LSXA}
\pard\keepn\sb95 \b\fs25 definition\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, definition;definition}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 expression\plain\fs20\cf1\cb1 {\v FD5QFK}, \uldb operation\plain\fs20\cf1\cb1 {\v CQFG7.}, \uldb transformer\plain\fs20\cf1\cb1 {\v 1VQL398}\line

\par A \b definition\plain\fs20\cf1\cb1  in Nial is a syntactic construct that names a program fragment. The syntax is one of the three forms:
\par \pard\keep\sb95 \f1\fs16      <name>  IS  <array expression>  \line
     <name>  IS  <operation expression>  \line
     <name>  IS  <transformer expression> \plain\fs20\cf1\cb1 \line

\par \pard\sb95 A definition is used to associate a name (identifier) with a program fragment that is an array expression, an operation expression or a transformer expression.  If the definition appears within a block, the association is made in the local environment.  Otherwise, the association is made in the global environment and assigns a role to the name as representing that kind of expression.  \line

\par If the program fragment is syntactically correct, the name is associated with the program fragment in the environment and no result is given.  If a syntax error is detected in the analysis of the program fragment, an explanatory fault message is returned and the name association is not made.\line

\par \pard\sb95 If the name being associated in a definition is already in use, the new definition must be for a construct of the same role and the earlier definition is replaced.  The use of a defined name always refers to its most recent definition.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:004b}
{\up $}{\footnote\pard\plain{\up $} deparse}
{\up #}{\footnote\pard\plain{\up #} 15N2FZO}
\pard\keepn\sb95 \b\fs25 deparse\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} deparse;evaluation operation, deparse}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 deparse Pt    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 descan\plain\fs20\cf1\cb1 {\v 7ABG_7N}, \uldb parse\plain\fs20\cf1\cb1 {\v TVJF9K}, \uldb scan\plain\fs20\cf1\cb1 {\v 1CMJ16H}, \uldb see\plain\fs20\cf1\cb1 {\v 1ZNC7PK}\line

\par The operation \i deparse\plain\fs20\cf1\cb1  is used to convert a parse tree representation of a Nial definition or program fragment into a token stream which can be converted into text corresponding to the Nial definition.  The argument to \i deparse\plain\fs20\cf1\cb1  must be either a cast or the result of \i parse\plain\fs20\cf1\cb1  or \i getdef\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      deparse !(Pi * cos 0.5) \line
99 1 ( 2 Pi 2 * 2 cos 18 0.5 1 )\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The principal use of \i deparse\plain\fs20\cf1\cb1  is in displaying Nial definitions.  It is used in the definition of \i defedit\plain\fs20\cf1\cb1  and \i see\plain\fs20\cf1\cb1 .  \line

\par The token stream returned by \i deparse\plain\fs20\cf1\cb1  also includes indicators to identify where new lines are to begin and to control indentation.  The tokens corresponding to identifiers are given in the canonical form, indicating what role each token plays.  \line

\par The result of \i deparse\plain\fs20\cf1\cb1  is implementation dependent and should be viewed as an internal representation provided as an interface to editing.  It is subject to change as Q'Nial evolves.  \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    Pt a parse tree ==> parse deparse Pt = Pt \line
   Ts a token stream ==> parse deparse parse Ts = parse Ts \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:004c}
{\up $}{\footnote\pard\plain{\up $} depth}
{\up #}{\footnote\pard\plain{\up #} TJND0N}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 depth\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} depth;measurement operation, depth}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 tally A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 tally\plain\fs20\cf1\cb1 {\v 5JEH.UN}, \uldb down\plain\fs20\cf1\cb1 {\v 25VG_8X}\line

\par The operation \i depth\plain\fs20\cf1\cb1  returns an integer indicating the number of levels of nesting of the array.  This is called the depth of the array.  The depth of an atom is 0.  The depth of a simple nonempty  is 1. In general, the depth of an array is 1 plus the maximum of the depths of the items. 
\par \pard\keep\sb95 \f1\fs16      depth "abc \line
0 \line
     depth 3 4 5 \line
1 \line
     depth 1 (2 3) (4 5 6) \line
2 \line
     depth [2, [3, 4, [5],8],24] \line
3\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      depth IS OPERATION A  \line
     \{\- IF atomic A THEN \line
          0 \line
       ELSE \line
          1 + (max EACH depth A) \line
       ENDIF \line
     \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    depth Null = max Null \line
   tally depth A = 1 \line
   depth A = FORK [atomic, 0 first, 1 plus max EACH depth] A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:004d}
{\up $}{\footnote\pard\plain{\up $} descan}
{\up #}{\footnote\pard\plain{\up #} 7ABG_7N}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 descan\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} descan;evaluation operation, descan}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 descan Ts    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 scan\plain\fs20\cf1\cb1 {\v 1CMJ16H}, \uldb deparse\plain\fs20\cf1\cb1 {\v 15N2FZO}, \uldb see\plain\fs20\cf1\cb1 {\v 1ZNC7PK}, \uldb canonical\plain\fs20\cf1\cb1 {\v NZPQUY}\line

\par The operation \i descan\plain\fs20\cf1\cb1  converts a token stream to a list of strings that represents the program fragment given by the token stream.  The input to \i descan\plain\fs20\cf1\cb1  must be a token stream produced by \i scan\plain\fs20\cf1\cb1  or \i deparse\plain\fs20\cf1\cb1  or an equivalent list of tokens.  
\par \pard\keep\sb95 \f1\fs16      descan scan 'A + 32' \line
+-------+ \line
|A + 32 | \line
+-------+ \line
 \line
     descan deparse !(Pi * cos 0.5) \line
+-----------------+ \line
|( Pi * cos 0.5 ) | \line
+-----------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The principal use of \i descan\plain\fs20\cf1\cb1  is in displaying Nial definitions.  It is used to define \i defedit\plain\fs20\cf1\cb1  and \i see\plain\fs20\cf1\cb1 .  The argument to \i descan\plain\fs20\cf1\cb1  may also include tokens indicating the beginning of new lines and controlling indentation used to display a structured definition.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    S a string of Nial text ==> scan link descan scan S = scan S \line
   S a string of Nial text ==> canonical canonical S = canonical S \line
   S a string of Nial text ==> execute canonical S = execute S \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:004e}
{\up $}{\footnote\pard\plain{\up $} diagram}
{\up #}{\footnote\pard\plain{\up #} G5WG1G}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 diagram\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} diagram;picture operation, diagram}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul picture operation\plain\fs20\cf1\cb1 {\v picture operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 diagram A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 display\plain\fs20\cf1\cb1 {\v GH5A1S}, \uldb paste\plain\fs20\cf1\cb1 {\v TVJG0K}, \uldb picture\plain\fs20\cf1\cb1 {\v __8RKL}, \uldb positions\plain\fs20\cf1\cb1 {\v 1AGU44_}, \uldb sketch\plain\fs20\cf1\cb1 {\v .86S0D}, \uldb set\plain\fs20\cf1\cb1 {\v 1_E789J}\line

\par The operation \i diagram\plain\fs20\cf1\cb1  computes a character table that gives the fully boxed picture of \i A\plain\fs20\cf1\cb1  with the decoration of the atoms determined by the current setting of the decor switch.  An array is displayed as a frame with cells for each item.  It is arranged in two dimensions, using groupings of table frames to picture arrays of higher dimension.  Each cell is large enough to hold the diagram of the corresponding item of \i A\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 The diagram of an atom is a picture that indicates its value.  The diagram of a non-atomic single has an "o" in its upper left corner.  \line

\par \i Diagram\plain\fs20\cf1\cb1  returns the display given by the operation \i picture\plain\fs20\cf1\cb1  when in diagram mode of display.  \line

\par The decor or nodecor mode switch controls the display of atoms.  With decor set, it gives a picture that distinguishes all atoms.  
\par \pard\keep\sb95 \f1\fs16      set "decor; \line
     A := diagram (2 3 2 reshape 3 'abc' (2 1 reshape count 3) "apple 8.5 \line
          (3 4)); \line
     set "nodecor; A \line
+---+----------+  +---+----------+ \line
|  3|+--+--+--+|  |  3|+--+--+--+| \line
|   ||`a|`b|`c||  |   ||`a|`b|`c|| \line
|   |+--+--+--+|  |   |+--+--+--+| \line
+---+----------+  +---+----------+ \line
|+-+|"apple    |  |+-+|"apple    | \line
||1||          |  ||1||          | \line
|+-+|          |  |+-+|          | \line
||2||          |  ||2||          | \line
|+-+|          |  |+-+|          | \line
+---+----------+  +---+----------+ \line
|8.5|+-+-+     |  |8.5|+-+-+     | \line
|   ||3|4|     |  |   ||3|4|     | \line
|   |+-+-+     |  |   |+-+-+     | \line
+---+----------+  +---+----------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The display of the result of a \i picture\plain\fs20\cf1\cb1  operation, such as \i diagram\plain\fs20\cf1\cb1 , makes sense when it itself is pictured in sketch-nodecor mode.  In other modes, the characters making up the table would be boxed and/or decorated.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      diagram IS OPERATION A \{\-  \line
        Old_setting := set "diagram ;  \line
        Result := picture A ;  \line
        set Old_setting ;  \line
        Result \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:004f}
{\up $}{\footnote\pard\plain{\up $} dimensions}
{\up #}{\footnote\pard\plain{\up #} 12_I6ZM}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 dimensions\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, dimensions;dimensions}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 valence\plain\fs20\cf1\cb1 {\v MQJNXM}, \uldb axes\plain\fs20\cf1\cb1 {\v 40KG6X}\line

\par The number of axes of an array is referred to as its dimensionality.  In array theory terminology the dimensionality is called the \b valence\plain\fs20\cf1\cb1  of the array.  The following terms describe arrays by their valence: 
\par  \trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 \b Valence \cell\pard \pard\intbl\sb95 Description \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 0 \cell\pard \pard\intbl\sb95 single \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 1 \cell\pard \pard\intbl\sb95 list, vector \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 2 \cell\pard \pard\intbl\sb95 table, matrix \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 2 or more \cell\pard \pard\intbl\sb95 multivalent \cell\intbl\row
\pard \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0050}
{\up $}{\footnote\pard\plain{\up $} display}
{\up #}{\footnote\pard\plain{\up #} GH5A1S}
\pard\keepn\sb95 \b\fs25 display\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} display;picture operation, display}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul picture operation\plain\fs20\cf1\cb1 {\v picture operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 display A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 picture\plain\fs20\cf1\cb1 {\v __8RKL}, \uldb execute\plain\fs20\cf1\cb1 {\v 3WULI4D}\line

\par The operation \i display\plain\fs20\cf1\cb1  returns a string which, when executed, returns the value \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      set "decor; display 23.5 \line
'23.5'\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \i Display\plain\fs20\cf1\cb1  inserts the operation to construct values that cannot be described directly by constants.  In the example below, since the phrase containing a blank character cannot be specified simply using the phrase mark, display inserts the operation \i phrase\plain\fs20\cf1\cb1  and the string that will create the desired phrase \i An answer\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      display "Nm (phrase 'An answer') 'Nm' \line
'["Nm,(phrase 'An answer'),'Nm']' \line
 \line
     X := "Name (2 3 (4 5) 'Queen''s' (3 2 reshape count 6)) \line
+-----+-----------------------+ \line
|"Name|+-+-+---+---------+---+| \line
|     ||2|3|4 5|'Queen's'|1 2|| \line
|     || | |   |         |3 4|| \line
|     || | |   |         |5 6|| \line
|     |+-+-+---+---------+---+| \line
+-----+-----------------------+ \line
 \line
     display X \line
'["Name,[2,3,4 5,'Queen''s',3 2 reshape 1 2 3 4 5 6]]' \line
 \line
     execute display X = X \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the definition of \i X\plain\fs20\cf1\cb1 , strand notation was used.  In the display of \i X\plain\fs20\cf1\cb1 , brackets notation is created to represent \i X\plain\fs20\cf1\cb1 .  The display is seen to be correct by the last example that shows that the \i execute\plain\fs20\cf1\cb1  of the \i display\plain\fs20\cf1\cb1  of \i X\plain\fs20\cf1\cb1  is \i X\plain\fs20\cf1\cb1 .  \line

\par \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    execute display A = A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0051}
{\up $}{\footnote\pard\plain{\up $} diverse}
{\up #}{\footnote\pard\plain{\up #} 19T6FZO}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 diverse\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} diverse;logic operation, diverse}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul logic operation\plain\fs20\cf1\cb1 {\v logic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 diverse A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 equal\plain\fs20\cf1\cb1 {\v TKZHRR}, \uldb in\plain\fs20\cf1\cb1 {\v RJ2SC2}, \uldb cull\plain\fs20\cf1\cb1 {\v 40MD_Q}\line

\par The operation \i diverse\plain\fs20\cf1\cb1  tests whether or not the items of \i A\plain\fs20\cf1\cb1  are all different.  It returns \i true\plain\fs20\cf1\cb1  if they are and \i false\plain\fs20\cf1\cb1  if they are not.  
\par \pard\keep\sb95 \f1\fs16      diverse 2 3 5 \line
l \line
 \line
     diverse 'hello world' \line
o \line
 \line
     diverse 2 3 (2 3) \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the last example, the items are all different because the last item is a pair of items (2 3) which is not the same as 2 or 3.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      diverse IS OPERATION A \{\- cull A = list A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Pragmatics\plain\fs20\cf1\cb1 \line

\par The operation \i diverse\plain\fs20\cf1\cb1  executes faster when a large array has been sorted, hence it is better to use \i sortup\plain\fs20\cf1\cb1  to order a large array prior to applying \i diverse\plain\fs20\cf1\cb1 .  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0052}
{\up $}{\footnote\pard\plain{\up $} divide}
{\up #}{\footnote\pard\plain{\up #} 6242D6P}
\pard\keepn\sb95 \b\fs25 divide\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, divide;divide}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A divide B   A / B   A div B   divide A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 product\plain\fs20\cf1\cb1 {\v 2H9LPX5}, \uldb quotient\plain\fs20\cf1\cb1 {\v KJKAFK}, \uldb mod\plain\fs20\cf1\cb1 {\v 1_E72C0}, \uldb reciprocal\plain\fs20\cf1\cb1 {\v AJCGJN}\line

\par The operation \i divide\plain\fs20\cf1\cb1  returns the result of dividing two numeric atoms.  It coerces the type of the atoms to be real and gives a real number result.  If \i B\plain\fs20\cf1\cb1  is a numeric zero, the result is the fault \i ?div\plain\fs20\cf1\cb1 .  \line

\par If one argument is numeric and the other is a fault or if both arguments are the same fault, the answer is the fault.  In all other cases when one or more of the arguments is not numeric, the result is the arithmetic fault \i ?A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      R gets 1 2 2.5 `a "abc ??error \line
1 2 2.5 `a "abc ??error \line
 \line
     R outer divide R \line
    1.    0.5    0.4 ?A ?A ?error \line
    2.     1.    0.8 ?A ?A ?error \line
   2.5   1.25     1. ?A ?A ?error \line
?A     ?A     ?A     ?A ?A ?A \line
?A     ?A     ?A     ?A ?A ?A \line
?error ?error ?error ?A ?A ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The above example illustrates all combinations of atom types for the two arguments to \i divide\plain\fs20\cf1\cb1 .  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    1.0 divide A = reciprocal A \line
   A divide B = A times reciprocal B (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0053}
{\up $}{\footnote\pard\plain{\up $} dlllist}
{\up #}{\footnote\pard\plain{\up #} 1YSI_GC}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 dlllist\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} dlllist;system expression, dlllist}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Dlllist    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 calldllfun\plain\fs20\cf1\cb1 {\v 201S2GS}, \uldb registerdllfun\plain\fs20\cf1\cb1 {\v R.9.XP}\line

\par The expression \i Dlllist\plain\fs20\cf1\cb1  provides a list of the current routines that have been registered.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0054}
{\up $}{\footnote\pard\plain{\up $} down}
{\up #}{\footnote\pard\plain{\up #} 25VG_8X}
\pard\keepn\sb95 \b\fs25 down\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} down;recursion transformer, down}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul recursion transformer\plain\fs20\cf1\cb1 {\v recursion transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 DOWN [test, endf, structf, joinf] A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 recur\plain\fs20\cf1\cb1 {\v 7OB7OH}, \uldb across\plain\fs20\cf1\cb1 {\v G9ON74}\line

\par  DOWN is a general transformer that recurs over the depth of an array to some arbitrary level.  DOWN has four operation arguments: \i test\plain\fs20\cf1\cb1  tests when the recursion has gone as deep as necessary, \i endf\plain\fs20\cf1\cb1  is applied to the argument that satisfies \i test\plain\fs20\cf1\cb1 , \i structf\plain\fs20\cf1\cb1  rearranges the argument before recurring on each item, and \i joinf\plain\fs20\cf1\cb1  combines the results of the recursion on the items. 
\par \pard\keep\sb95 \f1\fs16      DOWN [ atomic, 0 minus, pass, pass]  3 -4 (5 6) \line
+--+-+-----+ \line
|-3|4|-5 -6| \line
+--+-+-----+ \line
     DOWN [ simple, dosum, pack, pass ] 3 4 5 6 \line
18 \line
     DOWN [ atomic, 0 first, pass, 1 plus max ] [2, [3, 4, [5],8],24] \line
3 \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16 DOWN IS TRANSFORMER test endf structf joinf OPERATION A \{\- \line
   Candidates := [A]; \line
   Results := Null; \line
   WHILE not empty Candidates DO \line
     Candidates B := [front, last] Candidates; \line
     IF B = "Start THEN \line
        Candidates Shp := [front, last] Candidates; \line
        N := prod Shp; \line
        IF N = 0 THEN N := N + 1; ENDIF; \line
        Results Items := opposite N [drop, take] Results; \line
        Results := Results append joinf (Shp reshape Items);    \line
     ELSEIF test B THEN \line
        Results := results append endf B; \line
     ELSE \line
        B := structf B; \line
        Candidates := Candidates link [shape B, "Start] link reverse list B; \line
       IF empty B THEN Candidates := Candidates append first B; ENDIF; \line
ENDIF; \line
   ENDWHILE; \line
   first Results \'7d \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    DOWN [test, endf, structf, joinf ] A = FORK [test, endf, joinf EACH DOWN [test, endf, structf, joinf] structf ] A \line
   opposite A = DOWN [ atomic, 0 minus, pass, pass] A \line
   sum A = DOWN [ simple, dosum, pack, pass ] A \line
   depth A = DOWN [ atomic, 0 minus, pass, pass] A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0055}
{\up $}{\footnote\pard\plain{\up $} drop}
{\up #}{\footnote\pard\plain{\up #} 5FYX_OT}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 drop\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} drop;selection operation, drop}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A drop B   drop A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 take\plain\fs20\cf1\cb1 {\v 25VVYWO}, \uldb rest\plain\fs20\cf1\cb1 {\v 1CMI3HN}\line

\par The operation \i drop\plain\fs20\cf1\cb1  selects the items of an array after a specified number of items have been dropped.  If \i B\plain\fs20\cf1\cb1  is a list and \i A\plain\fs20\cf1\cb1  is a non-negative integer, the result is the list formed from dropping \i A\plain\fs20\cf1\cb1  items from the front of \i B\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  is a negative integer, the result is formed by dropping \i abs A\plain\fs20\cf1\cb1  items from the right end of \i B\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 If \i B\plain\fs20\cf1\cb1  is a table and \i A\plain\fs20\cf1\cb1  is a pair of non-negative integers, the result is lower right corner of \i B\plain\fs20\cf1\cb1  that remains after dropping the number of rows and columns indicated by \i A\plain\fs20\cf1\cb1  from the upper left corner of \i B\plain\fs20\cf1\cb1 .  If one or both items of \i A\plain\fs20\cf1\cb1  are negative, the dropping occurs from the other end of the extent of the corresponding axis.  \line

\par For a higher dimensional array \i B\plain\fs20\cf1\cb1 , \i tally A\plain\fs20\cf1\cb1  must equal \i valence B\plain\fs20\cf1\cb1 ; and the result is obtained by dropping from the front or back of the extents along each axis.  If \i B\plain\fs20\cf1\cb1  is a single and \i product A\plain\fs20\cf1\cb1  is zero, the result is \i B\plain\fs20\cf1\cb1 ; otherwise the result is an empty array with valence of tally \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      2 drop "Able "Baker "Charlie "Dog \line
Charlie Dog \line
 \line
     T1 := tell 2 4 \line
+---+---+---+---+ \line
|0 0|0 1|0 2|0 3| \line
+---+---+---+---+ \line
|1 0|1 1|1 2|1 3| \line
+---+---+---+---+ \line
 \line
     1 2 drop T1 \line
+---+---+ \line
|1 2|1 3| \line
+---+---+ \line
 \line
     1 -2 drop T1 \line
+---+---+ \line
|1 0|1 1| \line
+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      drop IS OPERATION A B \{\-  \line
        IF not and EACH isinteger A THEN  \line
           fault '?left arg of drop must be integers'  \line
        ELSEIF valence B = 0 THEN  \line
           IF product A > 0 THEN  \line
              (tally A reshape 0) reshape B  \line
           ELSE  \line
              B  \line
           ENDIF  \line
        ELSEIF tally A ~= valence B THEN  \line
           fault '?valence error in drop'  \line
        ELSE  \line
           ((A < 0) + (-1 * (A >= 0) )) * (shape B - abs A max 0) take B  \line
        ENDIF \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    0 times shape B drop B = B \line
   tally B drop list B = Null \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0056}
{\up $}{\footnote\pard\plain{\up $} dropright}
{\up #}{\footnote\pard\plain{\up #} H_F96H}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 dropright\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} dropright;selection operation, dropright}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A dropright B   dropright A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 drop\plain\fs20\cf1\cb1 {\v 5FYX_OT}, \uldb takeright\plain\fs20\cf1\cb1 {\v 149YX4U}, \uldb front\plain\fs20\cf1\cb1 {\v 7COCHJ}\line

\par The operation \i dropright\plain\fs20\cf1\cb1  is an obsolete operation that drops items from the ends of extents. It is provided to retain compatibility with earlier versions of Q'Nial.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      dropright IS OPERATION A B \{\- opposite A drop B \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0057}
{\up $}{\footnote\pard\plain{\up $} each}
{\up #}{\footnote\pard\plain{\up #} QCZZL2}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 each\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} distributive transformer, each;each}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul distributive transformer\plain\fs20\cf1\cb1 {\v distributive transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 EACH f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 eachall\plain\fs20\cf1\cb1 {\v LYL6P6}, \uldb eachboth\plain\fs20\cf1\cb1 {\v 1R110IM}, \uldb eachleft\plain\fs20\cf1\cb1 {\v BIN189}, \uldb eachright\plain\fs20\cf1\cb1 {\v X9UDS7}, \uldb iterate\plain\fs20\cf1\cb1 {\v 11O99LP}, \uldb unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}\line

\par The transformer \i EACH\plain\fs20\cf1\cb1  forms an operation, called the \i EACH\plain\fs20\cf1\cb1  transform of \i f\plain\fs20\cf1\cb1 , that applies \i f\plain\fs20\cf1\cb1  to every item of the argument \i A\plain\fs20\cf1\cb1 .  The shape of the result of the application of \i EACH f\plain\fs20\cf1\cb1  to \i A\plain\fs20\cf1\cb1  is the same shape as \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      EACH reverse ('abc' 'def' 'ghi') \line
+---+---+---+ \line
|cba|fed|ihg| \line
+---+---+---+ \line
 \line
     EACH first tell 3 4 \line
0 0 0 0 \line
1 1 1 1 \line
2 2 2 2\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \i EACH\plain\fs20\cf1\cb1  is used to distribute an operation \i f\plain\fs20\cf1\cb1  across an entire array \i A\plain\fs20\cf1\cb1 . Its use avoids the need to explicitly allocate space for the result and to write an explicit loop to apply \i f\plain\fs20\cf1\cb1  to each item of \i A\plain\fs20\cf1\cb1  individually.\line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape EACH f A = shape A \line
   I in grid A ==> I pick (EACH f A) = f (I pick A) \line
   (EACH f) (EACH g) A = EACH (f g) A \line
   EACH f A = shape A reshape (f first A hitch EACH f rest A) \line
   EACH f single A = single f A \line
   EACH f solitary A = solitary f A \line
   EACH f list A = list EACH f A \line
   isshape A ==> EACH f (A reshape B) = A reshape EACH f B \line
   EACH f link A = link EACH EACH f A \line
   EACH EACH f cart A = cart EACH EACH f A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0058}
{\up $}{\footnote\pard\plain{\up $} eachall}
{\up #}{\footnote\pard\plain{\up #} LYL6P6}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 eachall\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} distributive transformer, eachall;eachall}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul distributive transformer\plain\fs20\cf1\cb1 {\v distributive transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 EACHALL f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 each\plain\fs20\cf1\cb1 {\v QCZZL2}, \uldb eachboth\plain\fs20\cf1\cb1 {\v 1R110IM}, \uldb eachleft\plain\fs20\cf1\cb1 {\v BIN189}, \uldb eachright\plain\fs20\cf1\cb1 {\v X9UDS7}, \uldb pack\plain\fs20\cf1\cb1 {\v QD0ZL5}, \uldb multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}\line

\par The transformer \i EACHALL\plain\fs20\cf1\cb1  forms an operation which applies \i f\plain\fs20\cf1\cb1  to arrays formed by selecting the items of the items of \i A\plain\fs20\cf1\cb1  in corresponding positions, assuming that the items of \i A\plain\fs20\cf1\cb1  are all of the same shape.  \line

\par When the items of \i A\plain\fs20\cf1\cb1  are not all the same shape, \i A\plain\fs20\cf1\cb1  is examined to see if all the items with tally greater than one have the same shape.  If so, all the items of tally 1 are replicated to that shape.  If not, the fault \i ?conform\plain\fs20\cf1\cb1  is returned.  \i EACHALL\plain\fs20\cf1\cb1  is implicitly applied in multi pervasive operations.  
\par \pard\keep\sb95 \f1\fs16      A := 9 [2] (4 4 reshape (5+tell 16)) \line
+-+-+-----------+ \line
|9|2| 5  6  7  8| \line
| | | 9 10 11 12| \line
| | |13 14 15 16| \line
| | |17 18 19 20| \line
+-+-+-----------+ \line
     pack A \line
+------+------+------+------+ \line
|9 2 5 |9 2 6 |9 2 7 |9 2 8 | \line
+------+------+------+------+ \line
|9 2 9 |9 2 10|9 2 11|9 2 12| \line
+------+------+------+------+ \line
|9 2 13|9 2 14|9 2 15|9 2 16| \line
+------+------+------+------+ \line
|9 2 17|9 2 18|9 2 19|9 2 20| \line
+------+------+------+------+ \line
 \line
     (EACH sum) pack A \line
16 17 18 19 \line
20 21 22 23 \line
24 25 26 27 \line
28 29 30 31 \line
 \line
     EACHALL sum A \line
16 17 18 19 \line
20 21 22 23 \line
24 25 26 27 \line
28 29 30 31 \line
 \line
     sum A \line
16 17 18 19 \line
20 21 22 23 \line
24 25 26 27 \line
28 29 30 31\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The example shows that \i EACHALL\plain\fs20\cf1\cb1  is defined in terms of \i pack\plain\fs20\cf1\cb1  and is implicitly used in the multi pervasive operation \i sum\plain\fs20\cf1\cb1 .  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      EACHALL IS TRANSFORMER f OPERATION A \{\- EACH f pack A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape EACHALL f A = shape pack A \line
   I in grid pack A ==> I pick (EACHALL f A) = f (I pick pack A) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0059}
{\up $}{\footnote\pard\plain{\up $} eachboth}
{\up #}{\footnote\pard\plain{\up #} 1R110IM}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 eachboth\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} distributive transformer, eachboth;eachboth}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul distributive transformer\plain\fs20\cf1\cb1 {\v distributive transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A EACHBOTH f B   EACHBOTH f A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 each\plain\fs20\cf1\cb1 {\v QCZZL2}, \uldb eachall\plain\fs20\cf1\cb1 {\v LYL6P6}, \uldb eachleft\plain\fs20\cf1\cb1 {\v BIN189}, \uldb eachright\plain\fs20\cf1\cb1 {\v X9UDS7}, \uldb pack\plain\fs20\cf1\cb1 {\v QD0ZL5}, \uldb binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}\line

\par The transformer \i EACHBOTH\plain\fs20\cf1\cb1  forms an operation which applies \i f\plain\fs20\cf1\cb1  to pairs formed by selecting the items of \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  in corresponding positions, assuming that \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  have the same shape.  \line

\par When \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  do not have the same shape, if either \i A\plain\fs20\cf1\cb1  or \i B\plain\fs20\cf1\cb1  has only one item, that item is replicated to the shape of the other argument; otherwise, the fault \i ?conform\plain\fs20\cf1\cb1  is returned.  \line

\par \pard\sb95 \i EACHBOTH\plain\fs20\cf1\cb1  is used implicitly in all binary pervasive operations.  
\par \pard\keep\sb95 \f1\fs16      7 2 1 EACHBOTH post 4 5 3 \line
+-+-+-+ \line
|7|2|1| \line
|4|5|3| \line
+-+-+-+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      EACHBOTH IS TRANSFORMER f OPERATION A B \{\- EACHALL f A B \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape (A EACHBOTH f B) = shape (A pack B) \line
   I in grid pack A B ==> I pick (A EACHBOTH f B) = f (I pick (A pack B)) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:005a}
{\up $}{\footnote\pard\plain{\up $} eachleft}
{\up #}{\footnote\pard\plain{\up #} BIN189}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 eachleft\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} distributive transformer, eachleft;eachleft}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul distributive transformer\plain\fs20\cf1\cb1 {\v distributive transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A EACHLEFT f B   EACHLEFT f A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 each\plain\fs20\cf1\cb1 {\v QCZZL2}, \uldb eachall\plain\fs20\cf1\cb1 {\v LYL6P6}, \uldb eachboth\plain\fs20\cf1\cb1 {\v 1R110IM}, \uldb eachright\plain\fs20\cf1\cb1 {\v X9UDS7}\line

\par The transformer \i EACHLEFT\plain\fs20\cf1\cb1  forms an operation which applies \i f\plain\fs20\cf1\cb1  to pairs formed by pairing the items of \i A\plain\fs20\cf1\cb1  with \i B\plain\fs20\cf1\cb1 .  The shape of the result is the shape of \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      2 3 4 EACHLEFT reshape 5 \line
+---+-----+-------+ \line
|5 5|5 5 5|5 5 5 5| \line
+---+-----+-------+ \line
 \line
     (2 3 reshape 'abcdef') EACHLEFT hitch '123' \line
+----+----+----+ \line
|a123|b123|c123| \line
+----+----+----+ \line
|d123|e123|f123| \line
+----+----+----+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      EACHLEFT IS TRANSFORMER f OPERATION A B \{\- EACH (B CONVERSE f) A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape ( A EACHLEFT f B ) = shape A \line
   I in grid A ==> I pick (A EACHLEFT f B) = f (I pick A) B \line
   A EACHLEFT f B = A EACHBOTH f single B \line
   single A EACHLEFT f B = single (A f B) \line
   solitary A EACHLEFT f B = solitary (A f B) \line
   list A EACHLEFT B = list (A EACHLEFT f B) \line
   isshape S ==> (S reshape A) EACHLEFT f B = S reshape (A EACHLEFT f B) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:005b}
{\up $}{\footnote\pard\plain{\up $} eachright}
{\up #}{\footnote\pard\plain{\up #} X9UDS7}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 eachright\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} distributive transformer, eachright;eachright}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul distributive transformer\plain\fs20\cf1\cb1 {\v distributive transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A EACHRIGHT f B   EACHRIGHT f A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 each\plain\fs20\cf1\cb1 {\v QCZZL2}, \uldb eachleft\plain\fs20\cf1\cb1 {\v BIN189}, \uldb eachall\plain\fs20\cf1\cb1 {\v LYL6P6}, \uldb eachboth\plain\fs20\cf1\cb1 {\v 1R110IM}\line

\par The transformer \i EACHRIGHT\plain\fs20\cf1\cb1  forms an operation which applies \i f\plain\fs20\cf1\cb1  to pairs formed by pairing \i A\plain\fs20\cf1\cb1  with the items of \i B\plain\fs20\cf1\cb1 .  The shape of the result is the shape of \i B\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      2 EACHRIGHT reshape 3 4 5 \line
+---+---+---+ \line
|3 3|4 4|5 5| \line
+---+---+---+ \line
 \line
     `X EACHRIGHT hitch (2 3 reshape 'ab' 'cd') \line
+---+---+---+ \line
|Xab|Xcd|Xab| \line
+---+---+---+ \line
|Xcd|Xab|Xcd| \line
+---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      EACHRIGHT IS TRANSFORMER f OPERATION A B \{\- EACH ( A f ) B \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    I in grid B ==> I pick (A EACHRIGHT f B) = f A (I pick B) \line
   shape ( A EACHRIGHT f B ) = shape B \line
   A EACHRIGHT f B = single A EACHBOTH f B \line
   A EACHRIGHT f single B = single (A f B) \line
   A EACHRIGHT f solitary B = solitary (A f B) \line
   A EACHRIGHT f list B = list(A EACHRIGHT fB) \line
   isshape S ==> A EACHRIGHT f (S reshape B) = S reshape (A EACHRIGHT f B) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:005c}
{\up $}{\footnote\pard\plain{\up $} edit}
{\up #}{\footnote\pard\plain{\up #} 40O30Y}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 edit\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} edit;system operation, edit}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 edit Filename    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 host\plain\fs20\cf1\cb1 {\v 25VK_53}, \uldb loaddefs\plain\fs20\cf1\cb1 {\v RIAXFW}\line

\par The operation \i edit\plain\fs20\cf1\cb1  passes control to the standard editor, requesting it to edit the file named by the string or phrase \i Filename\plain\fs20\cf1\cb1 .  The editor used is determined by the environment variable \i EDITOR\plain\fs20\cf1\cb1  or by a default chosen for each version.  When the editing task is completed, the editor returns control to Q'Nial.  The result is the fault \i ?noexpr\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      edit "test.ndf \line
     edit 'data_records'\plain\fs20\cf1\cb1 \line

\par \pard\sb95 If \i edit\plain\fs20\cf1\cb1  is used to edit a file of Nial definitions, the operation \i loaddefs\plain\fs20\cf1\cb1  must be executed on return from the editor to load the definitions.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:005d}
{\up $}{\footnote\pard\plain{\up $} empty}
{\up #}{\footnote\pard\plain{\up #} 7BJDNO}
\pard\keepn\sb95 \b\fs25 empty\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} empty;structure testing operation, empty}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul structure testing operation\plain\fs20\cf1\cb1 {\v structure testing operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 empty A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 null\plain\fs20\cf1\cb1 {\v 40XD_Q}, \uldb in\plain\fs20\cf1\cb1 {\v RJ2SC2}, \uldb simple\plain\fs20\cf1\cb1 {\v 1KHVNG6}, \uldb single\plain\fs20\cf1\cb1 {\v 1KHWEG6}\line

\par The operation \i empty\plain\fs20\cf1\cb1  tests whether or not an array \i A\plain\fs20\cf1\cb1  has any items.  If \i A\plain\fs20\cf1\cb1  has no items, it returns \i true\plain\fs20\cf1\cb1 ; otherwise, \i false\plain\fs20\cf1\cb1 .  The predefined expression \i Null\plain\fs20\cf1\cb1  is empty as is any array with a zero in its shape.  \line

\par Since there are empty arrays with more than one dimension, it is better to test for an empty array by using \i empty\plain\fs20\cf1\cb1  rather than by direct comparison with \i Null\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      empty Null \line
l \line
 \line
     empty (0 3 2 reshape 5) \line
l \line
 \line
     empty solitary 5 \line
o \line
 \line
     empty solitary Null \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The last two examples show that a solitary is not empty even if the item it contains is empty.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      empty IS OPERATION A \{\- tally A = 0 \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    empty A = 0 in shape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:005e}
{\up $}{\footnote\pard\plain{\up $} equal}
{\up #}{\footnote\pard\plain{\up #} TKZHRR}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 equal\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} equal;logic operation, equal}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul logic operation\plain\fs20\cf1\cb1 {\v logic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A equal B   A = B   equal A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 unequal\plain\fs20\cf1\cb1 {\v LT7UC9}, \uldb match\plain\fs20\cf1\cb1 {\v TSJGTN}, \uldb mate\plain\fs20\cf1\cb1 {\v 25VOZ5O}, \uldb gte\plain\fs20\cf1\cb1 {\v 1ZNBW4K}, \uldb lte\plain\fs20\cf1\cb1 {\v 1ZNC14K}\line

\par The operation \i equal\plain\fs20\cf1\cb1  is normally used to compare two arrays \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  to see whether or not they are identical.  It returns \i true\plain\fs20\cf1\cb1  if they are equal; \i false\plain\fs20\cf1\cb1  otherwise.  (Two nonempty arrays are identical if they have identical shapes and hold identical items at each location.  Two empty arrays are identical if they have identical shapes.) \i Empty\plain\fs20\cf1\cb1  is extended to arbitrary arrays by returning \i true\plain\fs20\cf1\cb1  if all items of an array are identical.  \line

\par \pard\sb95 The symbol = is a synonym for equal and can be used in both infix and prefix application.  In the \i Equations\plain\fs20\cf1\cb1  sections of the dictionary entries, the symbol = is used to separate two sides of an equation.  To test such an equation, it may be necessary to replace the expression following = with the same expression in parentheses in order to force correct parsing of the equation as a Nial expression.  
\par \pard\keep\sb95 \f1\fs16      2 3 4 = [2,3,4] \line
l \line
     Null = '' \line
l \line
     2 (3 4) = (2 3) 4 \line
o \line
     equal EACH shape tell 2 3 4 \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows that a triple formed using strand notation is identical to that formed using brackets notation.  The second shows that \i Null\plain\fs20\cf1\cb1  is equal to the empty string.  The third shows that grouping items of a list in different ways creates different arrays.  The last shows the convenience of the more general form of \i equal\plain\fs20\cf1\cb1 .  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A equal B <==> shape A = shape B \line
   A equal B and (I in grid A) ==> I pick A = I pick B \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:005f}
{\up $}{\footnote\pard\plain{\up $} equations}
{\up #}{\footnote\pard\plain{\up #} 6TVNM7}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 equations\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, equations;equations}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}\line

\par \pard\sb95 The equations in the Nial Dictionary and in the on-line help provide an abbreviated way of stating properties of the term or object being described.  They could be expanded into an explanation in English but that would lengthen the manual considerably.  \line

\par The equations use variables such as \i A\plain\fs20\cf1\cb1 , \i B\plain\fs20\cf1\cb1  and \i C\plain\fs20\cf1\cb1  that take on array values; and variables such as \i f\plain\fs20\cf1\cb1 , \i g\plain\fs20\cf1\cb1  and \i h\plain\fs20\cf1\cb1  that denote operations that map arrays to arrays.  An equation holds for all arrays and for all computable operations without side effects, unless a specific qualification is made.  Thus, the equation: 
\par \pard\keep\sb95 \f1\fs16    (EACH f) (EACH g) A = EACH (f g) A \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 says that for all operations \i f\plain\fs20\cf1\cb1  and \i g\plain\fs20\cf1\cb1  and all arrays \i A\plain\fs20\cf1\cb1 , the use of the \i EACH\plain\fs20\cf1\cb1  transform of \i f\plain\fs20\cf1\cb1  on the result of the use of the \i EACH\plain\fs20\cf1\cb1  transform of \i g\plain\fs20\cf1\cb1  on \i A\plain\fs20\cf1\cb1  has the same value as the use of the \i EACH\plain\fs20\cf1\cb1  transform of the composition of \i f\plain\fs20\cf1\cb1  and \i g\plain\fs20\cf1\cb1  on \i A\plain\fs20\cf1\cb1 .  In mathematical terms, the \i EACH\plain\fs20\cf1\cb1  transformer distributes over operation composition.  \line

\par The symbol \i =\plain\fs20\cf1\cb1  is used in its mathematical sense in equations and separates two Nial expressions.  The symbol \i =\plain\fs20\cf1\cb1  has higher precedence than the two expressions it is separating.  Where the Nial equivalent to \i =\plain\fs20\cf1\cb1  is needed to state the equation, the term \i equal\plain\fs20\cf1\cb1  is used.  \line

\par \pard\sb95 To test an equation using Q'Nial, in order to force the correct parsing of the equation as a Nial expression, it may be necessary to replace 
\par \pard\keep\sb95 \f1\fs16                Expr1 = Expr2\plain\fs20\cf1\cb1 \line

\par \pard\sb95 with 
\par \pard\keep\sb95 \f1\fs16                Expr1 = ( Expr2 )\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The equality used in equations assumes that both sides of the equations compute without triggering a fault and produce equal arrays; or both produce the same fault value if fault triggering is off.  In some cases, the equality is inexact due to roundoff errors.  \line

\par The symbol \i =f=\plain\fs20\cf1\cb1  is used to denote an equality where both sides produce the same non-fault value; but in some cases one or both of the sides may fault and the equality is no longer valid.  \line

\par Some of the equations are qualified by a constraint on the variables.  The constraint is written in English or as a conditional expression in Nial that must hold for the equation to be true.  In a statement of the form 
\par \pard\keep\sb95 \f1\fs16                Expr ==> Eqn\plain\fs20\cf1\cb1 \line

\par \pard\sb95 Expr is the qualification written as a Nial boolean expression, the symbol ==> is used for "implies", and Eqn is the equation that holds under the qualification.  \line

\par The symbol <==> denotes an if and only if implication.  Thus a statement of the form 
\par \pard\keep\sb95 \f1\fs16               Expr1 <==> Expr2\plain\fs20\cf1\cb1 \line

\par \pard\sb95 states that both expressions have the same truth value; either both are true or both are false.  \line

\par \b Reading the Equations \plain\fs20\cf1\cb1 \line

\par The equations related to \i abs\plain\fs20\cf1\cb1 , the operation that finds the absolute value of a number, are: 
\par \pard\keep\sb95 \f1\fs16    abs A = EACH abs A \line
   shape abs A = shape A \line
   abs abs A = abs A \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first two come from the property that \i abs\plain\fs20\cf1\cb1  is \i unary pervasive\plain\fs20\cf1\cb1 .  The first one says that applying \i abs\plain\fs20\cf1\cb1  to an array \i A\plain\fs20\cf1\cb1  is the same as applying \i abs\plain\fs20\cf1\cb1  to the items of array \i A\plain\fs20\cf1\cb1 .  It also implies that the shape of the result of \i abs A\plain\fs20\cf1\cb1  is the same as shape of \i A\plain\fs20\cf1\cb1  since \i EACH\plain\fs20\cf1\cb1  transforms always preserve shape.  The second equation says that the shape of the result of \i abs A\plain\fs20\cf1\cb1  is the same as the shape of \i A\plain\fs20\cf1\cb1 .  The third equation indicates that subsequent applications of \i abs\plain\fs20\cf1\cb1  after the first do not change the result.  \line

\par \pard\sb95 The equations related to \i minus\plain\fs20\cf1\cb1 , denoted by \i -\plain\fs20\cf1\cb1 , are: 
\par \pard\keep\sb95 \f1\fs16    A - B = EACH - pack A B \line
   shape (A - B) = shape pack A B \line
   A - B = A + opposite B \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first equation says that pair of arrays \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  are packed at each level of nesting to bring corresponding items together.  Then, the items are subtracted.  \line

\par The second equation states that the shape of the result of subtracting \i A\plain\fs20\cf1\cb1  from \i B\plain\fs20\cf1\cb1  is the shape formed by packing \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1 .  The third equation states that subtracting \i A\plain\fs20\cf1\cb1  from \i B\plain\fs20\cf1\cb1  is equivalent to adding the opposite of \i B\plain\fs20\cf1\cb1  to \i A\plain\fs20\cf1\cb1 .  \line

\par The equations related to \i hitch\plain\fs20\cf1\cb1  are as follows: 
\par \pard\keep\sb95 \f1\fs16    A hitch B = A hitch list B \line
   list (A hitch B) = A hitch B \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first says that \i hitch\plain\fs20\cf1\cb1  treats its right argument as though it were a list, and the second states that the result of \i hitch\plain\fs20\cf1\cb1  is a list.  \line

\par The following equations illustrate the use of qualifications: 
\par \pard\keep\sb95 \f1\fs16    atomic A ==> single A = A \line
   not empty A ==> mix rows A = A \line
   diverse A <==> cull A = list A \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first equation says that if \i A\plain\fs20\cf1\cb1  is atomic, the single of \i A\plain\fs20\cf1\cb1  is equal to \i A\plain\fs20\cf1\cb1 .  That is, the single of an atom is the atom.  The second equation says that if \i A\plain\fs20\cf1\cb1  is not empty, forming the rows of \i A\plain\fs20\cf1\cb1  and applying \i mix\plain\fs20\cf1\cb1  to recombine them, results in the original array.  The third equation says that if \i A\plain\fs20\cf1\cb1  is diverse, the cull of \i A\plain\fs20\cf1\cb1  is equal to the list of \i A\plain\fs20\cf1\cb1 ; and that if \i A\plain\fs20\cf1\cb1  is not diverse, the cull of \i A\plain\fs20\cf1\cb1  is not equal to the list of \i A\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 There are many identities that hold for all arrays in Nial.  The equations are shown in the on-line help for each topic.  Three general equations are the following: \line

\par A unary pervasive operation f satisfies the equation: 
\par \pard\keep\sb95 \f1\fs16    f A = EACH f A \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 A binary pervasive operation f satisfies the equation: 
\par \pard\keep\sb95 \f1\fs16    A f B = A EACHBOTH f B \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 A multi pervasive operation f satisfies the equations: 
\par \pard\keep\sb95 \f1\fs16    f A = EACHALL f A \line
   f A = REDUCE f A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0060}
{\up $}{\footnote\pard\plain{\up $} erase}
{\up #}{\footnote\pard\plain{\up #} 2V.T3TP}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 erase\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} erase;system operation, erase}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 erase Nm    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 symbols\plain\fs20\cf1\cb1 {\v 1KUXMUU}\line

\par The operation \i erase\plain\fs20\cf1\cb1  is used to remove unwanted global definitions and variables from the workspace.  The argument \i Nm\plain\fs20\cf1\cb1  must be a phrase or string giving the object to be removed.  Predefined names and names in local scopes cannot be removed.  \line

\par When a name has been erased, it remains in the symbol table with its original role.  It can be redefined in the same role or, if a variable, reassigned a value by a subsequent action.  A name cannot change its role once established.  
\par \pard\keep\sb95 \f1\fs16      average IS divide[sum,tally]; \line
     calc IS EACH average; \line
     Var3 := calc (2 3 4) (5 6 7) \line
3. 6. \line
 \line
     EACH erase "average 'Var3' "sum \line
?noexpr ?noexpr ?system name\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the example above, the operation \i sum\plain\fs20\cf1\cb1  cannot be erased as it is a predefined operation.  In the next three examples below, faults are returned because of missing variables or operations that were erased.  The effect of erasing an object is not propagated to other definitions referring to the erased name.  
\par \pard\keep\sb95 \f1\fs16      Var3 \line
?no_value \line
 \line
     average count 10 \line
?missing_op \line
 \line
     calc (2 3 4) (5 6 7) \line
?missing_op ?missing_op \line
 \line
     average := 5 6 7 \line
?invalid assignment: AVERAGE :=  <***> 5 6\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the last example, an attempt is made to redefine the role of \i average\plain\fs20\cf1\cb1  and Q'Nial indicated that \i average\plain\fs20\cf1\cb1  is not a suitable name for such an assignment.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0061}
{\up $}{\footnote\pard\plain{\up $} eraserecord}
{\up #}{\footnote\pard\plain{\up #} LE6Z0M}
\pard\keepn\sb95 \b\fs25 eraserecord\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} eraserecord;nial direct access file operation, eraserecord}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nial direct access file operation\plain\fs20\cf1\cb1 {\v nial direct access file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 eraserecord Filenum N    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 readrecord\plain\fs20\cf1\cb1 {\v 6J72_OO}, \uldb writerecord\plain\fs20\cf1\cb1 {\v V4AFRH}, \uldb readarray\plain\fs20\cf1\cb1 {\v 7HVXYZ}, \uldb writearray\plain\fs20\cf1\cb1 {\v 18CILAO}, \uldb open\plain\fs20\cf1\cb1 {\v 25VR_QX}, \uldb close\plain\fs20\cf1\cb1 {\v TIUC9K}, \uldb filetally\plain\fs20\cf1\cb1 {\v 1E5.ZTN}\line

\par The operation \i eraserecord\plain\fs20\cf1\cb1  is used to erase component \i N\plain\fs20\cf1\cb1  of direct access file designated by the number \i Filenum\plain\fs20\cf1\cb1 .  In a file with record components, \i eraserecord\plain\fs20\cf1\cb1  replaces the erased component with an empty string.  In a file with array components, it replaces the erased component with the fault \i ?missing\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 \i N\plain\fs20\cf1\cb1  may be a single record number or a list of record numbers.  \line

\par If the last component in a file is erased, any immediately preceding components that are empty in a record component file or contain the fault \i ?missing\plain\fs20\cf1\cb1  in an array component file are also removed.  The file tally, which records the number of records in the file, is adjusted accordingly.  \line

\par The operation returns the fault \i ?noexpr\plain\fs20\cf1\cb1  or a fault indicating improper use of the operation.  
\par \pard\keep\sb95 \f1\fs16      File_num := open "Names "d ; \line
     eraserecord File_num 23 ;\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0062}
{\up $}{\footnote\pard\plain{\up $} eval}
{\up #}{\footnote\pard\plain{\up #} 40OE2Q}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 eval\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} eval;evaluation operation, eval}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 eval Pt    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 execute\plain\fs20\cf1\cb1 {\v 3WULI4D}, \uldb scan\plain\fs20\cf1\cb1 {\v 1CMJ16H}, \uldb parse\plain\fs20\cf1\cb1 {\v TVJF9K}, \uldb value\plain\fs20\cf1\cb1 {\v 5JGH_30}\line

\par The operation \i eval\plain\fs20\cf1\cb1  provides access to the underlying expression evaluator of Q'Nial.  The argument to \i eval\plain\fs20\cf1\cb1  must be a parse tree returned by \i parse\plain\fs20\cf1\cb1  or \i getdef\plain\fs20\cf1\cb1 , a named expression or a cast which represents a Nial expression.  The effect is to evaluate the expression and return the resulting value.  As seen below, the parse tree can be one formed by using the cast mechanism or one built explicitly using \i parse\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      eval parse scan '23 + 45' \line
68 \line
 \line
     eval !(23 + 45) \line
68\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The next example shows that \i eval\plain\fs20\cf1\cb1  can be used to evaluate a named expression using either the cast or the phrase of its name.  
\par \pard\keep\sb95 \f1\fs16      A := 100 ; \line
     Addone IS (A := A + 1); \line
     (eval !Addone)(eval "Addone) \line
101 102 \line
 \line
     (eval !A)(eval "A)(value "A) \line
102 ?not an expression 102\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The last example shows that \i eval\plain\fs20\cf1\cb1  can be used to evaluate the cast of a variable but not a phrase naming the variable.  The operation \i value\plain\fs20\cf1\cb1  should be used instead.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    S a string holding a Nial expression ==> eval parse scan S = execute S \line
   Pt a parse tree ==> eval parse deparse Pt = eval P \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0063}
{\up $}{\footnote\pard\plain{\up $} except}
{\up #}{\footnote\pard\plain{\up #} 1_WLCKE}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 except\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} except;selection operation, except}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A except B   except A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 cull\plain\fs20\cf1\cb1 {\v 40MD_Q}, \uldb sublist\plain\fs20\cf1\cb1 {\v 88JHY6}, \uldb notin\plain\fs20\cf1\cb1 {\v 7KLHCD}\line

\par The operation \i except\plain\fs20\cf1\cb1  returns the list of items of \i A\plain\fs20\cf1\cb1  that are not in \i B\plain\fs20\cf1\cb1 .  It corresponds to set difference if \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  are viewed as set representations.  The result is a list with items in the same order as in \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      count 10 except 3 5 7 \line
1 2 4 6 8 9 10 \line
 \line
     'a list of words' except 'aeiou' \line
 lst f wrds \line
 \line
     tell 2 3 except [0 0] \line
+---+---+---+---+---+ \line
|0 1|0 2|1 0|1 1|1 2| \line
+---+---+---+---+---+ \line
 \line
     tell 2 3 except (0 0) \line
+---+---+---+---+---+---+ \line
|0 0|0 1|0 2|1 0|1 1|1 2| \line
+---+---+---+---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The last two examples show that if the left argument has nonatomic items, to remove a single non-atomic array, the right argument must be made into a solitary list.  Otherwise the items of the right argument are used.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      except IS OPERATION A B \{\- A EACHLEFT notin B sublist A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    list (A except B) = A except B \line
   list A except list B = A except B \line
   (A except B) except C = A except (B link C) \line
   A except cull B = A except B \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Pragmatics\plain\fs20\cf1\cb1 \line

\par The operation \i except\plain\fs20\cf1\cb1  uses an internal sort on its arguments to reduce the algorithmic complexity of the above definition.  It executes considerably faster if its arguments have already been sorted.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0064}
{\up $}{\footnote\pard\plain{\up $} execute}
{\up #}{\footnote\pard\plain{\up #} 3WULI4D}
\pard\keepn\sb95 \b\fs25 execute\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} evaluation operation, execute;execute}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 execute S    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 eval\plain\fs20\cf1\cb1 {\v 40OE2Q}, \uldb parse\plain\fs20\cf1\cb1 {\v TVJF9K}, \uldb scan\plain\fs20\cf1\cb1 {\v 1CMJ16H}, \uldb tonumber\plain\fs20\cf1\cb1 {\v 1_RG0DJ}, \uldb apply\plain\fs20\cf1\cb1 {\v TGYD34}, \uldb value\plain\fs20\cf1\cb1 {\v 5JGH_30}\line

\par The operation \i execute\plain\fs20\cf1\cb1  evaluates a Nial expression given as a string \i S\plain\fs20\cf1\cb1 .  The result of the evaluation is returned.  The execution of the string takes place in the environment where execute is applied.  \line

\par If the string contains a name, the local meaning of that name will be used if a local meaning exists.  If execution of the string results in the creation of a new variable or defined name, the new object is placed in the global environment.  \line

\par \pard\sb95 If a string being executed contains an integer representation that would be converted to an integer outside the range for the computer, the result is converted to the corresponding real number.  
\par \pard\keep\sb95 \f1\fs16      execute '23 + 40045' \line
40068. \line
 \line
     A := count 5; opname := 'product'; \line
     execute link opname ' A' \line
120\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The last example shows that Nial program text can be constructed under program control and then executed.  This feature is useful in applications where responses are generated by combining text elements based on the user input and the current state of the computation.  The technique is useful for applications involving computer assisted instruction and knowledge based systems.  \line

\par It is more efficient to use \i eval\plain\fs20\cf1\cb1  to evaluate the cast of an expression than to use \i execute\plain\fs20\cf1\cb1  to evaluate the corresponding string.  In the former approach the \i scan\plain\fs20\cf1\cb1  and \i parse\plain\fs20\cf1\cb1  is done once, whereas in the latter it is repeated on each execution.  \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      execute IS OPERATION A \{\- eval parse scan A \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    execute readscreen Prompt = read Prompt \line
   Txt, a Nial expression ==> eval !(Txt) = execute 'Txt' \line
   S a string holding a Nial expression ==> execute canonical S = execute S \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 where \i canonical IS link descan deparse parse scan.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0065}
{\up $}{\footnote\pard\plain{\up $} exp}
{\up #}{\footnote\pard\plain{\up #} 1_E6ULF}
\pard\keepn\sb95 \plain\b\fs25\cf1\cb1 exp\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} exp;scientific operation, exp}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 exp A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 ln\plain\fs20\cf1\cb1 {\v RJ2SF2}, \uldb power\plain\fs20\cf1\cb1 {\v TVXJVX}, \uldb log\plain\fs20\cf1\cb1 {\v 1_E71C_}\line

\par The operation \i exp\plain\fs20\cf1\cb1  implements the exponential function of mathematics.  It produces the following results when applied to atoms of the six types: 
\par 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 exponential of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 exponential of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 exponential of A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?exp \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?exp \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      exp  o  1  0.5  `a  "abc  ??error \line
1. 2.71828 1.64872 ?exp ?exp ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    exp ln A = A   (within roundoff error) \line
   exp A = exp 1.0 power A   (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0066}
{\up $}{\footnote\pard\plain{\up $} expression}
{\up #}{\footnote\pard\plain{\up #} FD5QFK}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 expression\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, expression;expression}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 operation\plain\fs20\cf1\cb1 {\v CQFG7.}, \uldb transformer\plain\fs20\cf1\cb1 {\v 1VQL398}\line

\par The term \b expression\plain\fs20\cf1\cb1  is used in its most general sense to describe a program fragment that denotes one of the three primary objects of Nial: an \i array\plain\fs20\cf1\cb1 , an \i operation\plain\fs20\cf1\cb1 , or a \i transformer\plain\fs20\cf1\cb1 . However, in most contexts we use the term as an abbreviation of an \i array expression\plain\fs20\cf1\cb1 .\line

\par An array expression denotes an array value. That is, it is a program fragment that when evaluated in the proper context will produce an array. The predefined expressions of Q'Nial either produce a constant value, or they carry out some system action and return the fault value \i ?noexpr\plain\fs20\cf1\cb1 . \line

\par \pard\sb95 The control constructs of Nial are array expressions made up of keywords, simple-expressions and expression-sequences.\line

\par A named expression is either a predefined expression or an expression that has been given an explicit name using the \i IS\plain\fs20\cf1\cb1  definition mechanism.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0067}
{\up $}{\footnote\pard\plain{\up $} expression sequence}
{\up #}{\footnote\pard\plain{\up #} R9CDMG}
\pard\keepn\sb95 \b\fs25 expression sequence\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} expression sequence;syntax, expression sequence}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 expression\plain\fs20\cf1\cb1 {\v FD5QFK}\line

\par An \b expression-sequence\plain\fs20\cf1\cb1  is the main construct used for program text that produces a value. It consists of one or more expressions separated by semi-colons and possible followed by a semi-colon.
\par \pard\keep\sb95 \f1\fs16      expression-sequence ::= expression \line
        \{\- ; expression \'7d [ ; ]\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The expressions in an expression-sequence are evaluated in left-to-right order.  If the sequence does not terminate with a semicolon, the array returned is the result of the last expression.  If the sequence does end with a semicolon, the array returned is the fault \i ?noexpr\plain\fs20\cf1\cb1 .  At the top level loop, if the array returned is the fault \i ?noexpr\plain\fs20\cf1\cb1 , it is not displayed.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0068}
{\up $}{\footnote\pard\plain{\up $} exprs}
{\up #}{\footnote\pard\plain{\up #} 7BUDLI}
\pard\keepn\sb95 \b\fs25 exprs\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} exprs;system expression, exprs}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Exprs    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 symbols\plain\fs20\cf1\cb1 {\v 1KUXMUU}\line

\par The expression \i Exprs\plain\fs20\cf1\cb1  returns a list of phrases giving the names of all user defined expressions in the workspace.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      Exprs IS \{\-  \line
        Names Roles := pack symbols 0;  \line
        "expr match Roles sublist Names \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0069}
{\up $}{\footnote\pard\plain{\up $} extent}
{\up #}{\footnote\pard\plain{\up #} KNQD25}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 extent\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, extent;extent}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 shape\plain\fs20\cf1\cb1 {\v TYQ56K}\line

\par The term \b extent\plain\fs20\cf1\cb1  is used to describe the length of an axis of an array in a particular dimension.  Thus a 4 by 6 table is said to have extent 4 in the first dimension and extent 6 in the second dimension.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:006a}
{\up $}{\footnote\pard\plain{\up $} external declaration}
{\up #}{\footnote\pard\plain{\up #} .O7OJC}
\pard\keepn\sb95 \b\fs25 external declaration\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} external declaration;syntax, external declaration}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 action\plain\fs20\cf1\cb1 {\v G9QH2Z}, \uldb role\plain\fs20\cf1\cb1 {\v QD__TZ}
\par \pard\keep\sb95 \f1\fs16      external-declaration ::= identifier IS \line
        EXTERNAL ( EXPRESSION \line
                         | OPERATION \line
                         | TRANSFORMER \line
                         | VARIABLE )\plain\fs20\cf1\cb1 \line

\par \pard\sb95 An external declaration assigns a role to a name, allowing it to be used in a definition before its own definition is given.  This mechanism is useful for creating mutually recursive definitions.  An external declaration is made only in the global environment.  \line

\par If the name is already defined with the same role, the declaration has no effect.  If the name has another role, a fault is reported.  If the name is not currently defined, a default object is associated with it.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:006b}
{\up $}{\footnote\pard\plain{\up $} false}
{\up #}{\footnote\pard\plain{\up #} 4WY._DU}
\pard\keepn\sb95 \b\fs25 false\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} constant expression, false;false}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul constant expression\plain\fs20\cf1\cb1 {\v constant expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 False    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 true\plain\fs20\cf1\cb1 {\v 5FZ__UI}, \uldb isboolean\plain\fs20\cf1\cb1 {\v 1VYX20O}\line

\par The constant expression \i False\plain\fs20\cf1\cb1  denotes the boolean atom for \i false\plain\fs20\cf1\cb1 , which Nial also denotes by \i o\plain\fs20\cf1\cb1 .  It is the result of comparing two arrays that are not identical for equality.  
\par \pard\keep\sb95 \f1\fs16      False (not False) \line
ol\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    tally False = 1 \line
   shape False = Null \line
   single False = False \line
   not False = True \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:006c}
{\up $}{\footnote\pard\plain{\up $} fault}
{\up #}{\footnote\pard\plain{\up #} TLJI2Z}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 fault\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} conversion operation, fault;fault}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 fault S    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 isfault\plain\fs20\cf1\cb1 {\v 1MY4M1D}, \uldb phrase\plain\fs20\cf1\cb1 {\v 4.B5_UK}, \uldb quiet_fault\plain\fs20\cf1\cb1 {\v 1EEKEB1}, \uldb settrigger\plain\fs20\cf1\cb1 {\v 16TEBGX}, \uldb string\plain\fs20\cf1\cb1 {\v .ACHEC}\line

\par The operation \i fault\plain\fs20\cf1\cb1  converts a string or phrase into the fault value with the string as its message.  If the argument is not a string, phrase or a fault, the result is the fault \i ?type error\plain\fs20\cf1\cb1 .  \line

\par \i Fault\plain\fs20\cf1\cb1  is used to construct faults that contain blanks or other characters than cannot appear in a literal fault or ones constructed from a message provided from the host system.  \line

\par \pard\sb95 By default, fault triggering is on when the interpreter is initialized. This causes the creation of a fault to interrupt the flow of execution. The operation \i quiet_fault\plain\fs20\cf1\cb1  can be used to create a fault value without triggering an interrupt.
\par \pard\keep\sb95 \f1\fs16      settrigger o; \line
     fault '?missing data' \line
?missing data \line
 \line
     fault "Notastring \line
Notastring \line
 \line
     fault 3.4 \line
?type error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The convention is that all faults generated by Q'Nial internally begin with the character \i ?\plain\fs20\cf1\cb1 .  The second example shows that this is not a requirement.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    isfault F ==> fault string F = F \line
   isstring S ==> string fault S = S \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:006d}
{\up $}{\footnote\pard\plain{\up $} fault triggering}
{\up #}{\footnote\pard\plain{\up #} 2JAK0C0}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 fault triggering\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, fault triggering;fault triggering}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 fault values\plain\fs20\cf1\cb1 {\v 2D_C0L1}, \uldb settrigger\plain\fs20\cf1\cb1 {\v 16TEBGX}, \uldb quiet_fault\plain\fs20\cf1\cb1 {\v 1EEKEB1}\line

\par Nial assumes that every computation that terminates results in an array value. However, there are many cases where a computation does not have a sensible answer. If division by zero occurs, for example, there is no suitable number to return.  Nial uses special atomic arrays called faults to indicate such results. For division by zero it is ?div. \line

\par Q'Nial has two ways of handling a fault: either a trigger mechanism is executed that causes an interruption when a fault is created, or during execution of a defined operation, expression or transformer the fault is treated as a normal atomic array. \line

\par \pard\sb95 When Q'Nial is invoked, the fault triggering mechanism is turned on by default. (This effect can be suppressed by using an option in the setup for each version). During execution, the state of the triggering mechanism can be turned on or off using the operation \i settrigger\plain\fs20\cf1\cb1 . The operation \i quiet_fault\plain\fs20\cf1\cb1  can be used to create a fault without causing fault triggering.\line

\par If fault triggering is set and a fault is generated during execution of a defined operation, execution is interrupted. On an interruption caused by a fault, a display message appears giving the call stack of definitions currently executing and the line of text that caused the fault. For example, the definition:
\par \pard\keep\sb95 \f1\fs16      foo is op A B \{\- A / B + 1 \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 followed by the evaluation of the expression
\par \pard\keep\sb95 \f1\fs16      foo 3 0\plain\fs20\cf1\cb1 \line

\par \pard\sb95 results in the output:
\par \pard\keep\sb95 \f1\fs16 ------------------------------------------------------------- \line
    Fault interruption loop:  enter expressions or  \line
      type: <Return>   to jump to top level \line
    current call stack : \line
foo \line
      ?div triggered in : ... A / B  \line
------------------------------------------------------------- \line
>>> \plain\fs20\cf1\cb1 \line

\par \pard\sb95 where the string '>>>' is a special prompt indicating that a fault has occurred and execution has been interrupted. The prompt permits you to query the value of variables in the expression and its surrounding computation or to view the operation that has triggered the fault. The above session might continue as:
\par \pard\keep\sb95 \f1\fs16 >>> see "foo \line
foo IS OPERATION A B \{\-  \line
    A / B + 1 \'7d  \line
>>> A \line
3 \line
>>> B \line
0 \line
>>> \plain\fs20\cf1\cb1 \line

\par \pard\sb95 A variable in a definition that called the current one can be referenced by preceding the variables name by the definition name and a colon, e.g. \i G:X\plain\fs20\cf1\cb1  denotes variable \i X\plain\fs20\cf1\cb1  in definition \i G\plain\fs20\cf1\cb1 . You can execute any expressions you want at the prompt. A useful thing to do is to see the definition that has interrupted. When you are ready to resume, reply to the prompt with a Return and control returns to the interactive loop.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:006e}
{\up $}{\footnote\pard\plain{\up $} fault values}
{\up #}{\footnote\pard\plain{\up #} 2D_C0L1}
\pard\keepn\sb95 \b\fs25 fault values\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, fault values;fault values}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}\line

\par \pard\sb95 The Role of Faults \line

\par A \b fault\plain\fs20\cf1\cb1  is a special kind of atomic value used by Q'Nial to signal special values or to indicate that an operation has been given an argument it cannot handle in a normal way.  The special value faults are: 
\par  \trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 \b Fault \cell\pard \pard\intbl\sb95 Meaning \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 ?noexpr \cell\pard \pard\intbl\sb95 indicates that no answer is expected \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 ?eof \cell\pard \pard\intbl\sb95 end of file indication \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 ?I \cell\pard \pard\intbl\sb95 Zenith which is greater than all atoms \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 ?O \cell\pard \pard\intbl\sb95 Nadir which is less than all atoms \cell\intbl\row
\pard \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:006f}
{\up $}{\footnote\pard\plain{\up $} filelength}
{\up #}{\footnote\pard\plain{\up #} 34SOEI}
\pard\keepn\sb95 \b\fs25 filelength\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} filelength;host direct access file operation, filelength}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul host direct access file operation\plain\fs20\cf1\cb1 {\v host direct access file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 filelength Filename    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 readfield\plain\fs20\cf1\cb1 {\v 7MML9E}, \uldb writefield\plain\fs20\cf1\cb1 {\v 3WBE_SO}\line

\par The operation \i filelength\plain\fs20\cf1\cb1  returns the length in bytes of the host file named by string or phrase \i Filename\plain\fs20\cf1\cb1 .  It is used in conjunction with \i readfield\plain\fs20\cf1\cb1  and \i writefield\plain\fs20\cf1\cb1  in processing host files.  
\par \pard\keep\sb95 \f1\fs16      Len := filelength "Myfile; \line
     Data := readfield "Myfile 0 Len;\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the example, \i filelength\plain\fs20\cf1\cb1  is used to determine the size of the file and \i readfield\plain\fs20\cf1\cb1  is used to read it in as raw byte data. If the file corresponds to a text file, the data will include end of line indications appropriate for the host system.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0070}
{\up $}{\footnote\pard\plain{\up $} filepath}
{\up #}{\footnote\pard\plain{\up #} 5IP8L}
\pard\keepn\sb95 \b\fs25 filepath\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} file operation, filepath;filepath}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul file operation\plain\fs20\cf1\cb1 {\v file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 filepath Nms    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 separator\plain\fs20\cf1\cb1 {\v 35WS3GL}\line

\par The operation \i filepath\plain\fs20\cf1\cb1  converts a list of phrases or strings giving the names of directories and a filename into the system dependent string that access the specific file.  This operation is useful in writing system independent programs that will work with either UNIX or DOS (and WINDOWS) path name conventions.  \line

\par \b Example:\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16         filepath ".. "aitools "newfnfl "frames\plain\fs20\cf1\cb1 \line

\par \pard\sb95 returns the string 
\par \pard\keep\sb95 \f1\fs16 ../aitools/newnfl/frames \plain\fs20\cf1\cb1 \line

\par \pard\sb95 on a UNIX version of Q'Nial, and returns 
\par \pard\keep\sb95 \f1\fs16 ..\'5caitools\'5cnewnfl\'5cframes \plain\fs20\cf1\cb1 \line

\par \pard\sb95 on a PCDOS version.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      filepath is op Nms \{\- \line
       front link (EACH string Nms EACHLEFT append Separator ) \'7d\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0071}
{\up $}{\footnote\pard\plain{\up $} filestatus}
{\up #}{\footnote\pard\plain{\up #} 0CG1FT}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 filestatus\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} file expression, filestatus;filestatus}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul file expression\plain\fs20\cf1\cb1 {\v file expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Filestatus    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 status\plain\fs20\cf1\cb1 {\v .A2SLO}, \uldb open\plain\fs20\cf1\cb1 {\v 25VR_QX}, \uldb close\plain\fs20\cf1\cb1 {\v TIUC9K}, \uldb filetally\plain\fs20\cf1\cb1 {\v 1E5.ZTN}\line

\par The expression \i Filestatus\plain\fs20\cf1\cb1  gives information on the files currently open in a Q'Nial session.  It returns a list of triples, one for each open file, giving the file number as an integer, the filename as a phrase and the mode as a character.  \line

\par The modes are \i r\plain\fs20\cf1\cb1 , \i w\plain\fs20\cf1\cb1 , \i a\plain\fs20\cf1\cb1 , \i d\plain\fs20\cf1\cb1 , \i pr\plain\fs20\cf1\cb1 , \i pw\plain\fs20\cf1\cb1  and \i c\plain\fs20\cf1\cb1 , standing for \i read\plain\fs20\cf1\cb1 , \i write\plain\fs20\cf1\cb1 , \i append\plain\fs20\cf1\cb1 , \i direct\plain\fs20\cf1\cb1 , \i pipe_read\plain\fs20\cf1\cb1 , \i pipe_write\plain\fs20\cf1\cb1  and \i communications\plain\fs20\cf1\cb1  respectively.  \line

\par \pard\sb95 The files for standard input, standard output and standard error are opened with modes of r, w and w respectively using file numbers 0, 1 and 2.  
\par \pard\keep\sb95 \f1\fs16      Fnum := open "F "a; \line
     Filestatus \line
+---------+----------+----------+-----+ \line
|0 stdin r|1 stdout w|2 stderr w|3 F a| \line
+---------+----------+----------+-----+\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0072}
{\up $}{\footnote\pard\plain{\up $} filetally}
{\up #}{\footnote\pard\plain{\up #} 1E5.ZTN}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 filetally\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} filetally;nial direct access file operation, filetally}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nial direct access file operation\plain\fs20\cf1\cb1 {\v nial direct access file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 filetally Filenum    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 open\plain\fs20\cf1\cb1 {\v 25VR_QX}, \uldb readarray\plain\fs20\cf1\cb1 {\v 7HVXYZ}, \uldb writearray\plain\fs20\cf1\cb1 {\v 18CILAO}, \uldb filelength\plain\fs20\cf1\cb1 {\v 34SOEI}\line

\par The operation \i filetally\plain\fs20\cf1\cb1  returns the number of records in the file designated by \i Filenum\plain\fs20\cf1\cb1 , an integer returned by an earlier call to \i open\plain\fs20\cf1\cb1 .  The filetally is one higher than the highest component number of a record or array that is written but not erased.  
\par \pard\keep\sb95 \f1\fs16      Fn := open "newfile `d; \line
     writearray Fn (9 99) ('The' 'End'); \line
     filetally Fn \line
100\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0073}
{\up $}{\footnote\pard\plain{\up $} filter}
{\up #}{\footnote\pard\plain{\up #} 42BZPGX}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 filter\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} filter;selection transformer, filter}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection transformer\plain\fs20\cf1\cb1 {\v selection transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 FILTER f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 each\plain\fs20\cf1\cb1 {\v QCZZL2}, \uldb sublist\plain\fs20\cf1\cb1 {\v 88JHY6}\line

\par The transformer \i FILTER\plain\fs20\cf1\cb1  is given a predicate operation \i f\plain\fs20\cf1\cb1  that is used to select items from \i A\plain\fs20\cf1\cb1 .  The result of applying \i FILTER f\plain\fs20\cf1\cb1  is to produce a list of the items of \i A\plain\fs20\cf1\cb1  that satisfy the predicate \i f\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      FILTER (0<) (4 -2 3 -5) \line
4 3 \line
 \line
     FILTER (not isphrase) (37 4.5 "cat) \line
37 4.5\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      FILTER IS TRANSFORMER f OPERATION A \{\- EACH f A sublist A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    tally FILTER f A = sum EACH f A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0074}
{\up $}{\footnote\pard\plain{\up $} find}
{\up #}{\footnote\pard\plain{\up #} QD17VY}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 find\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} find;search operation, find}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul search operation\plain\fs20\cf1\cb1 {\v search operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A find B   find A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 findall\plain\fs20\cf1\cb1 {\v 1U9H6P6}, \uldb seek\plain\fs20\cf1\cb1 {\v 1CMJ30E}, \uldb in\plain\fs20\cf1\cb1 {\v RJ2SC2}, \uldb gage\plain\fs20\cf1\cb1 {\v QD1ZOZ}, \uldb sortup\plain\fs20\cf1\cb1 {\v ..CSLL}\line

\par The operation \i find\plain\fs20\cf1\cb1  returns the address of the first occurrence of \i A\plain\fs20\cf1\cb1  as an item of \i B\plain\fs20\cf1\cb1 , searching \i B\plain\fs20\cf1\cb1  in row major order.  If \i A\plain\fs20\cf1\cb1  does not occur in \i B\plain\fs20\cf1\cb1 , the result is the \i gage\plain\fs20\cf1\cb1  of \i shape B\plain\fs20\cf1\cb1 .  The result of \i find\plain\fs20\cf1\cb1  is an integer if \i B\plain\fs20\cf1\cb1  is a list; and a list of integers of tally equal to \i valence B\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      set "diagram ; \line
     3 find 56 34 3 23 3 57 3 \line
2\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The result of find is 2.  
\par \pard\keep\sb95 \f1\fs16      `a find 'hello world' \line
11 \line
 \line
     2 3 find count 3 4 \line
+-+-+ \line
|1|2| \line
+-+-+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the second example, the character a is not in the string 'hello world' and the result is the tally of 'hello world'.  In the last example, the result is a list of two integers because the valence of count 3 4 is 2.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      find IS OPERATION A B \{\- gage first ( A findall B append shape B ) \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A seek B = A [in,find] B \line
   A in B ==> A find B pick B = A \line
   I in grid A and diverse A ==> I pick A find A = I \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Pragmatics\plain\fs20\cf1\cb1 \line

\par      The operation \i find\plain\fs20\cf1\cb1  uses a linear search on the items of \i B\plain\fs20\cf1\cb1  if the array has not been sorted, or uses a binary search algorithm if it has.  The latter fact suggests that an array that is searched frequently should be kept in lexicographical order by applying \i sortup\plain\fs20\cf1\cb1  to it when it is created or changed.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0075}
{\up $}{\footnote\pard\plain{\up $} findall}
{\up #}{\footnote\pard\plain{\up #} 1U9H6P6}
\pard\keepn\sb95 \b\fs25 findall\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} findall;search operation, findall}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul search operation\plain\fs20\cf1\cb1 {\v search operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A findall B   findall A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 find\plain\fs20\cf1\cb1 {\v QD17VY}, \uldb choose\plain\fs20\cf1\cb1 {\v 1XQ9M0F}, \uldb seek\plain\fs20\cf1\cb1 {\v 1CMJ30E}, \uldb in\plain\fs20\cf1\cb1 {\v RJ2SC2}\line

\par The operation \i findall\plain\fs20\cf1\cb1  returns a list of the addresses of all occurrences of \i A\plain\fs20\cf1\cb1  as an item of \i B\plain\fs20\cf1\cb1 , searching \i B\plain\fs20\cf1\cb1  in row major order.  If \i A\plain\fs20\cf1\cb1  does not occur in \i B\plain\fs20\cf1\cb1 , the result is the empty list \i Null\plain\fs20\cf1\cb1 .  \line

\par The result of \i findall\plain\fs20\cf1\cb1  is a list of integers if \i B\plain\fs20\cf1\cb1  is a list and a list of pairs if \i B\plain\fs20\cf1\cb1  is a table.  
\par \pard\keep\sb95 \f1\fs16      3 findall 56 34 3 23 3 57 3 \line
2 4 6 \line
 \line
     X := 3 4 reshape 1 7 3 2 3 4 3 2 6 3 \line
1 7 3 2 \line
3 4 3 2 \line
6 3 1 7 \line
 \line
     3 findall X \line
+---+---+---+---+ \line
|0 2|1 0|1 2|2 1| \line
+---+---+---+---+ \line
 \line
     `a findall 'hello world' \line
 \line
     1 1 findall tell 3 4 \line
+---+ \line
|1 1| \line
+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the first example \i findall\plain\fs20\cf1\cb1  returns the list of integers where 3 is found in the list; in the second a list of pairs is returned. The last example shows that if only one occurrence is found the result is a solitary list.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      findall IS OPERATION A B \{\- A EACHRIGHT equal B sublist grid B \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    (list A) findall B = A findall B \line
   list (A findall B) = A findall B \line
   A in B ==> A find B = first (A findall B) \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Pragmatics\plain\fs20\cf1\cb1 \line

\par The operation \i findall\plain\fs20\cf1\cb1  uses a linear search on the items of \i B\plain\fs20\cf1\cb1  if the array has not been sorted, or uses a binary search algorithm if it has.  The latter fact suggests that an array that is searched frequently should be kept in lexicographical order by applying \i sortup\plain\fs20\cf1\cb1  to it when it is created or changed.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0076}
{\up $}{\footnote\pard\plain{\up $} first}
{\up #}{\footnote\pard\plain{\up #} 7CFFMJ}
\pard\keepn\sb95 \b\fs25 first\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} first;selection operation, first}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 first A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 last\plain\fs20\cf1\cb1 {\v 1CMBZHN}, \uldb second\plain\fs20\cf1\cb1 {\v 1KDLMI5}, \uldb third\plain\fs20\cf1\cb1 {\v 7QE_L0}, \uldb pick\plain\fs20\cf1\cb1 {\v 40Z84P}, \uldb take\plain\fs20\cf1\cb1 {\v 25VVYWO}\line

\par The operation \i first\plain\fs20\cf1\cb1  returns the first of the items of \i A\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  is empty, it returns the fault \i ?address\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      first 4 5 6 \line
4 \line
 \line
     first count 3 4 5 \line
1 1 1 \line
 \line
     first Null \line
?address\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      first IS OPERATION A \{\- 0 pick list A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    first single A = A \line
   first solitary A = A \line
   first list A = first A \line
   first (S reshape A) = first A \line
   (valence A reshape 0) pick A = first A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0077}
{\up $}{\footnote\pard\plain{\up $} flip}
{\up #}{\footnote\pard\plain{\up #} QD10R0}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 flip\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} data rearrangement operation, flip;flip}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul data rearrangement operation\plain\fs20\cf1\cb1 {\v data rearrangement operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 flip A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 pack\plain\fs20\cf1\cb1 {\v QD0ZL5}\line

\par The operation \i flip\plain\fs20\cf1\cb1  is a synonym for \i pack\plain\fs20\cf1\cb1 . It has been retained for compatibility with earlier versions.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0078}
{\up $}{\footnote\pard\plain{\up $} floor}
{\up #}{\footnote\pard\plain{\up #} 7CICIH}
\pard\keepn\sb95 \b\fs25 floor\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, floor;floor}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 floor A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 ceiling\plain\fs20\cf1\cb1 {\v 5G__UQ}\line

\par The operation \i floor\plain\fs20\cf1\cb1  produces the following results when applied to atoms of the six types: 
\par 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 corresponding integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 next lower integer, or the fault ?A if the result is outside the range of integers \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 char \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      floor  l  -2  3.5  `a  "abc  ??error \line
1 -2 3 ?A ?A ?error \line
 \line
     floor  3.5  -4.6  7.0  25.3e20 \line
3 -5 7 ?A\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    floor A = opposite ceiling opposite A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0079}
{\up $}{\footnote\pard\plain{\up $} fold}
{\up #}{\footnote\pard\plain{\up #} QD1_TY}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 fold\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} applicative transformer, fold;fold}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul applicative transformer\plain\fs20\cf1\cb1 {\v applicative transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 N FOLD f A   FOLD f N A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 iterate\plain\fs20\cf1\cb1 {\v 11O99LP}, \uldb each\plain\fs20\cf1\cb1 {\v QCZZL2}\line

\par The transformer \i FOLD\plain\fs20\cf1\cb1  modifies an operation \i f\plain\fs20\cf1\cb1  to one that takes a pair of arguments consisting of an integer \i N\plain\fs20\cf1\cb1  and an arbitrary array \i A\plain\fs20\cf1\cb1 .  The result of applying \i N FOLD A\plain\fs20\cf1\cb1  is to apply \i f\plain\fs20\cf1\cb1 , \i N\plain\fs20\cf1\cb1  times, applying it first to \i A\plain\fs20\cf1\cb1  and subsequently to the result of the previous application.  
\par \pard\keep\sb95 \f1\fs16      3 FOLD rest 4 5 6 7 8 9 \line
7 8 9 \line
     2 FOLD sum (2 3 4) (5 6 7) \line
27 \line
     sum sum (2 3 4) (5 6 7) \line
27\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      FOLD IS TRANSFORMER f OPERATION N A \{\-  \line
        IF N > 0 THEN  \line
           N - 1 FOLD f ( f A )  \line
        ELSE  \line
           A  \line
        ENDIF \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    0 FOLD f A = A \line
   1 FOLD f A = f A \line
   2 FOLD f A = f f A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:007a}
{\up $}{\footnote\pard\plain{\up $} fork}
{\up #}{\footnote\pard\plain{\up #} 1CM__GE}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 fork\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} control structure transformer, fork;fork}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul control structure transformer\plain\fs20\cf1\cb1 {\v control structure transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 FORK [f,g,h] A   FORK [f,g,h,i,j,...z] A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 iterate\plain\fs20\cf1\cb1 {\v 11O99LP}, \uldb if-expr\plain\fs20\cf1\cb1 {\v XKQ1M}\line

\par The transformer \i FORK\plain\fs20\cf1\cb1  implements a conditional functional mechanism corresponding to the if-expression.  The argument to \i FORK\plain\fs20\cf1\cb1  must be an atlas of length two or more.  The operation in the first position is a predicate.  If there are exactly three items in the atlas, the first is a predicate; the second is applied to \i A\plain\fs20\cf1\cb1  if the predicate returns \i true\plain\fs20\cf1\cb1 ; and the third is applied to \i A\plain\fs20\cf1\cb1  if the predicate returns \i false\plain\fs20\cf1\cb1 .  That is, if \i f A\plain\fs20\cf1\cb1  is \i true\plain\fs20\cf1\cb1 , the result is \i g A\plain\fs20\cf1\cb1 ; otherwise it is \i h A\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 If there are more than three operations in the atlas, they are taken in pairs from left to right.  The first of each pair must be a predicate and is applied to \i A\plain\fs20\cf1\cb1  in turn until a result is \i true\plain\fs20\cf1\cb1 .  The result of the transform is the result of applying the second of that pair to \i A\plain\fs20\cf1\cb1 .  If no application results in \i true\plain\fs20\cf1\cb1  and the number of operations in the atlas is an odd number, the last operation is evaluated.  Otherwise the result is the fault \i ?noexpr\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      FORK [atomic, opposite, 1 +] (3 -4 (5 6 7)) \line
+-+--+-----+ \line
|4|-3|6 7 8| \line
+-+--+-----+ \line
 \line
     FORK [isreal,floor,simple,sum,5+] 2 4 6 \line
12\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    FORK [A first, B first, C first, D first, E first] Null = IF A THEN B ELSEIF C THEN D ELSE E ENDIF \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:007b}
{\up $}{\footnote\pard\plain{\up $} for-loop}
{\up #}{\footnote\pard\plain{\up #} MT.6OU}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 for-loop\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} control structure, for-loop;for-loop}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul control structure\plain\fs20\cf1\cb1 {\v control structure}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 FOR Var WITH Exp DO ExpSeq ENDFOR    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 repeat-loop\plain\fs20\cf1\cb1 {\v 12OGSY0}, \uldb while-loop\plain\fs20\cf1\cb1 {\v TQAIFP}, \uldb iterate\plain\fs20\cf1\cb1 {\v 11O99LP}, \uldb each\plain\fs20\cf1\cb1 {\v QCZZL2}\line

\par The \i FOR-loop\plain\fs20\cf1\cb1  control structure is used to execute the expression sequence \i ExpSeq\plain\fs20\cf1\cb1  repeatedly while variable \i Var\plain\fs20\cf1\cb1  takes on the values specified as items in the simple expression \i Exp\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      FOR X WITH 1. 2. 3. DO \line
        write (X) (X*X) (X power X) ; \line
     ENDFOR \line
1. 1. 1. \line
2. 4. 4. \line
3. 9. 27.\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the example, X takes on the values 1., 2.  and 3.  in successive loops and the values of X, X squared and X to the power X are displayed.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:007c}
{\up $}{\footnote\pard\plain{\up $} fromraw}
{\up #}{\footnote\pard\plain{\up #} 1IXHU.}
\pard\keepn\sb95 \b\fs25 fromraw\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} conversion operation, fromraw;fromraw}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 fromraw A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 toraw\plain\fs20\cf1\cb1 {\v TZXES2}\line

\par The operation \i fromraw\plain\fs20\cf1\cb1  converts the boolean array \i B\plain\fs20\cf1\cb1  to a simple array of the same type as atom \i A\plain\fs20\cf1\cb1 .
\par \pard\keep\sb95 \f1\fs16      fromraw `a olloooololloooloolloooll \line
abc \line
 \line
     fromraw 0 ooooooooooooooooooooooololollool \line
345 \line
 \line
fromraw 0.0 olooooooolooooololoooooooooooooooooooooooooooooooooooooooooooooo \line
34.5 \line
 \line
     fromraw l lollo \line
lollo\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    simple A and and (type A match type first A) => A = fromraw (toraw A) (first A) \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Pragmatics\plain\fs20\cf1\cb1 \line

\par \i Fromraw\plain\fs20\cf1\cb1  is used to convert raw bit data into atomic data that can be manipulated by Nial. If the data was created from Nial data using \i toraw\plain\fs20\cf1\cb1  then it will work in a system independent way. However, if raw byte data is obtained using \i readfile\plain\fs20\cf1\cb1  and then converted using \i toraw\plain\fs20\cf1\cb1  the host system byte ordering may need to be allowed for.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:007d}
{\up $}{\footnote\pard\plain{\up $} front}
{\up #}{\footnote\pard\plain{\up #} 7COCHJ}
\pard\keepn\sb95 \b\fs25 front\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} front;selection operation, front}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 front A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 last\plain\fs20\cf1\cb1 {\v 1CMBZHN}, \uldb rest\plain\fs20\cf1\cb1 {\v 1CMI3HN}, \uldb first\plain\fs20\cf1\cb1 {\v 7CFFMJ}\line

\par The operation \i front\plain\fs20\cf1\cb1  returns a list of all items but the last of \i A\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  is a solitary or is empty, the result is the empty list \i Null\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      front 3 4 5 6 \line
3 4 5 \line
     front tell 2 3 \line
+---+---+---+---+---+ \line
|0 0|0 1|0 2|1 0|1 1| \line
+---+---+---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      front IS OPERATION A \{\- tally A - 1 max 0 reshape list A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    front A = front list A \line
   list front A = front A \line
   front Null = Null \line
   not empty A ==> front A append last A = list A \line
   shape A reshape (front A append last A) = A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:007e}
{\up $}{\footnote\pard\plain{\up $} functions in nial}
{\up #}{\footnote\pard\plain{\up #} 3V52_J2}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 functions in nial\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, functions in nial;functions in nial}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 operation\plain\fs20\cf1\cb1 {\v CQFG7.}, \uldb transformer\plain\fs20\cf1\cb1 {\v 1VQL398}\line

\par A function is a mathematical name for an object that maps an argument in a given domain to a result in a given range.  In Nial, an \b operation\plain\fs20\cf1\cb1  is an object in the set of functions from the domain of Nial arrays to the range of Nial arrays.  Thus, an operation always applies to an array and returns an array.  \line

\par A \b transformer\plain\fs20\cf1\cb1  in Nial is also a function.  It domain is Nial operations and its range is also Nial operations.  Since its argument is itself a function, a transformer is said to be a \i second order\plain\fs20\cf1\cb1  function.  A transformer always applies to an operation and results in an operation.  \line

\par \pard\sb95 Definitions in which the associated object is a simple-expression are used to name program fragments that return an array value but which do not need parameters.  The resulting named-expression behaves like a function having no parameters.  \line

\par Nial is considered to be a functional language, but it is not purely functional in that it has assignments, loops and other non-functional concepts.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:007f}
{\up $}{\footnote\pard\plain{\up $} fuse}
{\up #}{\footnote\pard\plain{\up #} 40PDDJ}
\pard\keepn\sb95 \b\fs25 fuse\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} data rearrangement operation, fuse;fuse}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul data rearrangement operation\plain\fs20\cf1\cb1 {\v data rearrangement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 I fuse A   fuse I A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 transpose\plain\fs20\cf1\cb1 {\v 2UPAHZ}, \uldb blend\plain\fs20\cf1\cb1 {\v THU94J}, \uldb split\plain\fs20\cf1\cb1 {\v 5JDW.RI}\line

\par The operation \i fuse\plain\fs20\cf1\cb1  is used for two distinct purposes.  If \i I\plain\fs20\cf1\cb1  is simple and contains all the axes of \i A\plain\fs20\cf1\cb1  without repetition, the result is an array formed by a permutation of the axes of \i A\plain\fs20\cf1\cb1  by \i I\plain\fs20\cf1\cb1 .  The shape of the result is \i I choose shape A\plain\fs20\cf1\cb1 .  If \i I\plain\fs20\cf1\cb1  is not simple but link \i I\plain\fs20\cf1\cb1  is simple and contains all of the axes of \i A\plain\fs20\cf1\cb1  without repetition, the result is obtained by diagonalizing along axes that are grouped together, ordering them according to the ordering in \i I\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 If link \i I\plain\fs20\cf1\cb1  does not contain all the axes or if there are repetitions of the axes in link \i I\plain\fs20\cf1\cb1 , the fault \i ?invalid fuse\plain\fs20\cf1\cb1  is returned.  
\par \pard\keep\sb95 \f1\fs16      A := 2 3 4 reshape count 24 \line
1  2  3  4   13 14 15 16 \line
5  6  7  8   17 18 19 20 \line
9 10 11 12   21 22 23 24 \line
 \line
     1 2 0 fuse A \line
1 13   5 17    9 21 \line
2 14   6 18   10 22 \line
3 15   7 19   11 23 \line
4 16   8 20   12 24 \line
 \line
     0 (1 2) fuse A \line
 1  6 11 \line
13 18 23 \line
     [0 1 2] fuse A \line
1 18\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example is an axis permutation; the last two are diagonalizations.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    axes A fuse A = A \line
   transpose A = ( reverse axes A fuse A ) \line
   sortup I = axes A and not empty A ==> shape ( I fuse A ) = I choose shape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0080}
{\up $}{\footnote\pard\plain{\up $} gage}
{\up #}{\footnote\pard\plain{\up #} QD1ZOZ}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 gage\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} conversion operation, gage;gage}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 gage A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 pick\plain\fs20\cf1\cb1 {\v 40Z84P}, \uldb tell\plain\fs20\cf1\cb1 {\v 1CMK3AF}, \uldb grid\plain\fs20\cf1\cb1 {\v 40QA0I}\line

\par The operation \i gage\plain\fs20\cf1\cb1  is used to convert an array of integers into an atomic integer if there is only one item or a list if there is more than one.  The integers must be non-negative otherwise the fault \i ?gage\plain\fs20\cf1\cb1  is produced.  
\par \pard\keep\sb95 \f1\fs16      gage 4 5 6 \line
4 5 6 \line
 \line
     gage find 5 (tell 10) \line
6 \line
 \line
     gage 3 -4 5 \line
?gage\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The main purpose of \i gage\plain\fs20\cf1\cb1  is to express an list of non-negative integers in the form an address takes, i.e. it converts a solitary integer to the integer itself and leaves all other lists alone.\line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      gage is OPERATION A \{\-  \line
      IF and EACH isinteger A THEN \line
         IF tally A = 1 THEN  \line
            IF first A >= 0 THEN first A ELSE ??gage ENDIF \line
         ELSE \line
            IF and EACH (0<=) A THEN list A ELSE ??gage ENDIF \line
         ENDIF \line
      ELSE  \line
        ??gage \line
      ENDIF \'7d\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0081}
{\up $}{\footnote\pard\plain{\up $} getdef}
{\up #}{\footnote\pard\plain{\up #} 2EC.B}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 getdef\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} evaluation operation, getdef;getdef}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 getdef Nm    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 parse\plain\fs20\cf1\cb1 {\v TVJF9K}, \uldb eval\plain\fs20\cf1\cb1 {\v 40OE2Q}, \uldb see\plain\fs20\cf1\cb1 {\v 1ZNC7PK}\line

\par The operation \i getdef\plain\fs20\cf1\cb1  retrieves the parse tree associated with the global definition named \i Nm\plain\fs20\cf1\cb1 .  \i Nm\plain\fs20\cf1\cb1  may be a phrase or a string.  Only the parse trees associated with global user definitions can be retrieved.  
\par \pard\keep\sb95 \f1\fs16      foo IS first ; getdef "foo \line
+---+-----------------------------+ \line
|100|+--+---------------+------+-+| \line
|   ||11|+--+----------+|3 47 3|1|| \line
|   ||  ||22|2 160 7459||      | || \line
|   ||  |+--+----------+|      | || \line
|   |+--+---------------+------+-+| \line
+---+-----------------------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The example shows a parse tree for a simple definition.  For definitions of any reasonable size the diagram of the parse tree becomes too large to examine easily.  \line

\par The primary use of \i getdef\plain\fs20\cf1\cb1  is to provide an interface between internal representations and the editing facilities.  It is used in \i see\plain\fs20\cf1\cb1  and \i defedit\plain\fs20\cf1\cb1 .  The detailed form of the parse tree is implementation specific and may change in future releases.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0082}
{\up $}{\footnote\pard\plain{\up $} getfile}
{\up #}{\footnote\pard\plain{\up #} 45R7_SO}
\pard\keepn\sb95 \b\fs25 getfile\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} file operation, getfile;getfile}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul file operation\plain\fs20\cf1\cb1 {\v file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 getfile Filename    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 putfile\plain\fs20\cf1\cb1 {\v IMUFEL}, \uldb appendfile\plain\fs20\cf1\cb1 {\v 3AAL9Q}, \uldb open\plain\fs20\cf1\cb1 {\v 25VR_QX}, \uldb readfile\plain\fs20\cf1\cb1 {\v 5JAWOA}\line

\par The operation \i getfile\plain\fs20\cf1\cb1  returns the records of the text file named by the string or phrase \i Filename\plain\fs20\cf1\cb1  as a list of strings.  The file must not be open. 
\par \pard\keep\sb95 \f1\fs16      Recs := getfile "Myfile;\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      getfile IS OPERATION Filename \{\-  \line
        Fnum := open Filename `r;  \line
        IF isfault Fnum THEN  \line
           Fnum  \line
        ELSE  \line
           Lines := '';  \line
           Line := readfile Fnum;  \line
           WHILE Line ~= ??eof DO  \line
              Lines := Lines append Line;  \line
              Line := readfile Fnum;  \line
           ENDWHILE;  \line
           Lines  \line
        ENDIF \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0083}
{\up $}{\footnote\pard\plain{\up $} getname}
{\up #}{\footnote\pard\plain{\up #} 2EM8IE}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 getname\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} evaluation operation, getname;getname}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 getname Triple    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 parse\plain\fs20\cf1\cb1 {\v TVJF9K}, \uldb cast\plain\fs20\cf1\cb1 {\v 1CM9ZHN}, \uldb getdef\plain\fs20\cf1\cb1 {\v 2EC.B}\line

\par The operation \i getname\plain\fs20\cf1\cb1  retrieves the variable or definition name associated with a name reference \i triple\plain\fs20\cf1\cb1  within a parse tree.  The argument must be a triple with first item 2 that has been produced by the Q'Nial parser.  The operation is useful when analyzing the structure of a parse tree representation.  This is a specialized task and \i getname\plain\fs20\cf1\cb1  is used only with considerable knowledge of the internal workings of Q'Nial.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0084}
{\up $}{\footnote\pard\plain{\up $} getsyms}
{\up #}{\footnote\pard\plain{\up #} 2ERPIS}
\pard\keepn\sb95 \b\fs25 getsyms\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} evaluation operation, getsyms;getsyms}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 getsyms Nm    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 parse\plain\fs20\cf1\cb1 {\v TVJF9K}, \uldb getdef\plain\fs20\cf1\cb1 {\v 2EC.B}\line

\par The operation \i getsyms\plain\fs20\cf1\cb1  retrieves the parameters and local variables of a defined operation or expression named by \i Nm\plain\fs20\cf1\cb1 .  The operation is useful when analyzing the name usage of a definition in the context of analyzing the name interaction among a set of definitions.  This is a specialized task and \i getsyms\plain\fs20\cf1\cb1  is used only with considerable knowledge of the semantics of Q'Nial.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0085}
{\up $}{\footnote\pard\plain{\up $} global environment}
{\up #}{\footnote\pard\plain{\up #} 0.KANS}
\pard\keepn\sb95 \b\fs25 global environment\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, global environment;global environment}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 local environment\plain\fs20\cf1\cb1 {\v BN.OFR}\line

\par The \b global environment\plain\fs20\cf1\cb1  is the set of associations between names and objects formed in the workspace that are either predefined in Nial or have been created by actions that have taken place during a session.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0086}
{\up $}{\footnote\pard\plain{\up $} grade}
{\up #}{\footnote\pard\plain{\up #} 3HH5325}
\pard\keepn\sb95 \b\fs25 grade\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} grade;sorting transformer, grade}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul sorting transformer\plain\fs20\cf1\cb1 {\v sorting transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 GRADE f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 sort\plain\fs20\cf1\cb1 {\v 1CMJ_GN}, \uldb gradeup\plain\fs20\cf1\cb1 {\v 32WH0Y0}, \uldb lte\plain\fs20\cf1\cb1 {\v 1ZNC14K}, \uldb gte\plain\fs20\cf1\cb1 {\v 1ZNBW4K}\line

\par The transformer \i GRADE\plain\fs20\cf1\cb1  modifies a comparator \i f\plain\fs20\cf1\cb1  to produce an operation that, when applied to \i A\plain\fs20\cf1\cb1 , returns an array of addresses of the same shape as \i A\plain\fs20\cf1\cb1  that orders \i A\plain\fs20\cf1\cb1  according to the comparator.  The addresses can be used to select the items of \i A\plain\fs20\cf1\cb1  (using \i choose\plain\fs20\cf1\cb1 ) so that the items are in order according to \i f\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 A \b comparator\plain\fs20\cf1\cb1  is an operation that compares two arrays and returns \i true\plain\fs20\cf1\cb1  if they are in the desired ordering or \i false\plain\fs20\cf1\cb1  otherwise.  Operations \i lte\plain\fs20\cf1\cb1  (\i <=\plain\fs20\cf1\cb1 ) and \i gte\plain\fs20\cf1\cb1  (\i >=\plain\fs20\cf1\cb1 ) are the most commonly used comparators.  
\par \pard\keep\sb95 \f1\fs16      A gets 3 2 reshape 65 77 4 19 22 11 \line
65 77 \line
 4 19 \line
22 11 \line
 \line
     Addrs := GRADE >= A \line
+---+---+ \line
|0 1|0 0| \line
+---+---+ \line
|2 0|1 1| \line
+---+---+ \line
|2 1|1 0| \line
+---+---+ \line
 \line
     Addrs choose A \line
77 65 \line
22 19 \line
11  4 \line
 \line
     GRADE <= ("some "not "in "order) \line
3 1 0 2 \line
 \line
     GRADE <= ['xyz','abc','mno','cat'] \line
?invalid comparison in GRADE \line
 \line
     GRADE up ['xyz','abc','mno','cat'] \line
1 3 2 0\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first three expressions illustrate that \i GRADE\plain\fs20\cf1\cb1  returns the addresses that re-order the items of table \i A\plain\fs20\cf1\cb1  in descending order.  The next expression shows that the \i GRADE\plain\fs20\cf1\cb1  transform of \i <=\plain\fs20\cf1\cb1  can be applied to a list of phrases.  The second last expression shows that \i GRADE <=\plain\fs20\cf1\cb1  cannot be applied to a list of strings.  This is because \i <=\plain\fs20\cf1\cb1  is used itemwise on the characters of the strings and hence the comparator yields a bitstring rather than an atomic boolean result.  The last expression shows that the comparator \i up\plain\fs20\cf1\cb1  can be used with strings.\line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    SORT f A = GRADE f A choose A \line
   f a comparator ==> shape GRADE f A = shape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0087}
{\up $}{\footnote\pard\plain{\up $} gradeup}
{\up #}{\footnote\pard\plain{\up #} 32WH0Y0}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 gradeup\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} gradeup;sorting operation, gradeup}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul sorting operation\plain\fs20\cf1\cb1 {\v sorting operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 gradeup A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 sortup\plain\fs20\cf1\cb1 {\v ..CSLL}, \uldb grade\plain\fs20\cf1\cb1 {\v 3HH5325}, \uldb up\plain\fs20\cf1\cb1 {\v RJ2SO4}\line

\par The operation 
\par \pard\keep\sb95 \f1\fs16      gradeup 3 7 5 4 9 8 2 1 6 10 \line
7 6 0 3 2 8 1 5 4 9 \line
 \line
     gradeup ("some "words "not "in "order) \line
3 2 4 0 1\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      gradeup IS GRADE up\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    gradeup A choose A = sortup A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0088}
{\up $}{\footnote\pard\plain{\up $} grid}
{\up #}{\footnote\pard\plain{\up #} 40QA0I}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 grid\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} array generation operation, grid;grid}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul array generation operation\plain\fs20\cf1\cb1 {\v array generation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 grid A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 tell\plain\fs20\cf1\cb1 {\v 1CMK3AF}, \uldb address\plain\fs20\cf1\cb1 {\v 63.8K7}, \uldb shape\plain\fs20\cf1\cb1 {\v TYQ56K}\line

\par The operation \i grid\plain\fs20\cf1\cb1  returns the array of addresses of the array \i A\plain\fs20\cf1\cb1 .  The result has the same shape as \i A\plain\fs20\cf1\cb1 .  Each item of the result is the address of the corresponding item in \i A\plain\fs20\cf1\cb1 .  The grid of a list is a list of integers.  The grid of a table is a table of pairs of integers.  
\par \pard\keep\sb95 \f1\fs16      grid 3 6 4 7 4 \line
0 1 2 3 4 \line
 \line
     A :=  2 3 reshape count 6; A (grid A) \line
 \line
+-----+-------------+ \line
|1 2 3|+---+---+---+| \line
|4 5 6||0 0|0 1|0 2|| \line
|     |+---+---+---+| \line
|     ||1 0|1 1|1 2|| \line
|     |+---+---+---+| \line
+-----+-------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      grid IS OPERATION A \{\- tell gage shape A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    grid A choose A = A \line
   shape grid A = shape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0089}
{\up $}{\footnote\pard\plain{\up $} gt}
{\up #}{\footnote\pard\plain{\up #} RJ2SA8}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 gt\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} comparison operation, gt;gt}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul comparison operation\plain\fs20\cf1\cb1 {\v comparison operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A gt B   A > B   gt A B   > A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 gte\plain\fs20\cf1\cb1 {\v 1ZNBW4K}, \uldb lt\plain\fs20\cf1\cb1 {\v RJ2SF8}, \uldb match\plain\fs20\cf1\cb1 {\v TSJGTN}, \uldb mate\plain\fs20\cf1\cb1 {\v 25VOZ5O}, \uldb max\plain\fs20\cf1\cb1 {\v 1_E725N}, \uldb sort\plain\fs20\cf1\cb1 {\v 1CMJ_GN}\line

\par The operation \i gt\plain\fs20\cf1\cb1  compares two atoms \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  with the \i greater than\plain\fs20\cf1\cb1  relation, returning \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is greater than \i B\plain\fs20\cf1\cb1  and \i false\plain\fs20\cf1\cb1  otherwise.  The symbol \i >\plain\fs20\cf1\cb1  is a synonym for \i gt\plain\fs20\cf1\cb1 .  \line

\par The atoms in Nial are organized as a lattice using \i <=\plain\fs20\cf1\cb1  for the ordering.  The numeric atoms are comparable across types but numeric and literal atoms are incomparable.  The literal types are not comparable across types.  A comparison between incomparable objects results in \i false\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      R := l 2 2.5 `a "abc ??error \line
l 2 2.5 a abc ?error \line
 \line
     R OUTER > R \line
oooooo \line
looooo \line
lloooo \line
oooooo \line
oooooo \line
oooooo \line
 \line
     'apple' > 'above' \line
olloo \line
 \line
     "apple > "above \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The use of \i OUTER >\plain\fs20\cf1\cb1  shows the comparisons between various atom types.  The last two examples show the difference between comparing two strings, where the operation is distributed by its pervasive property; and comparing the corresponding phrases.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      gt IS OPERATION A B \{\- (A gte B) and not (A mate B) \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:008a}
{\up $}{\footnote\pard\plain{\up $} gte}
{\up #}{\footnote\pard\plain{\up #} 1ZNBW4K}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 gte\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} comparison operation, gte;gte}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul comparison operation\plain\fs20\cf1\cb1 {\v comparison operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A gte B   A >= B   gte A B   >= A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 gt\plain\fs20\cf1\cb1 {\v RJ2SA8}, \uldb lte\plain\fs20\cf1\cb1 {\v 1ZNC14K}, \uldb match\plain\fs20\cf1\cb1 {\v TSJGTN}, \uldb sort\plain\fs20\cf1\cb1 {\v 1CMJ_GN}\line

\par The operation \i gte\plain\fs20\cf1\cb1  compares two atoms \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  with the \i greater than or equal\plain\fs20\cf1\cb1  relation, returning \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is greater than or equal to \i B\plain\fs20\cf1\cb1  and \i false\plain\fs20\cf1\cb1  otherwise.  The symbol \i >=\plain\fs20\cf1\cb1  is a synonym for \i gte\plain\fs20\cf1\cb1 .  \line

\par The atoms in Nial are organized as a lattice using \i <=\plain\fs20\cf1\cb1  for the ordering.  The numeric atoms are comparable across types but numeric and literal atoms are incomparable.  The literal types are not comparable across types.  A comparison between incomparable objects results in \i false\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      R := l 2 2.5 `a "abc ??error \line
l 2 2.5 a abc ?error \line
 \line
     R OUTER >= R \line
looooo \line
lloooo \line
lllooo \line
oooloo \line
oooolo \line
oooool \line
 \line
     'apple' >= 'above' \line
lllol \line
 \line
     "apple >= "above \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The use of \i OUTER >=\plain\fs20\cf1\cb1  shows the comparisons between various atom types.  The last two examples show the difference between comparing two strings, where the operation is distributed by its pervasive property; and comparing the corresponding phrases.  \line

\par \b Definition\plain\fs20\cf1\cb1 \line

\par gte IS OPERATION A B \{\- B lte A \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:008b}
{\up $}{\footnote\pard\plain{\up $} help}
{\up #}{\footnote\pard\plain{\up #} 40R4_U}
\pard\keepn\sb95 \b\fs25 help\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} help;system expression, help}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Help    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 topic\plain\fs20\cf1\cb1 {\v 7QLDC9}, \uldb symbols\plain\fs20\cf1\cb1 {\v 1KUXMUU}\line

\par The Q'Nial Help Facility is integrated with the Windows Help mechanism in the Q'Nial for Windows version. If the cursor is over a word for which there is a help entry, then pressing F1 will bring up the help screen for that topic.\line

\par There is no Help Facility in console versions. However the Windows help file \i Winnial.hlp\plain\fs20\cf1\cb1  can be run independently of WinNial.exe.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:008c}
{\up $}{\footnote\pard\plain{\up $} hitch}
{\up #}{\footnote\pard\plain{\up #} TNRGTN}
\pard\keepn\sb95 \b\fs25 hitch\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} construction operation, hitch;hitch}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul construction operation\plain\fs20\cf1\cb1 {\v construction operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A hitch B   hitch A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 append\plain\fs20\cf1\cb1 {\v GFMD1P}, \uldb link\plain\fs20\cf1\cb1 {\v QD77W5}, \uldb list\plain\fs20\cf1\cb1 {\v 40V8DY}, \uldb solitary\plain\fs20\cf1\cb1 {\v 2BGSG4Y}\line

\par The operation \i hitch\plain\fs20\cf1\cb1  attaches \i A\plain\fs20\cf1\cb1  to the front of the list of items of \i B\plain\fs20\cf1\cb1 .  It returns a list of length one greater than the tally of \i B\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      (2 3 4) hitch (5 6 7) \line
+-----+-+-+-+ \line
|2 3 4|5|6|7| \line
+-----+-+-+-+ \line
     7 hitch 3 \line
7 3 \line
     hitch 'Wow' '' \line
+---+ \line
|Wow| \line
+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows that the list 2 3 4 becomes an item on the front of the list 5 6 7.  In the next example, the right argument of \i hitch\plain\fs20\cf1\cb1  is treated as a list.  The last example shows that if the right argument is an empty list, the result is the left argument as a solitary.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      hitch IS OPERATION A B \{\- solitary A link B \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A hitch B = A hitch (list B) \line
   A hitch Null = solitary A \line
   list (A hitch B) = A hitch B \line
   not empty A ==> first A hitch rest A = list A \line
   shape A reshape (first A hitch rest A) = A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:008d}
{\up $}{\footnote\pard\plain{\up $} host}
{\up #}{\footnote\pard\plain{\up #} 25VK_53}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 host\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} host;system operation, host}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 host S    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 edit\plain\fs20\cf1\cb1 {\v 40O30Y}\line

\par The operation \i host\plain\fs20\cf1\cb1  executes \i S\plain\fs20\cf1\cb1  as a host command language instruction.  The argument \i S\plain\fs20\cf1\cb1  is a string or a phrase.  If the action carried out by the host system produces output, the output is displayed on the screen.  In window mode, Q'Nial is unable to capture this output and hence it may scramble the screen output.  The screen is restored by executing \i Refresh\plain\fs20\cf1\cb1 .  \line

\par The result of \i host\plain\fs20\cf1\cb1  is the fault \i ?noexpr\plain\fs20\cf1\cb1  if the command has returned normally; or a fault generated from a system dependent error message supplied by the host operating system.  At the top level loop, a line beginning with \i !\plain\fs20\cf1\cb1 , the exclamation mark, is interpreted as a host command.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:008e}
{\up $}{\footnote\pard\plain{\up $} if-expr}
{\up #}{\footnote\pard\plain{\up #} XKQ1M}
\pard\keepn\sb95 \b\fs25 if-expr\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} control structure, if-expr;if-expr}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul control structure\plain\fs20\cf1\cb1 {\v control structure}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 IF C1 THEN Es1 ELSEIF C2 THEN Es2 ...  ELSEIF Cn THEN Esn ELSE Esx ENDIF    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 case-expr\plain\fs20\cf1\cb1 {\v 3BHT_IZ}, \uldb fork\plain\fs20\cf1\cb1 {\v 1CM__GE}\line

\par The \i IF-expr\plain\fs20\cf1\cb1  construct is a notation for executing one of a number of possible expression sequences \i Es1\plain\fs20\cf1\cb1 , \i Es2\plain\fs20\cf1\cb1 , ... \i Esn\plain\fs20\cf1\cb1 .  The sequence selected depends on the result of the conditional expressions \i C1\plain\fs20\cf1\cb1 , \i C2\plain\fs20\cf1\cb1 , ... \i Cn\plain\fs20\cf1\cb1 .  In the general case, whichever condition is first found to return \i true\plain\fs20\cf1\cb1  specifies the expression sequence to be performed.  If all the conditional expressions return \i false\plain\fs20\cf1\cb1 , expression sequence \i Esx\plain\fs20\cf1\cb1  is selected.  The \i ELSEIF\plain\fs20\cf1\cb1  and \i ELSE\plain\fs20\cf1\cb1  clauses are optional.  \line

\par \pard\sb95 In the following example, the result is one of phrase \i Adult\plain\fs20\cf1\cb1 , \i Minor\plain\fs20\cf1\cb1  or \i Juvenile\plain\fs20\cf1\cb1 , depending on the value of \i Age\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      Age := 17; \line
     IF Age > 18 THEN \line
        "Adult \line
     ELSEIF Age < 16 THEN \line
        "Minor \line
     ELSE \line
        "Juvenile \line
     ENDIF \line
Juvenile\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:008f}
{\up $}{\footnote\pard\plain{\up $} in}
{\up #}{\footnote\pard\plain{\up #} RJ2SC2}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 in\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} in;search operation, in}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul search operation\plain\fs20\cf1\cb1 {\v search operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A in B   in A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 allin\plain\fs20\cf1\cb1 {\v 5J2S.RC}, \uldb notin\plain\fs20\cf1\cb1 {\v 7KLHCD}, \uldb seek\plain\fs20\cf1\cb1 {\v 1CMJ30E}, \uldb find\plain\fs20\cf1\cb1 {\v QD17VY}, \uldb equal\plain\fs20\cf1\cb1 {\v TKZHRR}, \uldb sortup\plain\fs20\cf1\cb1 {\v ..CSLL}\line

\par The operation \i in\plain\fs20\cf1\cb1  returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is an item of \i B\plain\fs20\cf1\cb1  and returns \i false\plain\fs20\cf1\cb1  if it is not.  
\par \pard\keep\sb95 \f1\fs16      3 in 56 34 23 3 57 3 \line
l \line
     1 1 in tell 3 4 \line
l \line
     `a in 'hello world' \line
o \line
     `a in "apple \line
o \line
     `a in string "apple \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The fourth and fifth examples show that a letter is not an item of a phrase but is an item of the corresponding string.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      in IS OPERATION A B \{\- or (A EACHRIGHT equal B \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A in B = A in (list B) \line
   A in Null = False \line
   A in solitary A = True \line
   A in (A hitch B) = True \line
   A in (B append A) = True \line
   A in (A pair B) = True \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Pragmatics\plain\fs20\cf1\cb1 \line

\par The operation \i in\plain\fs20\cf1\cb1  uses a linear search on the items of \i B\plain\fs20\cf1\cb1  if the array has not been sorted, or uses a binary search algorithm if it has.  The latter fact suggests that an array that is searched frequently should be kept in lexicographical order by applying \i sortup\plain\fs20\cf1\cb1  to it when it is created.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0090}
{\up $}{\footnote\pard\plain{\up $} indexing}
{\up #}{\footnote\pard\plain{\up #} 2MDYZ6S}
\pard\keepn\sb95 \b\fs25 indexing\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, indexing;indexing}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 address\plain\fs20\cf1\cb1 {\v 63.8K7}, \uldb pick\plain\fs20\cf1\cb1 {\v 40Z84P}, \uldb choose\plain\fs20\cf1\cb1 {\v 1XQ9M0F}, \uldb reach\plain\fs20\cf1\cb1 {\v TXN4TN}\line

\par The term \b indexing\plain\fs20\cf1\cb1  is used to describe notations that can be used to \i select from \plain\fs20\cf1\cb1  or \i insert into\plain\fs20\cf1\cb1  a variable.\line

\par There are four indexing methods in Nial: \i at\plain\fs20\cf1\cb1 , \i at all\plain\fs20\cf1\cb1 , \i at path\plain\fs20\cf1\cb1  and \i slice\plain\fs20\cf1\cb1  represented by \i @\plain\fs20\cf1\cb1 , \i #\plain\fs20\cf1\cb1 , \i @@\plain\fs20\cf1\cb1  and \i |\plain\fs20\cf1\cb1  respectively.  The different indexing methods return different subsets of the array.  The following is a summary of the indexing methods:
\par \pard\sb95  \trowd\trgaph175\trleft-6 \cellx1105\cellx1995\cellx5795\pard\intbl\sb95 \b Method \cell\pard \pard\intbl\sb95 Name \cell\pard \pard\intbl\sb95 Description \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1105\cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 @ \cell\pard \pard\intbl\sb95 at \cell\pard \pard\intbl\sb95 indexes one item \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1105\cellx1995\cellx5795\pard\intbl\sb95 # \cell\pard \pard\intbl\sb95 at all \cell\pard \pard\intbl\sb95 indexes several items \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1105\cellx1995\cellx5795\pard\intbl\sb95 @@ \cell\pard \pard\intbl\sb95 at path \cell\pard \pard\intbl\sb95 indexes a part at depth \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1105\cellx1995\cellx5795\pard\intbl\sb95 | \cell\pard \pard\intbl\sb95 slice \cell\pard \pard\intbl\sb95 indexes cross-section of items \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      Cities := "London "Washington "Ottawa "Moscow "Paris ; \line
     Cities@0 \line
London \line
     Cities#[2,3] \line
Ottawa Moscow \line
 \line
     Alpha := 5 5 reshape 'ABCDEFGHIJKLMNOPQRSTUVWXY' \line
ABCDE \line
FGHIJ \line
KLMNO \line
PQRST \line
UVWXY \line
 \line
     Alpha@[0,2] \line
C \line
 \line
     Alpha|[1,] \line
FGHIJ \line
 \line
     Alpha|[,1] \line
BGLQV \line
 \line
     Alpha|[,[1,3]] \line
BD \line
GI \line
LN \line
QS \line
VX\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The following example shows the slightly different structure which occurs when a comma is either present or missing before the last item.  The library operation \i findpaths\plain\fs20\cf1\cb1  is used to indicate the path to the integer 10 in each case.
\par \pard\keep\sb95 \f1\fs16      set "diagram ; Nest1 := [1, 2, [3, 4, 5, [6, 7], 8, 9], 10] \line
+-+-+-----------------+--+ \line
|1|2|+-+-+-+-----+-+-+|10| \line
| | ||3|4|5|+-+-+|8|9||  | \line
| | || | | ||6|7|| | ||  | \line
| | || | | |+-+-+| | ||  | \line
| | |+-+-+-+-----+-+-+|  | \line
+-+-+-----------------+--+ \line
 \line
     set "diagram ; Nest2 := [1, 2, [3, 4, 5, [6, 7], 8, 9] 10] \line
+-+-+----------------------+ \line
|1|2|+-----------------+--+| \line
| | ||+-+-+-+-----+-+-+|10|| \line
| | |||3|4|5|+-+-+|8|9||  || \line
| | ||| | | ||6|7|| | ||  || \line
| | ||| | | |+-+-+| | ||  || \line
| | ||+-+-+-+-----+-+-+|  || \line
| | |+-----------------+--+| \line
+-+-+----------------------+ \line
 \line
     findpaths 10 Nest1 \line
+---+ \line
|+-+| \line
||3|| \line
|+-+| \line
+---+ \line
 \line
     findpaths 10 Nest2 \line
+-----+ \line
|+-+-+| \line
||2|1|| \line
|+-+-+| \line
+-----+ \line
 \line
     (Nest2@@[2,0,3,0]) \line
6 \line
 \line
     (Nest2@@[2,0,4]) \line
8 \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b  Address Validity\plain\fs20\cf1\cb1 \line

\par The index used in selecting a part of an array must be an expression that evaluates to a valid address.  An invalid index returns a fault as follows:
\par  \trowd\trgaph175\trleft-6 \cellx2655\cellx5795\pard\intbl\sb95 \b Indexing Method \cell\pard \pard\intbl\sb95 Fault \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2655\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 A@I \cell\pard \pard\intbl\sb95 ?address \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2655\cellx5795\pard\intbl\sb95 A#I \cell\pard \pard\intbl\sb95 ?addresses \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2655\cellx5795\pard\intbl\sb95 A@@P \cell\pard \pard\intbl\sb95 ?path \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2655\cellx5795\pard\intbl\sb95 A|I \cell\pard \pard\intbl\sb95 ?slice \cell\intbl\row
\pard\sb95 \line

\par The operation \i pick\plain\fs20\cf1\cb1  works the same as the \i at\plain\fs20\cf1\cb1  method of indexing.  If the index is invalid, \i pick\plain\fs20\cf1\cb1  returns the fault \i ?address\plain\fs20\cf1\cb1 .  Similarly, \i choose\plain\fs20\cf1\cb1  works the same as \i at all\plain\fs20\cf1\cb1  indexing.
\par \pard\keep\sb95 \f1\fs16      3 pick Cities \line
Moscow \line
 \line
     2 3 choose Cities \line
Ottawa Moscow \line
 \line
     10 pick Cities \line
?address \line
 \line
     4 5 6 choose Cities \line
Paris ?address ?address\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0091}
{\up $}{\footnote\pard\plain{\up $} infix notation}
{\up #}{\footnote\pard\plain{\up #} 50FXVP}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 infix notation\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} infix notation;syntax, infix notation}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 prefix notation\plain\fs20\cf1\cb1 {\v 16XL468}\line

\par In Nial an operation-expression may be placed between two array-expressions.This is called an \b infix\plain\fs20\cf1\cb1  use of the operation-expression.
\par \pard\keep\sb95 \f1\fs16      7 + 5 \line
12 \line
 \line
     2 3 reshape 1 2 3 4 5 6 \line
1 2 3 \line
4 5 6\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In using the infix notation, one must understand that if a sequence of operations are placed between two array arguments, all but the first operation are applied to the second argument.
\par \pard\keep\sb95 \f1\fs16      2 + reverse tell 3 \line
4 3 2 \line
 \line
     2 (+ reverse tell) 3 \line
3 6 \line
 \line
     2 (+ reverse) tell 3 \line
2 3 4\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0092}
{\up $}{\footnote\pard\plain{\up $} initial subdirectory}
{\up #}{\footnote\pard\plain{\up #} 1TS.2ZP}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 initial subdirectory\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, initial subdirectory;initial subdirectory}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 clear workspace\plain\fs20\cf1\cb1 {\v 2R04_UA}\line

\par The \i initial\plain\fs20\cf1\cb1  subdirectory is within the directory identified as the Nialroot directory.  It holds a number of files that may be used for initializing Q'Nial including the \i defs.ndf\plain\fs20\cf1\cb1  file used for creating the clearws workspace.  \line

\par When a Q'Nial session is initiated, if none of the -defs, Filename or Wsname options is used as a parameter to the nial command, the \i clearws.nws\plain\fs20\cf1\cb1  workspace is loaded.  If the \i clearws.nws\plain\fs20\cf1\cb1  file does not exist in the current directory, it is sought in the Nialroot directory.  If it is not present in either place, it is created automatically by the initialization process and kept internal to Q'Nial.  \line

\par \pard\sb95 A user can customize their version of Q'Nial by setting up an \i initial\plain\fs20\cf1\cb1  directory and modifying the \i defs.ndf\plain\fs20\cf1\cb1  file to include definitions they wish to be present in every Q'Nial session.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0093}
{\up $}{\footnote\pard\plain{\up $} inner}
{\up #}{\footnote\pard\plain{\up #} TOWAVX}
\pard\keepn\sb95 \b\fs25 inner\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} applicative transformer, inner;inner}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul applicative transformer\plain\fs20\cf1\cb1 {\v applicative transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A INNER [f,g] B   INNER [f,g] A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 outer\plain\fs20\cf1\cb1 {\v TV3GVX}, \uldb innerproduct\plain\fs20\cf1\cb1 {\v QPKGRK}, \uldb solve\plain\fs20\cf1\cb1 {\v 5JDV_40}, \uldb inverse\plain\fs20\cf1\cb1 {\v W4WJKP}\line

\par The transformer \i INNER\plain\fs20\cf1\cb1  generalizes the inner product operation of linear algebra.  For a pair of lists \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1 , the result is the application of the reductive operation \i f\plain\fs20\cf1\cb1  to the result of applying the binary pervasive operation \i g\plain\fs20\cf1\cb1  to \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1 .  It is assumed that \i f\plain\fs20\cf1\cb1  is one of the seven reductive operations of Nial: \i sum\plain\fs20\cf1\cb1 , \i product\plain\fs20\cf1\cb1 , \i or\plain\fs20\cf1\cb1 , \i and\plain\fs20\cf1\cb1 , \i max\plain\fs20\cf1\cb1 , \i min\plain\fs20\cf1\cb1 , or \i link\plain\fs20\cf1\cb1  and that \i g\plain\fs20\cf1\cb1  distributes pairwise.  For tables, \i OUTER g\plain\fs20\cf1\cb1  is applied to the rows of \i A\plain\fs20\cf1\cb1  and the columns of \i B\plain\fs20\cf1\cb1  and \i f\plain\fs20\cf1\cb1  is applied to each item of the outer product.  \line

\par \pard\sb95 Thus, \i INNER [+,*] \plain\fs20\cf1\cb1  is equivalent to matrix multiplication in linear algebra and \i INNER [or,and] \plain\fs20\cf1\cb1  is boolean matrix product.  For higher dimensional arrays, the lists are formed by "pushing down" the last axis of \i A\plain\fs20\cf1\cb1  and the first axis of \i B\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      2 3 4 INNER [+,*] 4 5 6 \line
47 \line
     loll INNER [or,and] olol \line
l \line
     A := 2 4 reshape count 8; \line
     B := 4 3 reshape tell 8; \line
     A B \line
+-------+-----+ \line
|1 2 3 4|0 1 2| \line
|5 6 7 8|3 4 5| \line
|       |6 7 0| \line
|       |1 2 3| \line
+-------+-----+ \line
     A INNER [sum,times] B \line
28 38 24 \line
68 94 64\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      INNER IS TRANSFORMER f g (OPERATION A B) \{\-  \line
        rows A OUTER (f g) (0 split B) \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape (A INNER [f,g] B) = (front shape A) link (rest shape B) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0094}
{\up $}{\footnote\pard\plain{\up $} innerproduct}
{\up #}{\footnote\pard\plain{\up #} QPKGRK}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 innerproduct\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} innerproduct;linear algebra operation, innerproduct}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul linear algebra operation\plain\fs20\cf1\cb1 {\v linear algebra operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A innerproduct B   A ip B   innerproduct A B   ip A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 inner\plain\fs20\cf1\cb1 {\v TOWAVX}, \uldb outer\plain\fs20\cf1\cb1 {\v TV3GVX}, \uldb solve\plain\fs20\cf1\cb1 {\v 5JDV_40}, \uldb inverse\plain\fs20\cf1\cb1 {\v W4WJKP}\line

\par The operation \i innerproduct\plain\fs20\cf1\cb1  computes the mathematical inner product of real vectors and matrices using special code for efficiency.  For real matrices, it produces the same result as \i A INNER [+,*] B\plain\fs20\cf1\cb1 , but computes the result more rapidly for large arguments.  It coerces boolean and integer arrays to reals.  The name \i ip\plain\fs20\cf1\cb1  is provided as an abbreviation.  
\par \pard\keep\sb95 \f1\fs16      A := 2 4 reshape count 8; \line
     B := 4 3 reshape tell 8; \line
     A B \line
+-------+-----+ \line
|1 2 3 4|0 1 2| \line
|5 6 7 8|3 4 5| \line
|       |6 7 0| \line
|       |1 2 3| \line
+-------+-----+ \line
 \line
     A innerproduct B \line
28. 38. 24. \line
68. 94. 64.\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The number of columns of \i A\plain\fs20\cf1\cb1  must match the number of rows in \i B\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      B ip A \line
?conform in ip\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0095}
{\up $}{\footnote\pard\plain{\up $} interrupt}
{\up #}{\footnote\pard\plain{\up #} 8EQO0LE}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 interrupt\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, interrupt;interrupt}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 fault triggering\plain\fs20\cf1\cb1 {\v 2JAK0C0}, \uldb setinterrupts\plain\fs20\cf1\cb1 {\v 36DY_X6}, \uldb toplevel\plain\fs20\cf1\cb1 {\v 3A08M4I}\line

\par An \b interrupt\plain\fs20\cf1\cb1  is an event that causes the operating system to suspend its operation and address a requirement of higher priority.  Typically, interrupts occur to handle input/output.  However, an interrupt also occurs when a fault is detected.  \line

\par In the default mode of operation of Q'Nial, most fault values are not created.  Rather, an interrupt is triggered.  A description of the fault triggering mechanism is given under \i fault triggering\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 The user can interrupt execution by pressing \i <Ctrl-c> <Return>\plain\fs20\cf1\cb1  at the keyboard in console versions, or clicking on the \i STOP\plain\fs20\cf1\cb1  button in the GUI version. This capability can be turned off using \i setinterrrupts\plain\fs20\cf1\cb1 . An interrupt can also be triggered under program control using the expression \i Toplevel\plain\fs20\cf1\cb1 .\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0096}
{\up $}{\footnote\pard\plain{\up $} inverse}
{\up #}{\footnote\pard\plain{\up #} W4WJKP}
\pard\keepn\sb95 \b\fs25 inverse\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} inverse;linear algebra operation, inverse}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul linear algebra operation\plain\fs20\cf1\cb1 {\v linear algebra operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 inverse A   inverse A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 solve\plain\fs20\cf1\cb1 {\v 5JDV_40}, \uldb inner\plain\fs20\cf1\cb1 {\v TOWAVX}, \uldb innerproduct\plain\fs20\cf1\cb1 {\v QPKGRK}, \uldb outer\plain\fs20\cf1\cb1 {\v TV3GVX}\line

\par The operation \i inverse\plain\fs20\cf1\cb1  computes the mathematical inverse of a square matrix \i A\plain\fs20\cf1\cb1  returning a square matrix of the same shape.  If \i A\plain\fs20\cf1\cb1  is \b singular\plain\fs20\cf1\cb1  within numerical limits, the result is the fault \i ?singular\plain\fs20\cf1\cb1 .  The name \i inv\plain\fs20\cf1\cb1  is provided as an abbreviation.  
\par \pard\keep\sb95 \f1\fs16      seed 0.5; \line
     A := ceiling ( 100. * (3 3 reshape random 9)) \line
50 44 13 \line
78 74 90 \line
98 67 17 \line
 \line
     inverse A \line
-0.0736442  0.00189821  0.0462669 \line
  0.115652 -0.00654341  -0.053798 \line
-0.0312664   0.0148461 0.00413593 \line
 \line
     A innerproduct inverse A \line
         1. -6.93889e-18 -7.11237e-17 \line
 9.4369e-16           1. -1.97758e-16 \line
3.60822e-16 -6.93889e-18           1.\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The final computation shows that the result is not always an exact inverse due to roundoff errors introduced by using floating point arithmetic.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A a square matrix ==> A innerproduct (inverse A) innerproduct A = A   (within roundoff error) \line
   inverse A innerproduct B = A solve B   (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0097}
{\up $}{\footnote\pard\plain{\up $} isboolean}
{\up #}{\footnote\pard\plain{\up #} 1VYX20O}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 isboolean\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} isboolean;measurement operation, isboolean}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 isboolean A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 type\plain\fs20\cf1\cb1 {\v 25VWG1O}, \uldb isinteger\plain\fs20\cf1\cb1 {\v 23WZ8W4}, \uldb isreal\plain\fs20\cf1\cb1 {\v OIOCOX}\line

\par The operation \i isboolean\plain\fs20\cf1\cb1  tests whether or not \i A\plain\fs20\cf1\cb1  is a boolean atom.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is a boolean, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      isboolean false \line
l \line
     isboolean llollool \line
o \line
     isboolean 7 \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 \line

\par isboolean IS OPERATION A \{\- type A = o \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0098}
{\up $}{\footnote\pard\plain{\up $} ischar}
{\up #}{\footnote\pard\plain{\up #} 1ARLF.C}
\pard\keepn\sb95 \b\fs25 ischar\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} ischar;measurement operation, ischar}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 ischar A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 type\plain\fs20\cf1\cb1 {\v 25VWG1O}, \uldb isfault\plain\fs20\cf1\cb1 {\v 1MY4M1D}, \uldb isphrase\plain\fs20\cf1\cb1 {\v E7PW.M}, \uldb isstring\plain\fs20\cf1\cb1 {\v HCQ47O}\line

\par The operation \i ischar\plain\fs20\cf1\cb1  tests whether or not atom \i A\plain\fs20\cf1\cb1  is a character atom.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is a character, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      EACH ischar (`a) ('a') 7 \line
loo\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the example \i 'a'\plain\fs20\cf1\cb1  is not an atom; it is a solitary holding \i `a\plain\fs20\cf1\cb1 .\line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      ischar IS OPERATION A \{\- type A = ` \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0099}
{\up $}{\footnote\pard\plain{\up $} isfault}
{\up #}{\footnote\pard\plain{\up #} 1MY4M1D}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 isfault\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} isfault;measurement operation, isfault}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 isfault A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 type\plain\fs20\cf1\cb1 {\v 25VWG1O}, \uldb isphrase\plain\fs20\cf1\cb1 {\v E7PW.M}, \uldb ischar\plain\fs20\cf1\cb1 {\v 1ARLF.C}, \uldb isstring\plain\fs20\cf1\cb1 {\v HCQ47O}\line

\par The operation \i isfault\plain\fs20\cf1\cb1  tests whether or not \i A\plain\fs20\cf1\cb1  is a fault.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is a fault, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      EACH isfault (??error) ("?error) \line
lo\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      isfault IS OPERATION A \{\- type A = ?? \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:009a}
{\up $}{\footnote\pard\plain{\up $} isinteger}
{\up #}{\footnote\pard\plain{\up #} 23WZ8W4}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 isinteger\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} isinteger;measurement operation, isinteger}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 isinteger A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 type\plain\fs20\cf1\cb1 {\v 25VWG1O}, \uldb isboolean\plain\fs20\cf1\cb1 {\v 1VYX20O}, \uldb isreal\plain\fs20\cf1\cb1 {\v OIOCOX}\line

\par The operation \i isinteger\plain\fs20\cf1\cb1  tests whether or not \i A\plain\fs20\cf1\cb1  is an integer.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is an integer, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      EACH isinteger (7)(2 3 4)(`3)(3.0) \line
looo \line
 \line
     isinteger (`a find 'whale') \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The last example returns \i true\plain\fs20\cf1\cb1  because the result of \i `a find 'whale'\plain\fs20\cf1\cb1  is an integer, since the second argument of \i find\plain\fs20\cf1\cb1  is a list.\line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      isinteger IS OPERATION A \{\- type A = 0 \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:009b}
{\up $}{\footnote\pard\plain{\up $} isphrase}
{\up #}{\footnote\pard\plain{\up #} E7PW.M}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 isphrase\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} isphrase;measurement operation, isphrase}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 isphrase A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 type\plain\fs20\cf1\cb1 {\v 25VWG1O}, \uldb isstring\plain\fs20\cf1\cb1 {\v HCQ47O}, \uldb isfault\plain\fs20\cf1\cb1 {\v 1MY4M1D}, \uldb ischar\plain\fs20\cf1\cb1 {\v 1ARLF.C}\line

\par The operation \i isphrase\plain\fs20\cf1\cb1  tests whether or not \i A\plain\fs20\cf1\cb1  is a phrase.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is a phrase, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      isphrase "Mike \line
l \line
     isphrase 'abc' \line
o \line
     isphrase  `a \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      isphrase IS OPERATION A \{\- type A = "" \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:009c}
{\up $}{\footnote\pard\plain{\up $} isreal}
{\up #}{\footnote\pard\plain{\up #} OIOCOX}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 isreal\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} isreal;measurement operation, isreal}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 isreal A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 type\plain\fs20\cf1\cb1 {\v 25VWG1O}, \uldb isboolean\plain\fs20\cf1\cb1 {\v 1VYX20O}, \uldb isinteger\plain\fs20\cf1\cb1 {\v 23WZ8W4}\line

\par The operation \i isreal\plain\fs20\cf1\cb1  tests whether or not \i A\plain\fs20\cf1\cb1  is a real number.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is a real number, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      isreal 3.5 \line
l \line
 \line
     isreal 'abc' \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      isreal IS OPERATION A \{\- type A = 0.  \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:009d}
{\up $}{\footnote\pard\plain{\up $} isstring}
{\up #}{\footnote\pard\plain{\up #} HCQ47O}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 isstring\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} isstring;measurement operation, isstring}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 isstring A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 ischar\plain\fs20\cf1\cb1 {\v 1ARLF.C}, \uldb string\plain\fs20\cf1\cb1 {\v .ACHEC}\line

\par The operation \i isstring\plain\fs20\cf1\cb1  tests whether or not the array \i A\plain\fs20\cf1\cb1  is a string.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is a string, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      isstring 'A string' \line
l \line
     isstring `A \line
o \line
     isstring `2 `A `? \line
l \line
     isstring '' \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      isstring IS OP A \{\- valence A = 1 and EACH ischar A \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    atomic A ==> isstring string A = True \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:009e}
{\up $}{\footnote\pard\plain{\up $} item}
{\up #}{\footnote\pard\plain{\up #} 40SC6R}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 item\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, item;item}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 array\plain\fs20\cf1\cb1 {\v 28ZHDVT}, \uldb address\plain\fs20\cf1\cb1 {\v 63.8K7}\line

\par An array \i A\plain\fs20\cf1\cb1  is said to be an \b item\plain\fs20\cf1\cb1  of array \i B\plain\fs20\cf1\cb1  if \i B\plain\fs20\cf1\cb1  holds \i A\plain\fs20\cf1\cb1  at one or more locations. The term is a relative one; we cannot speak of item except in reference to the array that holds it.  The items of an array A are the objects at the locations at the top level.\line

\par The number of items in an array is called the tally of the array.  Because an array is rectangular, the tally is the product of the shape.  \line

\par \pard\sb95 The following names are give to common array structures:
\par  \trowd\trgaph175\trleft-6 \cellx1775\cellx3435\cellx5795\pard\intbl\sb95 \b # of items \cell\pard \pard\intbl\sb95 # of axes \cell\pard \pard\intbl\sb95 Name \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1775\cellx3435\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 0 \cell\pard \pard\intbl\sb95 1 \cell\pard \pard\intbl\sb95 empty list \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1775\cellx3435\cellx5795\pard\intbl\sb95 1 \cell\pard \pard\intbl\sb95 0 \cell\pard \pard\intbl\sb95 single \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1775\cellx3435\cellx5795\pard\intbl\sb95 1 \cell\pard \pard\intbl\sb95 1 \cell\pard \pard\intbl\sb95 solitary \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1775\cellx3435\cellx5795\pard\intbl\sb95 1 \cell\pard \pard\intbl\sb95 2 \cell\pard \pard\intbl\sb95 1 by 1 table \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1775\cellx3435\cellx5795\pard\intbl\sb95 2 \cell\pard \pard\intbl\sb95 1 \cell\pard \pard\intbl\sb95 pair \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1775\cellx3435\cellx5795\pard\intbl\sb95 3 \cell\pard \pard\intbl\sb95 1 \cell\pard \pard\intbl\sb95 triple \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1775\cellx3435\cellx5795\pard\intbl\sb95 4 \cell\pard \pard\intbl\sb95 1 \cell\pard \pard\intbl\sb95 quadruple \cell\intbl\row
\pard\sb95 \line

\par The arrays of Nial are a recursive data type.  That is, the items of an array are also arrays.  Since an array has arrays as items, it may contain data at lower levels than the top one.  A \b path\plain\fs20\cf1\cb1  is a list of addresses that describes a data object at some depth within the array.  \line

\par An array is said to be \b simple\plain\fs20\cf1\cb1  if all its items are atomic.  \line

\par A \b part\plain\fs20\cf1\cb1  of an array is a data object that is contained at some level within the array.  The atomic parts of an array are called the \b leaves\plain\fs20\cf1\cb1  of the array.  The simple parts are called \b twigs\plain\fs20\cf1\cb1 .  The term \b level\plain\fs20\cf1\cb1  is used informally to describe the relative position of a part within the nesting structure of an array.  An item is at the first or top level, an item of an item is at the second level, etc.  \line

\par \pard\sb95 An \b empty\plain\fs20\cf1\cb1  array is one that has no items.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:009f}
{\up $}{\footnote\pard\plain{\up $} iterate}
{\up #}{\footnote\pard\plain{\up #} 11O99LP}
\pard\keepn\sb95 \b\fs25 iterate\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} control structure transformer, iterate;iterate}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul control structure transformer\plain\fs20\cf1\cb1 {\v control structure transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 ITERATE f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 each\plain\fs20\cf1\cb1 {\v QCZZL2}, \uldb for-loop\plain\fs20\cf1\cb1 {\v MT.6OU}, \uldb fork\plain\fs20\cf1\cb1 {\v 1CM__GE}\line

\par The transformer \i ITERATE\plain\fs20\cf1\cb1  is used to apply the operation \i f\plain\fs20\cf1\cb1  sequentially to the items of \i A\plain\fs20\cf1\cb1  in row major order.  (Row major order means across the rows moving left to right, starting at the top row and then going down the rows.  An example is given under list.) The result is the result of applying \i f\plain\fs20\cf1\cb1  to the final item.  If \i A\plain\fs20\cf1\cb1  has no items, the result is the fault \i ?noexpr\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      ITERATE write "Hello "out "there. \line
Hello \line
out \line
there. \line
 \line
     A IS EXTERNAL VARIABLE; \line
     accum IS OPERATION B \{\- \line
        NONLOCAL A; A := A + B \'7d; \line
     A := 20; \line
     ITERATE accum 3 4 5 ; A \line
32\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the second example, the operation \i accum\plain\fs20\cf1\cb1  increments variable \i A\plain\fs20\cf1\cb1  by the argument value.  The example shows \i ITERATE\plain\fs20\cf1\cb1  being used to apply \i accum\plain\fs20\cf1\cb1  to the list 3 4 5, which results in \i A\plain\fs20\cf1\cb1  having the values 23, 27 and 32.  \line

\par With \i ITERATE\plain\fs20\cf1\cb1 , an operation that has a side effect can be applied to an array of arguments sequentially in a specific sequence.  On the other hand, the order of application is undefined for \i EACH\plain\fs20\cf1\cb1 .  \line

\par A second major difference between \i EACH\plain\fs20\cf1\cb1  and \i ITERATE\plain\fs20\cf1\cb1  is that \i ITERATE\plain\fs20\cf1\cb1  returns only the result of the last application whereas \i EACH\plain\fs20\cf1\cb1  returns the array of all the results.  \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      ITERATE IS TR f OPERATION A \{\- FOR X WITH A DO f A ENDFOR \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00a0}
{\up $}{\footnote\pard\plain{\up $} juxtaposition}
{\up #}{\footnote\pard\plain{\up #} PU.YMO}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 juxtaposition\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} juxtaposition;syntax, juxtaposition}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}\line

\par \pard\sb95 The syntax rules for simple-expressions show three uses of the side-by-side or juxtapositional notation of Nial: strand formation, prefix operation application and infix operation application.  There are no syntactic restrictions as to whether or not a particular operation may be applied in infix or prefix form.  A fault is returned at run time if an operation is used inappropriately.  \line

\par \b Summary of Juxtapositional Syntax \plain\fs20\cf1\cb1 \line

\par The following table illustrates the uses of juxtaposition in Nial, where \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  are array-expressions, \i f\plain\fs20\cf1\cb1  and \i g\plain\fs20\cf1\cb1  are operation-expressions, and \i T\plain\fs20\cf1\cb1  is a transformer: 
\par \pard\sb95  \trowd\trgaph175\trleft-6 \cellx775\cellx2325\cellx5795\pard\intbl\sb95 \b Form \cell\pard \pard\intbl\sb95 Name \cell\pard \pard\intbl\sb95 Object \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx2325\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 A B \cell\pard \pard\intbl\sb95 strand \cell\pard \pard\intbl\sb95 array \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx2325\cellx5795\pard\intbl\sb95 A f \cell\pard \pard\intbl\sb95 currying \cell\pard \pard\intbl\sb95 operation \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx2325\cellx5795\pard\intbl\sb95 f A \cell\pard \pard\intbl\sb95 prefix use \cell\pard \pard\intbl\sb95 array \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx2325\cellx5795\pard\intbl\sb95 f g \cell\pard \pard\intbl\sb95 composition \cell\pard \pard\intbl\sb95 operation \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx2325\cellx5795\pard\intbl\sb95 T f \cell\pard \pard\intbl\sb95 transform \cell\pard \pard\intbl\sb95 operation \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx2325\cellx5795\pard\intbl\sb95 A f B \cell\pard \pard\intbl\sb95 infix use \cell\pard \pard\intbl\sb95 array \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx2325\cellx5795\pard\intbl\sb95 T f A \cell\pard \pard\intbl\sb95 transform use \cell\pard \pard\intbl\sb95 array \cell\intbl\row
\pard \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00a1}
{\up $}{\footnote\pard\plain{\up $} laminate}
{\up #}{\footnote\pard\plain{\up #} M19KO1}
\pard\keepn\sb95 \b\fs25 laminate\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} construction operation, laminate;laminate}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul construction operation\plain\fs20\cf1\cb1 {\v construction operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 I laminate A   laminate I A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 link\plain\fs20\cf1\cb1 {\v QD77W5}, \uldb catenate\plain\fs20\cf1\cb1 {\v BNUIZP}\line

\par The operation \i laminate\plain\fs20\cf1\cb1  merges the items of \i A\plain\fs20\cf1\cb1  adding a new axis before axis \i I\plain\fs20\cf1\cb1  of the items.  The items of \i A\plain\fs20\cf1\cb1  must be of the same shape.  \line

\par The following example creates a three dimensional array from two tables, placing the new axes at the front: 
\par \pard\keep\sb95 \f1\fs16      0 laminate (tell 2 3) (count 2 3) \line
+---+---+---+  +---+---+---+ \line
|0 0|0 1|0 2|  |1 1|1 2|1 3| \line
+---+---+---+  +---+---+---+ \line
|1 0|1 1|1 2|  |2 1|2 2|2 3| \line
+---+---+---+  +---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      laminate IS OPERATION I A \{\-  \line
        IF equal EACH shape A THEN  \line
           Axesofitems := axes first A;  \line
           link (I take Axesofitems) (I drop Axesofitems + 1) blend A  \line
        ELSE  \line
           fault '?conform error in laminate'  \line
        ENDIF \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00a2}
{\up $}{\footnote\pard\plain{\up $} last}
{\up #}{\footnote\pard\plain{\up #} 1CMBZHN}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 last\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} last;selection operation, last}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 last A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 first\plain\fs20\cf1\cb1 {\v 7CFFMJ}, \uldb pick\plain\fs20\cf1\cb1 {\v 40Z84P}, \uldb take\plain\fs20\cf1\cb1 {\v 25VVYWO}\line

\par The operation \i last\plain\fs20\cf1\cb1  returns the last of the items of \i A\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  is empty, it returns the fault \i ?address\plain\fs20\cf1\cb1 .  The operation \i last\plain\fs20\cf1\cb1  is a special case of \i pick\plain\fs20\cf1\cb1  (because \i first\plain\fs20\cf1\cb1  is defined in terms of \i pick\plain\fs20\cf1\cb1 ) and its behaviour is determined by that of \i pick\plain\fs20\cf1\cb1 .  Every nonempty array has a last item.  
\par \pard\keep\sb95 \f1\fs16      last 4 5 6 \line
6 \line
 \line
     last tell 3 4 \line
2 3\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      last IS OPERATION A \{\- first reverse A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    last single A = A \line
   last solitary A = A \line
   last list A = last A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00a3}
{\up $}{\footnote\pard\plain{\up $} latent}
{\up #}{\footnote\pard\plain{\up #} 4YEDEP}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 latent\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} latent;user defined expression, latent}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul user defined expression\plain\fs20\cf1\cb1 {\v user defined expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Latent    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 recover\plain\fs20\cf1\cb1 {\v 7L0TNT}, \uldb checkpoint\plain\fs20\cf1\cb1 {\v 4LLHD1P}, \uldb load\plain\fs20\cf1\cb1 {\v QD7_IY}, \uldb save\plain\fs20\cf1\cb1 {\v 25VUZ7O}\line

\par The expression \i Latent\plain\fs20\cf1\cb1  is used to name an expression to be executed without user intervention when the workspace is loaded.  \i Latent\plain\fs20\cf1\cb1  is used in closed applications so that an application can be started when the workspace is loaded.  \i Latent\plain\fs20\cf1\cb1  can establish any default or initial conditions desired.  
\par \pard\keep\sb95 \f1\fs16      Latent IS \{\- \line
        settrigger o; \line
        set "log; \line
        StartApp;  \line
        Bye; \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the example, \i Latent\plain\fs20\cf1\cb1  is defined to turn of triggering of faults, to turn on session logging, to start the application and then to terminate the session.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00a4}
{\up $}{\footnote\pard\plain{\up $} leaf}
{\up #}{\footnote\pard\plain{\up #} 40V42K}
\pard\keepn\sb95 \b\fs25 leaf\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} distributive transformer, leaf;leaf}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul distributive transformer\plain\fs20\cf1\cb1 {\v distributive transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 LEAF f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 twig\plain\fs20\cf1\cb1 {\v 25VWDUQ}, \uldb each\plain\fs20\cf1\cb1 {\v QCZZL2}, \uldb content\plain\fs20\cf1\cb1 {\v 11UQ9BC}\line

\par The transformer \i LEAF\plain\fs20\cf1\cb1  modifies an operation \i f\plain\fs20\cf1\cb1  into an operation that applies f to every atom of the argument \i A\plain\fs20\cf1\cb1 .  The result of applying \i LEAF f\plain\fs20\cf1\cb1  to \i A\plain\fs20\cf1\cb1  has the same shape as \i A\plain\fs20\cf1\cb1 .  If \i f\plain\fs20\cf1\cb1  maps atoms to atoms, the result has the same structure as \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      A := tell 2 3 \line
+---+---+---+ \line
|0 0|0 1|0 2| \line
+---+---+---+ \line
|1 0|1 1|1 2| \line
+---+---+---+ \line
 \line
     LEAF tally A \line
+---+---+---+ \line
|1 1|1 1|1 1| \line
+---+---+---+ \line
|1 1|1 1|1 1| \line
+---+---+---+ \line
 \line
     B := (2 3) (1 2) \line
+---+---+ \line
|2 3|1 2| \line
+---+---+ \line
 \line
     LEAF tell B \line
+-----------+-------+ \line
|+---+-----+|+-+---+| \line
||0 1|0 1 2|||0|0 1|| \line
|+---+-----+|+-+---+| \line
+-----------+-------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows that the result of applying a \i LEAF\plain\fs20\cf1\cb1  transform to a table is a table of the same shape.  The atoms have been mapped to 1 since the tally of an atom is 1.  The second example shows that applying a \i LEAF\plain\fs20\cf1\cb1  transform to a list gives a list of the same length.  However, the structure of the result is not preserved in this example because \i tell\plain\fs20\cf1\cb1  maps an integer to a list of integers.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      LEAF IS TRANSFORMER f OPERATION A \{\-  \line
        IF atomic A THEN  \line
           f A  \line
        ELSE  \line
           EACH (LEAF f) A  \line
        ENDIF \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape LEAF f A = shape A \line
   f unary pervasive ==> LEAF f A = f A \line
   (LEAF f) (LEAF g) A = LEAF (f g) A \line
   LEAF f list A = list LEAF f A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00a5}
{\up $}{\footnote\pard\plain{\up $} level}
{\up #}{\footnote\pard\plain{\up #} TRNIVR}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 level\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, level;level}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 item\plain\fs20\cf1\cb1 {\v 40SC6R}\line

\par The term \b level\plain\fs20\cf1\cb1  is used informally to describe the relative position of a part within the nesting structure of an array.  An item is at the first or top level, an item of an item is at the second level, etc.  \line

\par An atom is viewed in two ways.  As an indivisible data object it is viewed as having no levels and cannot be broken into subarrays.  As an array data structure it is viewed as a single holding itself and therefore has an infinity of levels.  This view is necessary for atomic arrays to fit the theory of nested array mathematics.  \line

\par \pard\sb95 The number of levels to reach an atom along each path need not be the same.  For example, in the following array, the phrase "hello is at the first level, the integer 23 is at the second level and the character `b is at the third level.  
\par \pard\keep\sb95 \f1\fs16      [ 23 'abc', "hello , tell 2 2 ] \line
+------------+-----+-------------+ \line
|+--+-------+|hello|+-----+-----+| \line
||23|+-+-+-+||     ||+-+-+|+-+-+|| \line
||  ||a|b|c|||     |||0|0|||0|1||| \line
||  |+-+-+-+||     ||+-+-+|+-+-+|| \line
|+--+-------+|     |+-----+-----+| \line
|            |     ||+-+-+|+-+-+|| \line
|            |     |||1|0|||1|1||| \line
|            |     ||+-+-+|+-+-+|| \line
|            |     |+-----+-----+| \line
+------------+-----+-------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 Some of the operations of Nial that operate on simple arrays are extended to arbitrarily nested arrays by being applied to the atoms at the deepest level.  These are called \i pervasive\plain\fs20\cf1\cb1  operations.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00a6}
{\up $}{\footnote\pard\plain{\up $} libpath}
{\up #}{\footnote\pard\plain{\up #} 2B9J0I3}
\pard\keepn\sb95 \b\fs25 libpath\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} libpath;system variable, libpath}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system variable\plain\fs20\cf1\cb1 {\v system variable}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Libpath := Paths    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 library\plain\fs20\cf1\cb1 {\v 2B9L0GD}\line

\par The variable \i Libpath\plain\fs20\cf1\cb1  is used by the operation \i library\plain\fs20\cf1\cb1  as a list of paths to directories that are to be checked for the definition file named in the \i library\plain\fs20\cf1\cb1  argument.  The directories defined by \i Libpath\plain\fs20\cf1\cb1  are searched before the system dependent library directories.  
\par \pard\keep\sb95 \f1\fs16      Libpath := ['mydefs','mylib\'5cnewdefs'];\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00a7}
{\up $}{\footnote\pard\plain{\up $} library}
{\up #}{\footnote\pard\plain{\up #} 2B9L0GD}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 library\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} library;system operation, library}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 library Nm   library Nm Sw    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 loaddefs\plain\fs20\cf1\cb1 {\v RIAXFW}, \uldb libpath\plain\fs20\cf1\cb1 {\v 2B9J0I3}, \uldb host\plain\fs20\cf1\cb1 {\v 25VK_53}, \uldb standard definitions\plain\fs20\cf1\cb1 {\v AXO3EN}\line

\par The operation \i library\plain\fs20\cf1\cb1  loads a definition from the Q'Nial library of definition files.  \i Nm\plain\fs20\cf1\cb1  is the name of a library file as a phrase or string.  The name is augmented with the path information for the library and loaded into the workspace using \i loaddefs\plain\fs20\cf1\cb1 .  \line

\par \i Sw\plain\fs20\cf1\cb1 , an optional argument, is either 0 (the default) or 1.  If \i Sw\plain\fs20\cf1\cb1  is 0, there is no display of the file as it is loaded.  If \i Sw\plain\fs20\cf1\cb1  is 1, the file is displayed as the file is read.  \line

\par \pard\sb95 Some of the programs in the library are grouped in definition files by function.  When such a file is specified, all the definitions in the file are loaded.  If it is desired to load only one operation from a definition file which contains several operations, it is necessary to edit the library file in order to isolate the desired operation in one file.  
\par \pard\keep\sb95 \f1\fs16      library "labeltable\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \i Library\plain\fs20\cf1\cb1  searches for files using paths that are provided in its definition.  Before searching for system defined directories, it searches in the directories named in the global variable \i Libpath\plain\fs20\cf1\cb1 , which is empty by default.  \line

\par To modify Libpath, either edit the standard definitions file \i defs.ndf\plain\fs20\cf1\cb1 , or assign it a value dynamically.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00a8}
{\up $}{\footnote\pard\plain{\up $} like}
{\up #}{\footnote\pard\plain{\up #} 40V8.J}
\pard\keepn\sb95 \b\fs25 like\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} like;set-like operation, like}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul set-like operation\plain\fs20\cf1\cb1 {\v set-like operation}
\par \pard\sb95 \b Properties:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}, \uldb predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A like B   like A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 allin\plain\fs20\cf1\cb1 {\v 5J2S.RC}, \uldb diverse\plain\fs20\cf1\cb1 {\v 19T6FZO}, \uldb in\plain\fs20\cf1\cb1 {\v RJ2SC2}, \uldb notin\plain\fs20\cf1\cb1 {\v 7KLHCD}\line

\par The operation \i like\plain\fs20\cf1\cb1  compares two arrays \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  and returns \i true\plain\fs20\cf1\cb1  if all the items of \i A\plain\fs20\cf1\cb1  are items of \i B\plain\fs20\cf1\cb1  and vice versa.  Otherwise it returns \i false\plain\fs20\cf1\cb1 .  The operation \i like\plain\fs20\cf1\cb1  corresponds to set equality at the first level of nesting.  
\par \pard\keep\sb95 \f1\fs16      2 3 like 3 2 2 3 2 \line
l \line
     2 3 like 3 2 4 \line
o \line
     'hello world' like 'whole door' \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      like IS OPERATION A B \{\- (A allin B) and (B allin A)\'7d\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00a9}
{\up $}{\footnote\pard\plain{\up $} link}
{\up #}{\footnote\pard\plain{\up #} QD77W5}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 link\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} construction operation, link;link}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul construction operation\plain\fs20\cf1\cb1 {\v construction operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 reductive\plain\fs20\cf1\cb1 {\v 7GGROL}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 link A   A link B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 catenate\plain\fs20\cf1\cb1 {\v BNUIZP}, \uldb laminate\plain\fs20\cf1\cb1 {\v M19KO1}, \uldb hitch\plain\fs20\cf1\cb1 {\v TNRGTN}, \uldb list\plain\fs20\cf1\cb1 {\v 40V8DY}, \uldb append\plain\fs20\cf1\cb1 {\v GFMD1P}, \uldb content\plain\fs20\cf1\cb1 {\v 11UQ9BC}, \uldb cull\plain\fs20\cf1\cb1 {\v 40MD_Q}\line

\par The operation \i link\plain\fs20\cf1\cb1  returns the list of the items of the items of its argument.  If it is applied to a pair of arrays \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1 , the result is the items of \i A\plain\fs20\cf1\cb1  followed by the items of \i B\plain\fs20\cf1\cb1 .  \line

\par If link is applied to an arbitrary array \i A\plain\fs20\cf1\cb1 , the items of the first item of \i A\plain\fs20\cf1\cb1  are followed by the items of the second item of \i A\plain\fs20\cf1\cb1 , etc.  \line

\par \pard\sb95 If \i A\plain\fs20\cf1\cb1  is empty, the result is \i Null\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  is not empty but there are no items in all the items of \i A\plain\fs20\cf1\cb1 , the result is also \i Null\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      2 3 5 4 7 2 link 2 4 6 8 \line
2 3 5 4 7 2 2 4 6 8 \line
 \line
     link 'hen' 'hello' 'eh' \line
henhelloeh\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows that the link of two lists of length 6 and 4 is a list of length 10.  The second example illustrates the linking of three strings.  \line

\par \i Link\plain\fs20\cf1\cb1  is similar to a set-union operation, although it does not remove duplicates in the representation.  The composition of \i cull\plain\fs20\cf1\cb1  with \i link\plain\fs20\cf1\cb1  may be more appropriate as a union operation.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    link A = link list A \line
   link A = list link A \line
   link A = EACH list link A \line
   tally link A = sum EACH tally A \line
   link solitary A = list A \line
   link Null = Null \line
   link EACH link A = link link A \line
   cart link A = EACH link cart EACH cart A \line
   EACH f link A = link EACH EACH f A \line
   simple A ==> link A = list A \line
   and EACH simple A ==> content A = link A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00aa}
{\up $}{\footnote\pard\plain{\up $} list}
{\up #}{\footnote\pard\plain{\up #} 40V8DY}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 list\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} list;reshaping operation, list}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul reshaping operation\plain\fs20\cf1\cb1 {\v reshaping operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 list A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 reshape\plain\fs20\cf1\cb1 {\v 3I4D_MA}, \uldb link\plain\fs20\cf1\cb1 {\v QD77W5}\line

\par The operation \i list\plain\fs20\cf1\cb1  returns the list of the items of \i A\plain\fs20\cf1\cb1  in row major order.  
\par \pard\keep\sb95 \f1\fs16      A := 2 3 4 reshape count 24 \line
1  2  3  4   13 14 15 16 \line
5  6  7  8   17 18 19 20 \line
9 10 11 12   21 22 23 24 \line
 \line
     list A \line
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \line
24 \line
 \line
     set "diagram; list "abc \line
+---+ \line
|abc| \line
+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows row major order for a table.  The second example shows that the list of an atom is the solitary holding the atom.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      list IS OPERATION A \{\- tally A reshape A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape list A = tally A \line
   list list A = list A \line
   list single A = solitary A \line
   EACH f list A = list EACH f A \line
   empty A ==> list A = Null \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ab}
{\up $}{\footnote\pard\plain{\up $} ln}
{\up #}{\footnote\pard\plain{\up #} RJ2SF2}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 ln\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} ln;scientific operation, ln}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 ln A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 exp\plain\fs20\cf1\cb1 {\v 1_E6ULF}, \uldb log\plain\fs20\cf1\cb1 {\v 1_E71C_}\line

\par The operation \i ln\plain\fs20\cf1\cb1  implements the natural logarithm function of mathematics.  It produces the following results when applied to atoms of the six types: 
\par 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 natural logarithm of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 natural logarithm of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 real natural logarithm if A > 0.0; ?ln if A <= 0.0 \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?ln \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?ln \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      ln  l  2  3.5   `a  "abc  ??error \line
0. 0.693147 1.25276 ?ln ?ln ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A > 0 ==> exp ln A = A   (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ac}
{\up $}{\footnote\pard\plain{\up $} load}
{\up #}{\footnote\pard\plain{\up #} QD7_IY}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 load\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} load;system operation, load}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 load Wsname    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 save\plain\fs20\cf1\cb1 {\v 25VUZ7O}, \uldb loaddefs\plain\fs20\cf1\cb1 {\v RIAXFW}, \uldb library\plain\fs20\cf1\cb1 {\v 2B9L0GD}, \uldb restart\plain\fs20\cf1\cb1 {\v 3I4P_OP}, \uldb latent\plain\fs20\cf1\cb1 {\v 4YEDEP}, \uldb continue\plain\fs20\cf1\cb1 {\v 1FW5IX}\line

\par The operation \i load\plain\fs20\cf1\cb1  is used to retrieve the saved workspace named by the phrase or string \i Wsname\plain\fs20\cf1\cb1 .  The convention in Q'Nial is to save workspaces with a file name extension of the form \i .nws\plain\fs20\cf1\cb1  to make it easy to identify workspace files in the file system.  When saving or loading a workspace, the extension may be omitted.  \line

\par \pard\sb95 The effect of loading a workspace is to replace the current workspace with the saved one.  To keep the contents of the current workspace, \i save\plain\fs20\cf1\cb1  should be used prior to doing a \i load\plain\fs20\cf1\cb1 .  \line

\par The operation \i load\plain\fs20\cf1\cb1  may be used within a defined expression or operation.  However, in such a use, it interrupts the execution of the operation or expression and does the load as though the operation were entered at top level.  \line

\par If a workspace contains an expression with the name \i Latent\plain\fs20\cf1\cb1 , \i load\plain\fs20\cf1\cb1  executes \i Latent\plain\fs20\cf1\cb1  when the load is complete.  This mechanism can be used to have the load of a workspace automatically begin an application or to chain execution of workspaces.  \line

\par \pard\sb95 There is no mechanism to obtain individual objects saved in a workspace.  
\par \pard\keep\sb95 \f1\fs16      load "mywork\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ad}
{\up $}{\footnote\pard\plain{\up $} loaddefs}
{\up #}{\footnote\pard\plain{\up #} RIAXFW}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 loaddefs\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} loaddefs;system operation, loaddefs}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 loaddefs Deffilename   loaddefs Deffilename Mode    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 library\plain\fs20\cf1\cb1 {\v 2B9L0GD}, \uldb edit\plain\fs20\cf1\cb1 {\v 40O30Y}\line

\par The operation \i loaddefs\plain\fs20\cf1\cb1  is used to load Nial actions (definitions or expressions) from the file named by the phrase or string \i Deffilename\plain\fs20\cf1\cb1 .  The convention in Q'Nial is to name Nial definition files with a file name extension of the form \i .ndf\plain\fs20\cf1\cb1  to make it easy to identify such files in the file system.  \line

\par When loading a file with \i loaddefs\plain\fs20\cf1\cb1 , the file extension may be omitted.  The operation may have an optional second argument to specify the mode of loading.  If mode is 0 or if it is omitted, the actions are not displayed as they are processed.  If it is 1, the actions are displayed.  \line

\par \pard\sb95 The file of actions consists of groups of lines that are treated as a unit.  These lines are separated by a blank line.  If the first character in the first line of the group is \i #\plain\fs20\cf1\cb1 , the group is a \i remark\plain\fs20\cf1\cb1  and is not processed.  \line

\par Several lines, up to a blank line, are treated as one long line.  No blank spaces are inserted between the end of one line and the beginning of another.  Thus, care should be taken to ensure that identifiers are not joined together.  \line

\par \pard\sb95 If a syntax error is detected when a definition is being loaded, the definition is not installed.  The absence of the erroneous definition may cause subsequent definitions in the file to fail also.  If any errors are detected, the number of errors is displayed when \i loaddefs\plain\fs20\cf1\cb1  ends.  Only the first syntax error found in each action is reported.  \line

\par The backslash character, \i  \'5c \plain\fs20\cf1\cb1 , which is used to continue a line of a definition in immediate mode, must not be inserted at the end of lines in a definition file.  \line

\par \pard\sb95 The tab characters, if they exist in a definition file, are treated as though they are space characters.  Since some editor programs insert tabs automatically, the display of the file on input may be different from the display using the editor.  \line

\par A definition file may contain uses of \i loaddefs\plain\fs20\cf1\cb1 .  For a large application with many definition files, it is a good idea to have one file which can construct the application by using \i loaddefs\plain\fs20\cf1\cb1  to bring in the other files in an appropriate order.  \i Loaddefs\plain\fs20\cf1\cb1  can also be used to execute a script of Nial expressions.  This feature is convenient when simulating a Q'Nial session and capturing its output in a log file.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ae}
{\up $}{\footnote\pard\plain{\up $} local environment}
{\up #}{\footnote\pard\plain{\up #} BN.OFR}
\pard\keepn\sb95 \b\fs25 local environment\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, local environment;local environment}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 global environment\plain\fs20\cf1\cb1 {\v 0.KANS}, \uldb scope of a variable\plain\fs20\cf1\cb1 {\v 42GY_XT}\line

\par A \b local environment\plain\fs20\cf1\cb1  is a collection of associations that are known within a limited section of program text.  These limited sections are formed by blocks, operation-forms and transformer-forms as discussed in the relevant sections below.  A name that has a local association in one of these forms is said to have local scope.  \line

\par Program fragments in which local variables are being assigned can be nested, so that one local scope surrounds another.  A local association is not visible outside the construct in which it is defined; and a name with local scope can hide associations that the name has in surrounding scopes.  \line

\par \pard\sb95 At any point in a program fragment, there is a current environment consisting of all names whose associations are visible.  It includes the names having local scope in the program fragment being executed, names that are visible in the surrounding scopes and names that have global scope.  \line

\par In program text, the scope of all names is determined by the static structure of the program text.  The one exception is text that has the operation execute applied to it under program control.  \line

\par \pard\sb95 In a local environment, a variable identifier can be chosen the same as a predefined or user-defined global definition name.  Such a choice makes the global use of the name unavailable in the local context.  \line

\par In any context, an identifier can name only one of: a variable, an array- expression, an operation-expression, or a transformer-expression.  During one session, the role of a name, i.e.  the class of syntactic object it names, cannot be changed.  \line

\par If a block is used as a primary-expression, the local environment created by a block is determined by the block itself.  If it is the body of an operation-form, the local environment includes the formal parameter names of the operation-form as variables.  \line

\par \pard\sb95 A block delimits a local environment.  It allows new uses of names which do not interfere with uses of those names outside the block.  For example, within a block, a predefined operation name can be redefined and used for a different purpose.  Only the reserved words of Q'Nial cannot be reused in this fashion.  Definitions that appear within the block have local scope.  That is, the definitions can be referenced only in the body of the block.  Variables assigned within the block may or may not have local scope, depending on the appearance of a local and/or a nonlocal declaration.  If there is no declaration, all assigned variables have local scope.  Declaring some variables as local does not change the effect on undeclared variables that are used on the left of assignment.  They are automatically localized.  \line

\par \pard\sb95 If a nonlocal declaration is used, an assigned name that is on the nonlocal list is sought in surrounding scopes.  If the name is not found, a variable is created in the global environment.  \line

\par During the parse of the assign-expression appearing in a block, each name on the variable list is sought in the local environment.  If the name exists in the local environment, the assignment affects the local association.  If a name does not exist in the local environment and no reference has been made to a nonlocal variable with the same name, a local variable is created in the block.  An assign-expression parsed in the global environment creates a global variable if a variable with that name does not already exist.  \line

\par \pard\sb95 An operation-form defines a local environment.  The formal parameter names are names of local variables.  If the body of the operation form is a block, the local environment of the block is extended to include the formal parameters.  When the operation is applied, the formal parameter names are assigned from the value of the actual argument.  If there is only one formal parameter, the actual argument is assigned to it as a whole; otherwise, the items of the actual argument are assigned to the formal parameters in corresponding order.  If there is a length mismatch between the list of formal parameter names and the values of the actual argument, the fault \i ?op_parameter\plain\fs20\cf1\cb1  is returned.  \line

\par \pard\sb95 The value of the application of the operation is the value of the body of the operation-form, which is evaluated with the local variables in the parameter list assigned as described above.  In determining the association for a name that appears in the body of an operation form, Q'Nial looks for the name in the local environment.  If the name is not found locally, the name is sought in surrounding environments until it is found or until the global environment is searched.  If it is not found, a fault \i ?unknown identifier:\plain\fs20\cf1\cb1  is given when the operation-form is analyzed (parsed).  \line

\par \pard\sb95 Operation-forms are most frequently used in definitions where they are given an associated name.  However, an operation-form can appear directly in an expression provided it is enclosed in parentheses.  In this usage, it can be an argument to a transformer name or can be applied to an array argument.  \line

\par The operation \i execute\plain\fs20\cf1\cb1  can be used within the execution of a block to make an assignment to variables or to invoke the definition mechanism.  If \i execute\plain\fs20\cf1\cb1  is used to make a new definition or to create a new variable, the resulting variable or definition is placed in the global environment.  However, if the block has local variables or local definitions, execute can be used to change a local version dynamically.  A similar situation occurs with dynamic alteration of variables using \i assign\plain\fs20\cf1\cb1 .  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00af}
{\up $}{\footnote\pard\plain{\up $} log}
{\up #}{\footnote\pard\plain{\up #} 1_E71C_}
\pard\keepn\sb95 \b\fs25 log\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} log;scientific operation, log}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 log A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 power\plain\fs20\cf1\cb1 {\v TVXJVX}, \uldb ln\plain\fs20\cf1\cb1 {\v RJ2SF2}\line

\par The operation \i log\plain\fs20\cf1\cb1  implements the base 10 logarithm function of mathematics.  It produces the following results when applied to atoms of the six types: 
\par 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 base 10 logarithm of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 base 10 logarithm of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 real base 10 logarithm if A > 0.0; ?log if A <= 0.0 \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?log \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?log \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      log  l  2  3.5  `a  "abc  ??error \line
0. 0.30103 0.544068 ?log ?log ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A > 0 ==> 10. power log A = A (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00b0}
{\up $}{\footnote\pard\plain{\up $} log file}
{\up #}{\footnote\pard\plain{\up #} 0G8259}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 log file\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} feature, log file;log file}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul feature\plain\fs20\cf1\cb1 {\v feature}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 setlogname\plain\fs20\cf1\cb1 {\v H7O7NO}\line

\par Q'Nial provides a facility to record the actions in a session in a text file.  The default name for the log file is \i auto.nlg\plain\fs20\cf1\cb1 .  Logging is initiated by: 
\par \pard\keep\sb95 \f1\fs16      set "log \line
nolog\plain\fs20\cf1\cb1 \line

\par \pard\sb95 Logging is ended by: 
\par \pard\keep\sb95 \f1\fs16      set "nolog \line
log\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The log file name can be changed using: 
\par \pard\keep\sb95 \f1\fs16      setlogname "newname \line
auto.nlg\plain\fs20\cf1\cb1 \line

\par \pard\sb95 A log file is opened and closed on each usage by the internal logging routine.  As a result, the log file is always available if the session is terminated unexpectedly.  If a file with the name of the log file exists when \i set "log\plain\fs20\cf1\cb1  is executed, the logging information is appended at the end.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00b1}
{\up $}{\footnote\pard\plain{\up $} lower}
{\up #}{\footnote\pard\plain{\up #} TRXJVX}
\pard\keepn\sb95 \b\fs25 lower\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} lower;nesting restructuring operation, lower}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nesting restructuring operation\plain\fs20\cf1\cb1 {\v nesting restructuring operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 N lower A   lower N A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 raise\plain\fs20\cf1\cb1 {\v TXJ_9K}, \uldb mix\plain\fs20\cf1\cb1 {\v 1_E72_N}, \uldb blend\plain\fs20\cf1\cb1 {\v THU94J}, \uldb rank\plain\fs20\cf1\cb1 {\v QD.ZW5}\line

\par The operation \i lower\plain\fs20\cf1\cb1  is used to partition an array \i A\plain\fs20\cf1\cb1  along its axes by indicating that the last \i N\plain\fs20\cf1\cb1  axes are to become axes of the items of the result.  The remaining axes become the axes of the result.  N must be an integer in the range from 0 to \i valence A\plain\fs20\cf1\cb1 .  The result is an array of shape given by dropping the last \i N\plain\fs20\cf1\cb1  items of \i shape A\plain\fs20\cf1\cb1 .  The items of the result have the shape given by taking the \i last N\plain\fs20\cf1\cb1  items of \i shape A\plain\fs20\cf1\cb1 .  Thus, the \i 1 lower\plain\fs20\cf1\cb1  of an array of shape 3 4 2 is a 3 by 4 table of pairs.  The \i 2 lower\plain\fs20\cf1\cb1  of the same array is a triple of 4 by 2 tables.  
\par \pard\keep\sb95 \f1\fs16      A := 3 4 2 reshape 'ABCDEFGHIJKLMNOPQRSTUVWX' \line
AB  IJ  QR \line
CD  KL  ST \line
EF  MN  UV \line
GH  OP  WX \line
     1 lower A \line
+--+--+--+--+ \line
|AB|CD|EF|GH| \line
+--+--+--+--+ \line
|IJ|KL|MN|OP| \line
+--+--+--+--+ \line
|QR|ST|UV|WX| \line
+--+--+--+--+ \line
     2 lower A \line
+--+--+--+ \line
|AB|IJ|QR| \line
|CD|KL|ST| \line
|EF|MN|UV| \line
|GH|OP|WX| \line
+--+--+--+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      lower IS OPERATION A \{\- valence A - N raise A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    N a nonnegative integer <= valence A and not empty A ==> shape (N lower A) = opp N drop shape A \line
   shape first (N drop A) = opp N take shape A ==> mix (N lower A) = A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00b2}
{\up $}{\footnote\pard\plain{\up $} lt}
{\up #}{\footnote\pard\plain{\up #} RJ2SF8}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 lt\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} comparison operation, lt;lt}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul comparison operation\plain\fs20\cf1\cb1 {\v comparison operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A lt B   A < B   lt A B   < A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 lte\plain\fs20\cf1\cb1 {\v 1ZNC14K}, \uldb gt\plain\fs20\cf1\cb1 {\v RJ2SA8}, \uldb gte\plain\fs20\cf1\cb1 {\v 1ZNBW4K}, \uldb match\plain\fs20\cf1\cb1 {\v TSJGTN}, \uldb mate\plain\fs20\cf1\cb1 {\v 25VOZ5O}, \uldb max\plain\fs20\cf1\cb1 {\v 1_E725N}, \uldb sort\plain\fs20\cf1\cb1 {\v 1CMJ_GN}\line

\par The operation \i lt\plain\fs20\cf1\cb1  compares two atoms \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  with the \i less than\plain\fs20\cf1\cb1  relation, returning \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is less than \i B\plain\fs20\cf1\cb1  and \i false\plain\fs20\cf1\cb1  otherwise.  Symbol \i <\plain\fs20\cf1\cb1  is a synonym for \i lt\plain\fs20\cf1\cb1 .  \line

\par The atoms in Nial are organized as a lattice using \i <=\plain\fs20\cf1\cb1  for the ordering.  The numeric atoms are comparable across types but literal atoms are not comparable with numeric atoms.  The literal types are not comparable across types.  A comparison between incomparable objects results in \i false\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      R := l 2 2.5 `a "abc ??error \line
l 2 2.5 a abc ?error \line
     R OUTER < R \line
ollooo \line
oolooo \line
oooooo \line
oooooo \line
oooooo \line
oooooo \line
 \line
     'apple' < 'above' \line
ooolo \line
 \line
     "apple < "above \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The use of \i OUTER <\plain\fs20\cf1\cb1  shows the comparisons between various atom types.  The last two examples show the difference between comparing two strings, where the operation is distributed by its pervasive property; and comparing the corresponding phrases.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      lt IS OPERATION A B ( ( A lte B ) and not ( A mate B ) ) \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00b3}
{\up $}{\footnote\pard\plain{\up $} lte}
{\up #}{\footnote\pard\plain{\up #} 1ZNC14K}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 lte\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} comparison operation, lte;lte}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul comparison operation\plain\fs20\cf1\cb1 {\v comparison operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A lte B   A <= B   lte A B   <= A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 lt\plain\fs20\cf1\cb1 {\v RJ2SF8}, \uldb gt\plain\fs20\cf1\cb1 {\v RJ2SA8}, \uldb gte\plain\fs20\cf1\cb1 {\v 1ZNBW4K}, \uldb match\plain\fs20\cf1\cb1 {\v TSJGTN}, \uldb mate\plain\fs20\cf1\cb1 {\v 25VOZ5O}, \uldb max\plain\fs20\cf1\cb1 {\v 1_E725N}, \uldb sort\plain\fs20\cf1\cb1 {\v 1CMJ_GN}\line

\par The operation \i lte\plain\fs20\cf1\cb1  compares two atoms \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  with the \i less than or equal\plain\fs20\cf1\cb1  relation, returning \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is less than \i B\plain\fs20\cf1\cb1  and \i false\plain\fs20\cf1\cb1  otherwise.  The symbol \i <=\plain\fs20\cf1\cb1  is a synonym for \i lte\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 The atoms in Nial are organized as a lattice using \i <=\plain\fs20\cf1\cb1  for the ordering.  The numeric atoms are comparable across types but numeric and literal atoms are incomparable.  The literal types are not comparable across types.  A comparison between incomparable objects results in \i false\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      R := l 2 2.5 `a "abc ??error \line
l 2 2.5 a abc ?error \line
 \line
     R OUTER <= R \line
lllooo \line
ollooo \line
oolooo \line
oooloo \line
oooolo \line
oooool \line
 \line
     'apple' <= 'above' \line
loolo \line
 \line
     "apple < "above \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The use of OUTER \i <=\plain\fs20\cf1\cb1  shows the comparisons between various atom types.  The last two examples show the difference between comparing two strings, where the operation is distributed by its pervasive property; and comparing the corresponding phrases.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00b4}
{\up $}{\footnote\pard\plain{\up $} match}
{\up #}{\footnote\pard\plain{\up #} TSJGTN}
\pard\keepn\sb95 \b\fs25 match\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} comparison operation, match;match}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul comparison operation\plain\fs20\cf1\cb1 {\v comparison operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A match B   match A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 mate\plain\fs20\cf1\cb1 {\v 25VOZ5O}, \uldb gt\plain\fs20\cf1\cb1 {\v RJ2SA8}, \uldb gte\plain\fs20\cf1\cb1 {\v 1ZNBW4K}, \uldb lt\plain\fs20\cf1\cb1 {\v RJ2SF8}, \uldb lte\plain\fs20\cf1\cb1 {\v 1ZNC14K}\line

\par The operation \i match\plain\fs20\cf1\cb1  compares two atoms \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  for exact equality, returning \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is equal to \i B\plain\fs20\cf1\cb1  and \i false\plain\fs20\cf1\cb1  otherwise.  \i Match\plain\fs20\cf1\cb1  cannot be used to determine the equality of atoms of different numeric or literal type, as when comparing the real number 3.0 with the integer 3.  
\par \pard\keep\sb95 \f1\fs16      3 match 3 \line
l \line
 \line
     3.0 match 3 \line
o \line
 \line
     "o match `o \line
o \line
 \line
     1.0 match l 1 1.0 \line
ool \line
 \line
     `  match 'a list of letters' \line
olooooloolooooooo \line
 \line
     1 match tell 2 3 \line
+--+--+--+ \line
|oo|ol|oo| \line
+--+--+--+ \line
|lo|ll|lo| \line
+--+--+--+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The second last example shows that the binary pervasive extension of \i match\plain\fs20\cf1\cb1  allows a lists of atoms to be compared for a value, returning a bitstring of results.  The last example shows where in the structure of tell 2 3 a 1 is held.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00b5}
{\up $}{\footnote\pard\plain{\up $} mate}
{\up #}{\footnote\pard\plain{\up #} 25VOZ5O}
\pard\keepn\sb95 \b\fs25 mate\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} comparison operation, mate;mate}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul comparison operation\plain\fs20\cf1\cb1 {\v comparison operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A mate B   mate A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 match\plain\fs20\cf1\cb1 {\v TSJGTN}, \uldb gt\plain\fs20\cf1\cb1 {\v RJ2SA8}, \uldb gte\plain\fs20\cf1\cb1 {\v 1ZNBW4K}, \uldb lt\plain\fs20\cf1\cb1 {\v RJ2SF8}, \uldb lte\plain\fs20\cf1\cb1 {\v 1ZNC14K}\line

\par The operation \i mate\plain\fs20\cf1\cb1  compares two atoms \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  for equality with type coercion, returning \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is equal to or can be coerced to \i B\plain\fs20\cf1\cb1  as a number; and \i false\plain\fs20\cf1\cb1  otherwise.  \i Mate\plain\fs20\cf1\cb1  is used to determine the equality of atoms of different numeric type, as when comparing the real number 3.0 with the integer 3.  It cannot be used to determine equality of literal types.  
\par \pard\keep\sb95 \f1\fs16      3 mate 3 \line
l \line
 \line
     3.0 mate 3 \line
l \line
 \line
     "o mate `o \line
o \line
 \line
     1.0 mate l 1 1.0 \line
lll\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The last example shows that the binary pervasive extension of \i mate\plain\fs20\cf1\cb1  allows a lists of atoms to be compared for a value, returning a bitstring of results.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      mate IS OPERATION A B \{\- (A lte B) and (B lte A) \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00b6}
{\up $}{\footnote\pard\plain{\up $} max}
{\up #}{\footnote\pard\plain{\up #} 1_E725N}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 max\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} comparison operation, max;max}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul comparison operation\plain\fs20\cf1\cb1 {\v comparison operation}
\par \pard\sb95 \b Properties:  \uldb \plain\uldb\fs20\cf1\cb1 multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}, \uldb reductive\plain\fs20\cf1\cb1 {\v 7GGROL}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 max A   A max B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 min\plain\fs20\cf1\cb1 {\v 1_E72_D}, \uldb gte\plain\fs20\cf1\cb1 {\v 1ZNBW4K}, \uldb sort\plain\fs20\cf1\cb1 {\v 1CMJ_GN}\line

\par The operation \i max\plain\fs20\cf1\cb1 , when applied to a simple array \i A\plain\fs20\cf1\cb1 , finds the least atom that is greater than or equal to all the items.  If the atoms of \i A\plain\fs20\cf1\cb1  are all positive numbers, for example, \i max A\plain\fs20\cf1\cb1  returns the biggest.  If the items are not comparable, the result is the fault \i ?I\plain\fs20\cf1\cb1 , the atom in the lattice of Nial atoms that is greater than or equal to all other atoms (the zenith).  If A is empty, the result is the fault \i ?O\plain\fs20\cf1\cb1 , the atom that is less than or equal to all other atoms (the nadir).  \line

\par \pard\sb95 \i Max\plain\fs20\cf1\cb1  is extended to arbitrary arrays by its multi pervasive behaviour.  It is a reductive operation in that it reduces a simple array to a single atom.  Applied to a pair of simple arrays, it produces a simple array with the corresponding items compared.  \line

\par If the items of \i A\plain\fs20\cf1\cb1  are all numeric type, they are comparable.  The result is the highest numeric type represented in the array, where boolean is the lowest numeric type and real number is the highest.  
\par \pard\keep\sb95 \f1\fs16      max 3 45 23 18 3.5 \line
45. \line
     max 3 "abc \line
?I \line
     max "abc "def "c \line
def \line
     max 'apples' 'orange' \line
orpngs\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows that \i max\plain\fs20\cf1\cb1  of a list of numbers of different type is the maximum number, coerced to the highest type.  The second shows that the integer 3 and the phrase "abc" are incomparable and the result is the fault ?I.  The third example shows that phrases are directly comparable.  The last shows that strings are compared on a character by character basis.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A max B = B max A \line
   max EACH max A =f= max link A \line
   atomic A ==> max B lte A = and (B EACHLEFT lte A) \line
   max Null = ??O \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00b7}
{\up $}{\footnote\pard\plain{\up $} min}
{\up #}{\footnote\pard\plain{\up #} 1_E72_D}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 min\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} comparison operation, min;min}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul comparison operation\plain\fs20\cf1\cb1 {\v comparison operation}
\par \pard\sb95 \b Properties:  \uldb \plain\uldb\fs20\cf1\cb1 multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}, \uldb reductive\plain\fs20\cf1\cb1 {\v 7GGROL}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 min A   A min B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 max\plain\fs20\cf1\cb1 {\v 1_E725N}, \uldb lte\plain\fs20\cf1\cb1 {\v 1ZNC14K}, \uldb sort\plain\fs20\cf1\cb1 {\v 1CMJ_GN}\line

\par The operation \i min\plain\fs20\cf1\cb1 , when applied to a simple array \i A\plain\fs20\cf1\cb1 , finds the greatest atom that is less than or equal to all the items.  If the atoms of \i A\plain\fs20\cf1\cb1  are all positive numbers, for example, \i min A\plain\fs20\cf1\cb1  returns the smallest number.  If the items are not comparable, the result is the fault \i ?O\plain\fs20\cf1\cb1 , the atom in the lattice of Nial atoms that is less than or equal to all other atoms (the nadir).  If \i A\plain\fs20\cf1\cb1  is empty, the result is the fault \i ?I\plain\fs20\cf1\cb1 , the atom that is greater than or equal to all other atoms (the zenith).  \line

\par \pard\sb95 \i Min\plain\fs20\cf1\cb1  is extended to arbitrary arrays by its multi pervasive behaviour.  It is a reductive operation in that it reduces a simple array to a single atom.  Applied to a pair of simple arrays, it produces a simple array with the corresponding items compared.  \line

\par If the items of \i A\plain\fs20\cf1\cb1  are all numeric type, they are comparable.  The result is the highest numeric type represented in the array, where boolean is the lowest numeric type and real number is the highest.  
\par \pard\keep\sb95 \f1\fs16      min 3 45 23 18 3.5 \line
3. \line
     min 3 "abc \line
?O \line
     min "abc "def "c \line
abc \line
     min 'apples' 'orange' \line
apalee\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows that \i min\plain\fs20\cf1\cb1  of a list of numbers of different type is the minimum number, coerced to the highest type.  The second shows that the integer 3 and the phrase "abc" are incomparable and the result is the fault \i ?I\plain\fs20\cf1\cb1 .  The third example shows that phrases are directly comparable.  The last shows that strings are compared on a character by character basis.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A min B = B min A \line
   min EACH min A = min link A \line
   atomic A ==> A lte min B = and (A EACHRIGHT lte B) \line
   min Null = ??I \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00b8}
{\up $}{\footnote\pard\plain{\up $} minus}
{\up #}{\footnote\pard\plain{\up #} 7JFBOI}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 minus\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, minus;minus}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A minus B   A - B   minus A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 plus\plain\fs20\cf1\cb1 {\v 1CMG0JM}, \uldb sum\plain\fs20\cf1\cb1 {\v 1_E78IC}, \uldb opposite\plain\fs20\cf1\cb1 {\v 18Y3XQ}\line

\par The operation \i minus\plain\fs20\cf1\cb1  returns the result of subtracting two numeric atoms.  It coerces the type of the atoms to be the higher type, if they differ; or to integer, if both are boolean.  The result is of the type of the coerced arguments.  \line

\par The symbol \i -\plain\fs20\cf1\cb1  is a synonym for \i minus\plain\fs20\cf1\cb1 .  Care must be taken when using this symbol because it also is used to form negative constants and the latter use has higher priority.  Thus, 
\par \pard\keep\sb95 \f1\fs16      A := 10; \line
     A - 1 \line
9\plain\fs20\cf1\cb1 \line

\par \pard\sb95 does a subtraction, but 
\par \pard\keep\sb95 \f1\fs16      A -1 \line
10 -1\plain\fs20\cf1\cb1 \line

\par \pard\sb95 forms a pair.  \line

\par If one argument is numeric and the other is a fault or if both arguments are the same fault, the answer is the fault.  In all other cases when one or more of the arguments is not numeric, the result is the arithmetic fault \i ?A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      R gets l 2 2.5 `a "abc ??error \line
l 2 2.5 a abc ?error \line
 \line
     R OUTER minus R \line
     0      -1    -1.5   ?A  ?A  ?error \line
     1       0    -0.5   ?A  ?A  ?error \line
   1.5     0.5      0.   ?A  ?A  ?error \line
?A      ?A      ?A       ?A  ?A  ?A \line
?A      ?A      ?A       ?A  ?A  ?A \line
?error  ?error  ?error   ?A  ?A  ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The above example illustrates all combinations of atom types for the two arguments to \i minus\plain\fs20\cf1\cb1 .  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    0 minus A = opposite A \line
   A minus B = A plus opposite B \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00b9}
{\up $}{\footnote\pard\plain{\up $} mix}
{\up #}{\footnote\pard\plain{\up #} 1_E72_N}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 mix\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} mix;nesting restructuring operation, mix}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nesting restructuring operation\plain\fs20\cf1\cb1 {\v nesting restructuring operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 mix A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 blend\plain\fs20\cf1\cb1 {\v THU94J}, \uldb link\plain\fs20\cf1\cb1 {\v QD77W5}, \uldb rows\plain\fs20\cf1\cb1 {\v 1CMI_LM}, \uldb rank\plain\fs20\cf1\cb1 {\v QD.ZW5}\line

\par The operation \i mix\plain\fs20\cf1\cb1  is intended to be used on an array \i A\plain\fs20\cf1\cb1  with items which are all the same shape.  In this case, the shape of the result is formed by the shape of \i A\plain\fs20\cf1\cb1  linked with the shape of the items.  The list of items of the result is the link of the items of \i A\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  does not have equally shaped items, the fault \i ?conform\plain\fs20\cf1\cb1  is returned.  
\par \pard\keep\sb95 \f1\fs16      mix (2 3) (4 5) (6 7) \line
2 3 \line
4 5 \line
6 7 \line
 \line
     A := (tell 2 3)(count 2 3) \line
+-------------+-------------+ \line
|+---+---+---+|+---+---+---+| \line
||0 0|0 1|0 2|||1 1|1 2|1 3|| \line
|+---+---+---+|+---+---+---+| \line
||1 0|1 1|1 2|||2 1|2 2|2 3|| \line
|+---+---+---+|+---+---+---+| \line
+-------------+-------------+ \line
 \line
     mix A \line
+---+---+---+  +---+---+---+ \line
|0 0|0 1|0 2|  |1 1|1 2|1 3| \line
+---+---+---+  +---+---+---+ \line
|1 0|1 1|1 2|  |2 1|2 2|2 3| \line
+---+---+---+  +---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows that the result of mixing a triple of pairs is a 3 by 2 table.  The second example shows that mixing a pair of 2 by 3 tables is a 2 by 2 by 3 array, with the tables as the planes of the array.  \line

\par The operation \i mix\plain\fs20\cf1\cb1  is the left inverse of the operations \i rows\plain\fs20\cf1\cb1  and \i raise\plain\fs20\cf1\cb1  for nonempty arrays.  It is often used to transform from a \i list of lists\plain\fs20\cf1\cb1  view of data to a table view of data.  In practice, transformations between the two representations on large arrays should be avoided in Q'Nial since considerable work is involved in doing the restructuring.  \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      mix IS OPERATION A \{\-  \line
        IF empty A THEN  \line
           shape A append 0 reshape A  \line
        ELSEIF not equal EACH shape A THEN  \line
           ??conform  \line
        ELSE  \line
           shape A link shape first A reshape link A  \line
        ENDIF \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    not empty A and equal EACH shape A ==> shape mix A = link (shape A)(shape first A) \line
   equal EACH shape A ==> list mix A = link A \line
   not empty A ==> mix rows A = A \line
   I in (axes A + 1) and not empty A ==> mix (I raise A) = A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ba}
{\up $}{\footnote\pard\plain{\up $} mod}
{\up #}{\footnote\pard\plain{\up #} 1_E72C0}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 mod\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, mod;mod}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A mod B   mod A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 quotient\plain\fs20\cf1\cb1 {\v KJKAFK}, \uldb ceiling\plain\fs20\cf1\cb1 {\v 5G__UQ}, \uldb floor\plain\fs20\cf1\cb1 {\v 7CICIH}\line

\par The operation \i mod\plain\fs20\cf1\cb1  returns the remainder of dividing integer \i A\plain\fs20\cf1\cb1  by integer \i B\plain\fs20\cf1\cb1 .  If the divisor \i B\plain\fs20\cf1\cb1  is zero, the result is \i A\plain\fs20\cf1\cb1 .  If it is negative, the result is the fault \i ?negative divisor\plain\fs20\cf1\cb1 .  \line

\par The operation \i mod\plain\fs20\cf1\cb1  coerces a boolean argument to an integer.  It produces a fault if either argument is not an integer or a boolean.  
\par \pard\keep\sb95 \f1\fs16      R gets l 2 2.5 `a "abc ??error \line
l 2 2.5 a abc ?error \line
     R OUTER mod R \line
     0       1  ?A      ?A  ?A  ?error \line
     0       0  ?A      ?A  ?A  ?error \line
?A      ?A      ?A      ?A  ?A  ?error \line
?A      ?A      ?A      ?A  ?A  ?A \line
?A      ?A      ?A      ?A  ?A  ?A \line
?error  ?error  ?error  ?A  ?A  ?error \line
 \line
     (5 mod 3)(-5 mod 3)(5 mod -3)(5 mod 0) \line
2 1 ?negative divisor 5\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example illustrates all combinations of atom types for the two arguments to \i mod\plain\fs20\cf1\cb1 .  \line

\par The remainder on division by a positive integer \i B\plain\fs20\cf1\cb1  is always a number between 0 and \i B - 1\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  is negative, the integer returned obeys the rule of modular arithmetic as described in the definition.  The result of \i A mod 0\plain\fs20\cf1\cb1  is \i A\plain\fs20\cf1\cb1  rather than a fault, since that is the preferred result in mathematics.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      mod IS OPERATION A B \{\- floor (A - (B * (A quotient B)) ) \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    isinteger A ==> A mod 0 = A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00bb}
{\up $}{\footnote\pard\plain{\up $} mold}
{\up #}{\footnote\pard\plain{\up #} QD8_TY}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 mold\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} mold;reshaping operation, mold}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul reshaping operation\plain\fs20\cf1\cb1 {\v reshaping operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A mold B   mold A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 take\plain\fs20\cf1\cb1 {\v 25VVYWO}\line

\par The operation \i mold\plain\fs20\cf1\cb1  is provided for backward compatibility with earlier versions of Nial.  The current definition is a synonym for \i take\plain\fs20\cf1\cb1 .  The previous definition was a reshaping operation that was almost always used on lists and \i take\plain\fs20\cf1\cb1  has the same effect as the previous definition on lists.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    mold is take \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00bc}
{\up $}{\footnote\pard\plain{\up $} multi pervasive}
{\up #}{\footnote\pard\plain{\up #} EEB.UV}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 multi pervasive\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} multi pervasive;operation property, multi pervasive}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul operation property\plain\fs20\cf1\cb1 {\v operation property}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 f A   f A B ... C    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}, \uldb binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}, \uldb pervasive\plain\fs20\cf1\cb1 {\v 4E_0R6}, \uldb reductive\plain\fs20\cf1\cb1 {\v 7GGROL}, \uldb eachall\plain\fs20\cf1\cb1 {\v LYL6P6}, \uldb reduce\plain\fs20\cf1\cb1 {\v 2.MYRUF}, \uldb pack\plain\fs20\cf1\cb1 {\v QD0ZL5}\line

\par Each operation \i f\plain\fs20\cf1\cb1  in this class reduces a simple array (an array of atoms) to an atom.  \line

\par A multi pervasive operation maps an array having items of identical structure to one with the same structure, applying the operation to the simple arrays formed from all the atoms in corresponding positions in the atoms.\line

\par \pard\sb95 There are six operations in this class. They are the \b reductive\plain\fs20\cf1\cb1  operations of arithmetic and logic.\line

\par If a multi pervasive operation is applied to an array that does not have items of the same shape, the effect is to build a conformable pair by replicating an atom or solitary item of the array to the common shape of the other items.  If two or more of the items have tally different from one and are of unequal shape, the fault \i ?conform\plain\fs20\cf1\cb1  is returned.  On a pair, a multi pervasive operation behaves the same way as a binary pervasive operation does.
\par \pard\keep\sb95 \f1\fs16      sum [3 4 5 6 , 5 , 7 8 9 10] = 15 17 19 21 \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The following table describes the multi pervasive operations.
\par  \trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 \b Operation \cell\pard \pard\intbl\sb95 Function  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 and \cell\pard \pard\intbl\sb95 logical "and" of a boolean array  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 max \cell\pard \pard\intbl\sb95 highest item in the array  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 min \cell\pard \pard\intbl\sb95 lowest item in the array  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 or \cell\pard \pard\intbl\sb95 logical "or" of a boolean array  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 product \cell\pard \pard\intbl\sb95 arithmetic product of an array of numbers  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 sum \cell\pard \pard\intbl\sb95 arithmetic sum of an array of numbers  \cell\intbl\row
\pard\sb95 \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    f A = EACHALL f A \line
   f A = EACH f pack A \line
   shape f A = shape pack A \line
   f A = REDUCE f A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00bd}
{\up $}{\footnote\pard\plain{\up $} nested definition}
{\up #}{\footnote\pard\plain{\up #} 1TSSBWU}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 nested definition\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, nested definition;nested definition}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 block\plain\fs20\cf1\cb1 {\v THUBTQ}, \uldb definition\plain\fs20\cf1\cb1 {\v K9LSXA}\line

\par A \b nested definition\plain\fs20\cf1\cb1  is one that appears in a definition sequence within a block.  Its name is a local definition name.  If the name is also used outside the block, the external meaning is not known in the block.  \line

\par Nested definitions can be used to encapsulate support definitions within a larger definition that is to be made available to other users.  This avoids cluttering up the name space with names that might interfere with the user's other work.  It is often easier to develop the large definition without encapsulation and package it in encapsulated form once the design is completed.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00be}
{\up $}{\footnote\pard\plain{\up $} next}
{\up #}{\footnote\pard\plain{\up #} 40X4IY}
\pard\keepn\sb95 \b\fs25 next\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} debugging command, next;next}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul debugging command\plain\fs20\cf1\cb1 {\v debugging command}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 next    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 debugging\plain\fs20\cf1\cb1 {\v PP0_XH}, \uldb break\plain\fs20\cf1\cb1 {\v 2V9T7BV}, \uldb resume\plain\fs20\cf1\cb1 {\v 1JE1SH6}, \uldb step\plain\fs20\cf1\cb1 {\v 1CMJB0J}, \uldb toend\plain\fs20\cf1\cb1 {\v 7QL9H0}, \uldb stepin\plain\fs20\cf1\cb1 {\v YJBNWZ}\line

\par The command \i next\plain\fs20\cf1\cb1  is used in debugging a definition that has been suspended using Break or <Ctrl B>.  The effect of \i next\plain\fs20\cf1\cb1  is to execute the next expression in an expression sequence and to suspend execution again.  If the current expression involves a call on a defined operation or expression, execution of the entire definition is completed and execution is suspended on the expression after the current one.  If the current expression is the last one in the expression sequence where the break began, the effect is the same as using \i resume\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 The related command \i nextv\plain\fs20\cf1\cb1  displays the result of the expression executed on a step before displaying the next expression.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00bf}
{\up $}{\footnote\pard\plain{\up $} nialroot}
{\up #}{\footnote\pard\plain{\up #} K_TBJ1}
\pard\keepn\sb95 \b\fs25 nialroot\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} nialroot;system expression, nialroot}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Nialroot    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 host\plain\fs20\cf1\cb1 {\v 25VK_53}, \uldb link\plain\fs20\cf1\cb1 {\v QD77W5}, \uldb library\plain\fs20\cf1\cb1 {\v 2B9L0GD}\line

\par The expression \i Nialroot\plain\fs20\cf1\cb1  returns a string giving the path to the directory holding the help directory, the initial directory and the library directories.  Nialroot is defined before Q'Nial is run.  In Windows and Unix versions this is set up as part of the installation procedure. \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00c0}
{\up $}{\footnote\pard\plain{\up $} no_expr}
{\up #}{\footnote\pard\plain{\up #} DRMT03}
\pard\keepn\sb95 \b\fs25 no_expr\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} no_expr;system expression, no_expr}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 No_expr    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 no_value\plain\fs20\cf1\cb1 {\v 1R1EBX3}, \uldb no_op\plain\fs20\cf1\cb1 {\v 7KL1IF}, \uldb no_tr\plain\fs20\cf1\cb1 {\v 7KL1NH}\line

\par The expression No_expr returns the fault \i ?missing_expr\plain\fs20\cf1\cb1 .  It is the default value for an expression name declared to be \i external\plain\fs20\cf1\cb1  or that has been erased.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00c1}
{\up $}{\footnote\pard\plain{\up $} no_op}
{\up #}{\footnote\pard\plain{\up #} 7KL1IF}
\pard\keepn\sb95 \b\fs25 no_op\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} no_op;system operation, no_op}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 no_op A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 no_value\plain\fs20\cf1\cb1 {\v 1R1EBX3}, \uldb no_expr\plain\fs20\cf1\cb1 {\v DRMT03}, \uldb no_tr\plain\fs20\cf1\cb1 {\v 7KL1NH}\line

\par The operation \i no_op\plain\fs20\cf1\cb1  returns the fault \i ?missing_op\plain\fs20\cf1\cb1  when applied to any array \i A\plain\fs20\cf1\cb1 .  It is the default value for an operation name declared to be external or that has been erased.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00c2}
{\up $}{\footnote\pard\plain{\up $} no_tr}
{\up #}{\footnote\pard\plain{\up #} 7KL1NH}
\pard\keepn\sb95 \b\fs25 no_tr\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} no_tr;system transformer, no_tr}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system transformer\plain\fs20\cf1\cb1 {\v system transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 no_tr f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 no_value\plain\fs20\cf1\cb1 {\v 1R1EBX3}, \uldb no_expr\plain\fs20\cf1\cb1 {\v DRMT03}, \uldb no_op\plain\fs20\cf1\cb1 {\v 7KL1IF}\line

\par The transformer \i NO_TR\plain\fs20\cf1\cb1  transforms any operation \i f\plain\fs20\cf1\cb1  to an operation that returns the fault \i ?missing_tr\plain\fs20\cf1\cb1  when applied to any array \i A\plain\fs20\cf1\cb1 .  It is the default value for a transformer name declared to be external or that has been erased.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00c3}
{\up $}{\footnote\pard\plain{\up $} no_value}
{\up #}{\footnote\pard\plain{\up #} 1R1EBX3}
\pard\keepn\sb95 \b\fs25 no_value\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} no_value;system constant, no_value}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system constant\plain\fs20\cf1\cb1 {\v system constant}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 ?no_value    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 no_expr\plain\fs20\cf1\cb1 {\v DRMT03}, \uldb no_op\plain\fs20\cf1\cb1 {\v 7KL1IF}, \uldb no_tr\plain\fs20\cf1\cb1 {\v 7KL1NH}\line

\par The fault \i ?no_value\plain\fs20\cf1\cb1  is a special fault value used as the default value of variables that have been declared external or that have been erased.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00c4}
{\up $}{\footnote\pard\plain{\up $} not}
{\up #}{\footnote\pard\plain{\up #} 1_E73CJ}
\pard\keepn\sb95 \b\fs25 not\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} logic operation, not;not}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul logic operation\plain\fs20\cf1\cb1 {\v logic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 not A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 and\plain\fs20\cf1\cb1 {\v 1_E6QB0}, \uldb or\plain\fs20\cf1\cb1 {\v RJ2SI6}, \uldb true\plain\fs20\cf1\cb1 {\v 5FZ__UI}, \uldb false\plain\fs20\cf1\cb1 {\v 4WY._DU}, \uldb isboolean\plain\fs20\cf1\cb1 {\v 1VYX20O}, \uldb notin\plain\fs20\cf1\cb1 {\v 7KLHCD}\line

\par The operation \i not\plain\fs20\cf1\cb1  reverses the value of a boolean.  It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is \i false\plain\fs20\cf1\cb1  and \i false\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is \i true\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  is any other atom, the result is the logical fault \i ?L\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      not l \line
o \line
     not lollo \line
olool \line
     not 2 "abc o \line
?L ?L l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    not not not A = not A \line
   not and A =f= or EACH not A \line
   not or A =f= and EACH not A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00c5}
{\up $}{\footnote\pard\plain{\up $} notin}
{\up #}{\footnote\pard\plain{\up #} 7KLHCD}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 notin\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} notin;search operation, notin}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul search operation\plain\fs20\cf1\cb1 {\v search operation}
\par \pard\sb95 \b Properties:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}, \uldb predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A notin B   notin A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 in\plain\fs20\cf1\cb1 {\v RJ2SC2}, \uldb not\plain\fs20\cf1\cb1 {\v 1_E73CJ}, \uldb allin\plain\fs20\cf1\cb1 {\v 5J2S.RC}, \uldb unequal\plain\fs20\cf1\cb1 {\v LT7UC9}\line

\par The operation \i notin\plain\fs20\cf1\cb1  returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is not an item of \i B\plain\fs20\cf1\cb1  and returns \i false\plain\fs20\cf1\cb1  if it is.  
\par \pard\keep\sb95 \f1\fs16      3 notin 56 34 23 3 57 3 \line
o \line
 \line
     4 1 notin tell 3 4 \line
l \line
 \line
     `a notin 'hello world' \line
l \line
 \line
     `a notin "apple \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      notin IS OPERATION A B \{\- not (A in B) \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A notin B = A notin list B \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00c6}
{\up $}{\footnote\pard\plain{\up $} null}
{\up #}{\footnote\pard\plain{\up #} 40XD_Q}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 null\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} constant expression, null;null}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul constant expression\plain\fs20\cf1\cb1 {\v constant expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Null    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 empty\plain\fs20\cf1\cb1 {\v 7BJDNO}, \uldb atomic\plain\fs20\cf1\cb1 {\v GJLKWO}\line

\par The expression \i Null\plain\fs20\cf1\cb1  denotes the empty list.  It is the array returned as the shape of a single and is equal to the empty string.  The empty list notation \i  [ ] \plain\fs20\cf1\cb1  also denotes the empty list \i Null\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      Null = shape 5 \line
l \line
     Null = [] \line
l \line
     Null = '' \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 Since there is an empty array for each shape containing a zero, unless you are certain \i A\plain\fs20\cf1\cb1  is a list, the test: \i A = Null\plain\fs20\cf1\cb1  should not be used in place of \i empty A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      set "sketch; Null \line
 \line
     set "diagram; Null \line
+ \line
| \line
+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \i Null\plain\fs20\cf1\cb1  is not displayed when sketch display mode is set.  In diagram mode it is displayed as the left border of a list diagram.  \line

\par A selection operation such as \i pick\plain\fs20\cf1\cb1  or \i first\plain\fs20\cf1\cb1  applied to \i Null\plain\fs20\cf1\cb1  results in the fault \i ?address\plain\fs20\cf1\cb1 .  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      Null IS shape 0 \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape single A = Null \line
   shape Null = 0 \line
   atomic A ==> Null = shape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00c7}
{\up $}{\footnote\pard\plain{\up $} numeric}
{\up #}{\footnote\pard\plain{\up #} K7MN2O}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 numeric\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} measurement operation, numeric;numeric}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 numeric A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 type\plain\fs20\cf1\cb1 {\v 25VWG1O}, \uldb isinteger\plain\fs20\cf1\cb1 {\v 23WZ8W4}, \uldb isreal\plain\fs20\cf1\cb1 {\v OIOCOX}, \uldb ischar\plain\fs20\cf1\cb1 {\v 1ARLF.C}\line

\par The operation \i numeric\plain\fs20\cf1\cb1  tests whether or not \i A\plain\fs20\cf1\cb1  is a numeric  atom.   It returns \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is a boolean atom, an integer atom or a real atom, \i false\plain\fs20\cf1\cb1  otherwise.  
\par \pard\keep\sb95 \f1\fs16      numeric 3.5 \line
l \line
     numeric l 45 3.78 \line
o \line
     numeric Null \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 \line

\par numeric IS OPERATION A \{\- isboolean A or isinteger A or isreal A \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00c8}
{\up $}{\footnote\pard\plain{\up $} numeric type hierarchy}
{\up #}{\footnote\pard\plain{\up #} 1_X9C7}
\pard\keepn\sb95 \b\fs25 numeric type hierarchy\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, numeric type hierarchy;numeric type hierarchy}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 sum\plain\fs20\cf1\cb1 {\v 1_E78IC}, \uldb or\plain\fs20\cf1\cb1 {\v RJ2SI6}\line

\par The three numeric types: boolean, integer and real, are organized in a hierarchy in the order mentioned.  For arithmetic and comparative binary operations, if the types of arguments are both numeric but differ in type, they are coerced to the higher of the two types.  For example, if you add an integer to a real number, say 3 + 4.5, the integer is coerced to 3.0 and a real number addition is done.  Boolean atoms are always coerced to integers if they are used with arithmetic operations.  \line

\par \pard\sb95 There are six types of atoms in Nial.  They are boolean, integer, real, character, phrase and fault.  The first three are numeric types and are used for arithmetic operations.  The last three are literal types and are used for symbol manipulation.  All six types of atoms are used in comparisons.  \line

\par A boolean atom is the result of a comparison of array values; or the result of a test relating to a characteristic of an array or the content of an array.  There are two boolean atoms: true and false, denoted by l and o respectively. When booleans are treated as numbers, true corresponds to one and false to zero.  \line

\par \pard\sb95 An integer atom is a positive or negative whole number representing a quantity of units.  A dash symbol (-) immediately preceding the integer denotes a negative integer.  No space is permitted between the dash and the number, otherwise the dash is interpreted as the arithmetical operation of subtraction.  Conversely, a space is required when subtraction is intended.  An integer is represented by an internal form that limits its range of values in the Q'Nial implementation of Nial.  \line

\par \pard\sb95 A real atom is a number which can represent any position on the real line.  It may be written with a fractional part and/or with a decimal exponent.  It is represented internally by a floating point number.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00c9}
{\up $}{\footnote\pard\plain{\up $} open}
{\up #}{\footnote\pard\plain{\up #} 25VR_QX}
\pard\keepn\sb95 \b\fs25 open\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} file operation, open;open}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul file operation\plain\fs20\cf1\cb1 {\v file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 open Filename Mode    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 close\plain\fs20\cf1\cb1 {\v TIUC9K}, \uldb readfile\plain\fs20\cf1\cb1 {\v 5JAWOA}, \uldb writefile\plain\fs20\cf1\cb1 {\v 1DNB1GE}, \uldb readarray\plain\fs20\cf1\cb1 {\v 7HVXYZ}, \uldb writearray\plain\fs20\cf1\cb1 {\v 18CILAO}, \uldb readrecord\plain\fs20\cf1\cb1 {\v 6J72_OO}, \uldb writerecord\plain\fs20\cf1\cb1 {\v V4AFRH}\line

\par The operation \i open\plain\fs20\cf1\cb1  prepares the host file named by the phrase or string \i Filename\plain\fs20\cf1\cb1  for use in one of seven possible modes.  \i Mode\plain\fs20\cf1\cb1  is a character, string or phrase encoding the mode as follows: 
\par  \trowd\trgaph175\trleft-6 \cellx995\cellx2655\cellx5795\pard\intbl\sb95 \b Mode  \cell\pard \pard\intbl\sb95 Mode Name \cell\pard \pard\intbl\sb95 Description  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx2655\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 r  \cell\pard \pard\intbl\sb95 read  \cell\pard \pard\intbl\sb95 existing sequential text file, read only  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx2655\cellx5795\pard\intbl\sb95 w  \cell\pard \pard\intbl\sb95 write  \cell\pard \pard\intbl\sb95 create sequential text file, write only  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx2655\cellx5795\pard\intbl\sb95 a  \cell\pard \pard\intbl\sb95 append  \cell\pard \pard\intbl\sb95 existing sequential text file, write only starting at the end  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx2655\cellx5795\pard\intbl\sb95 d  \cell\pard \pard\intbl\sb95 direct  \cell\pard \pard\intbl\sb95 existing or new binary file, direct access for both read and write  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx2655\cellx5795\pard\intbl\sb95 c  \cell\pard \pard\intbl\sb95 communication  \cell\pard \pard\intbl\sb95 existing or new sequential text file, for both read and write  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx2655\cellx5795\pard\intbl\sb95 pr  \cell\pard \pard\intbl\sb95 pipe read  \cell\pard \pard\intbl\sb95 output from the command Filename is available \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx2655\cellx5795\pard\intbl\sb95 pw  \cell\pard \pard\intbl\sb95 pipe write  \cell\pard \pard\intbl\sb95 input to the command Filename is provided \cell\intbl\row
\pard\sb95 \line

\par In \i read\plain\fs20\cf1\cb1 , \i write\plain\fs20\cf1\cb1 , \i append\plain\fs20\cf1\cb1  or \i communication\plain\fs20\cf1\cb1  modes, \i Filename\plain\fs20\cf1\cb1  must include the file extension, if any.  In direct mode, two host files are opened, one with extension \i .ndx\plain\fs20\cf1\cb1  and the other with extension \i .rec\plain\fs20\cf1\cb1 , standing for \i index\plain\fs20\cf1\cb1  and \i record\plain\fs20\cf1\cb1 , respectively.  In this mode, \i Filename\plain\fs20\cf1\cb1  is the root of the file name, without any extension.  \line

\par The \i communication\plain\fs20\cf1\cb1  mode can be used with special forms of \i readfile\plain\fs20\cf1\cb1  and \i writefile\plain\fs20\cf1\cb1  usage to access a special device or a communications port.  This mode is available only on the EXTDOS Version of Nial.  \line

\par \pard\sb95 The pipe modes treat the \i Filename\plain\fs20\cf1\cb1  as a host command. The \i open\plain\fs20\cf1\cb1  causes the command to be executed. In \i pipe read\plain\fs20\cf1\cb1 , the output from the command is obtained using \i readfile\plain\fs20\cf1\cb1 ; in \i pipe write\plain\fs20\cf1\cb1 , input to the command is provided using \i writefile\plain\fs20\cf1\cb1 .\line

\par The result of \i open\plain\fs20\cf1\cb1  is a file designator, an integer specifying an input/output port.  This value is used in later references to the file.  \line

\par The effect of \i open\plain\fs20\cf1\cb1  may be system dependent.  If the file exists and can be opened by the user in the requested mode, the result will be the file designator.  If it cannot be opened or does not exist, the result will be a fault message generated from the error message provided by the host system.  For portable programs, the specific fault message should not be used in an equality test.  The result of an open should be tested for a fault value using \i isfault\plain\fs20\cf1\cb1  to catch unexpected failures.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ca}
{\up $}{\footnote\pard\plain{\up $} operation}
{\up #}{\footnote\pard\plain{\up #} CQFG7.}
\pard\keepn\sb95 \b\fs25 operation\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, operation;operation}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 expression\plain\fs20\cf1\cb1 {\v FD5QFK}, \uldb transformer\plain\fs20\cf1\cb1 {\v 1VQL398}\line

\par An \b operation\plain\fs20\cf1\cb1  is a functional object that is given an argument array and returns a result array.  The process of executing an operation by giving it an argument value is called an \i operation call\plain\fs20\cf1\cb1  or an \i operation application\plain\fs20\cf1\cb1 .  \line

\par An operation can be constructed by defining one or more parameters and giving an algorithm to compute the result in terms of the parameters.  An operation is usually given a name when it is defined.  There are also program fragments that construct unnamed operations by composing operations, forming a list of operations or modifying an operation by use of a transformer.  \line

\par \pard\sb95 A named operation is either a predefined operation or an operation that has been given an explicit name using the \i IS\plain\fs20\cf1\cb1  definition mechanism.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00cb}
{\up $}{\footnote\pard\plain{\up $} operation composition}
{\up #}{\footnote\pard\plain{\up #} 1ZR4NW0}
\pard\keepn\sb95 \b\fs25 operation composition\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, operation composition;operation composition}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 curried operation\plain\fs20\cf1\cb1 {\v 3NTT_IU}\line

\par A sequence of simple-operation denotations forms an operation-sequence in the syntax of Nial.  Its meaning is the same as the composition of the operations in the sequence which is explained by its effect when applied.  \line

\par The result of applying an operation-sequence to an argument is determined by applying the simple-operations in the sequence in right-to-left order.  The simple-operation on the right is applied to the argument giving an intermediate result.  Then the simple-operation to the immediate left is applied to the result of the first application.  Subsequent simple-operations are applied to the results in turn.  \line

\par \pard\sb95 An example of this concept is the expression 
\par \pard\keep\sb95 \f1\fs16      (first rest) 8 7 2 5 3 \line
7\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The expression sequence \i first rest\plain\fs20\cf1\cb1  is evaluated by applying \i rest\plain\fs20\cf1\cb1  to the argument resulting in 7 2 5 3 and then \i first\plain\fs20\cf1\cb1  is applied giving 7.  \line

\par The relationship can be described by the equations:
\par \pard\keep\sb95 \f1\fs16    (f g) A = f (g A) \line
   (f g h) A = f (g (h A)) \line
   etc. \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 which is mathematically known as the rule of \b function composition\plain\fs20\cf1\cb1 .  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00cc}
{\up $}{\footnote\pard\plain{\up $} operation form}
{\up #}{\footnote\pard\plain{\up #} B1O8VR}
\pard\keepn\sb95 \b\fs25 operation form\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} operation form;syntax, operation form}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 operation\plain\fs20\cf1\cb1 {\v CQFG7.}, \uldb definition\plain\fs20\cf1\cb1 {\v K9LSXA}\line

\par An \b operation-form\plain\fs20\cf1\cb1  is the syntactic structure used to describe an operation in terms of a parameterized expression-sequence.  The identifiers following the keyword operation are called the \b formal parameters\plain\fs20\cf1\cb1 .  The body of an operation-form is normally a block but it may be an expression-sequence without automatic localization.  
\par \pard\keep\sb95 \f1\fs16      operation-form ::= \line
        OPERATION \{\- identifiers \'7d+ block \line
        | OPERATION \{\- identifiers \'7d+ \line
          ( expression-sequence )\plain\fs20\cf1\cb1 \line

\par \pard\sb95 An operation-form defines a local environment.  The formal parameter names are names of local variables.  If the body of the operation form is a block, the local environment of the block is extended to include the formal parameters.  When the operation is applied, the formal parameter names are assigned from the value of the actual argument.  If there is only one formal parameter, the actual argument is assigned to it as a whole; otherwise, the items of the actual argument are assigned to the formal parameters in corresponding order.  If there is a length mismatch between the list of formal parameter names and the values of the actual argument, the fault \i ?op_parameter\plain\fs20\cf1\cb1  is returned.  \line

\par \pard\sb95 The value of the application of the operation is the value of the body of the operation-form, which is evaluated with the local variables in the parameter list assigned as described above.  In determining the association for a name that appears in the body of an operation form, Q'Nial looks for the name in the local environment.  If the name is not found locally, the name is sought in surrounding environments until it is found or until the global environment is searched.  If it is not found, a fault \i ?unknown identifier:\plain\fs20\cf1\cb1  is given when the operation-form is analyzed (parsed).  \line

\par \pard\sb95 Operation-forms are most frequently used in definitions where they are given an associated name.  However, an operation-form can appear directly in an expression provided it is enclosed in parentheses.  In this usage, it can be an argument to a transformer name or can be applied to an array argument.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00cd}
{\up $}{\footnote\pard\plain{\up $} opposite}
{\up #}{\footnote\pard\plain{\up #} 18Y3XQ}
\pard\keepn\sb95 \b\fs25 opposite\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, opposite;opposite}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 opposite A   opp A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 minus\plain\fs20\cf1\cb1 {\v 7JFBOI}, \uldb not\plain\fs20\cf1\cb1 {\v 1_E73CJ}, \uldb reciprocal\plain\fs20\cf1\cb1 {\v AJCGJN}\line

\par The operation \i opposite\plain\fs20\cf1\cb1  returns the opposite value of the integer or real number \i A\plain\fs20\cf1\cb1 .  The opposite value of a positive number A is the corresponding negative value and vice versa.  The operation produces the following results when applied to atoms of the six types: 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 opposite of the corresponding integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 opposite integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 opposite real number \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 \line

\par The name \i opp\plain\fs20\cf1\cb1  is a synonym for \i opposite\plain\fs20\cf1\cb1  used as an abbreviation.  
\par \pard\keep\sb95 \f1\fs16      opposite  l  -2  3.5  `a  "abc  ??err \line
-1 2 -3.5 ?A ?A ?err\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In Nial, the symbol \i -\plain\fs20\cf1\cb1  is used as part of negative numbers and as a synonym for \i minus\plain\fs20\cf1\cb1 . Care must be taken to use a space after the symbol before a constant to get the expected subtraction.\line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      opposite IS OPERATION A (0 minus A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    opposite opposite opposite A = opposite A \line
   A - B = A + opposite B \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ce}
{\up $}{\footnote\pard\plain{\up $} ops}
{\up #}{\footnote\pard\plain{\up #} 1_E74DI}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 ops\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} ops;system expression, ops}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Ops    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 symbols\plain\fs20\cf1\cb1 {\v 1KUXMUU}, \uldb exprs\plain\fs20\cf1\cb1 {\v 7BUDLI}, \uldb trs\plain\fs20\cf1\cb1 {\v 1_E79FI}, \uldb vars\plain\fs20\cf1\cb1 {\v 1CMLZGM}\line

\par The expression \i Ops\plain\fs20\cf1\cb1  returns a list of phrases giving the names of all user defined operations in the workspace.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      Ops IS \{\-  \line
        Names Roles := pack symbols 0;  \line
        "op match Roles sublist Names \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00cf}
{\up $}{\footnote\pard\plain{\up $} or}
{\up #}{\footnote\pard\plain{\up #} RJ2SI6}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 or\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} logic operation, or;or}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul logic operation\plain\fs20\cf1\cb1 {\v logic operation}
\par \pard\sb95 \b Properties:  \uldb \plain\uldb\fs20\cf1\cb1 multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}, \uldb reductive\plain\fs20\cf1\cb1 {\v 7GGROL}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 or A   A or B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 and\plain\fs20\cf1\cb1 {\v 1_E6QB0}, \uldb not\plain\fs20\cf1\cb1 {\v 1_E73CJ}\line

\par The operation \i or\plain\fs20\cf1\cb1  applies to a boolean array \i A\plain\fs20\cf1\cb1  and does the boolean sum of its items.  If any item of \i A\plain\fs20\cf1\cb1  is \i true\plain\fs20\cf1\cb1 , the result is \i true\plain\fs20\cf1\cb1 ; otherwise it is \i false\plain\fs20\cf1\cb1 .  Used in binary form, it implements the usual or-connective of logic.  If \i A\plain\fs20\cf1\cb1  is a simple array but has a non-boolean item, the result is the logical fault \i ?L\plain\fs20\cf1\cb1 .  The operation extends to non-simple arrays by the multi pervasive mechanism.  
\par \pard\keep\sb95 \f1\fs16      l or o \line
l \line
 \line
     or oooolooo \line
l \line
 \line
     lloo or lolo \line
lllo\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \i Or\plain\fs20\cf1\cb1  is a reductive operation in that it reduces an array of booleans to a single boolean.  Applied to a pair of bitstrings, it produces a bitstring resulting from applying or to the bits of its arguments in corresponding positions.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A or B = B or A \line
   not or A =f= and EACH not A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00d0}
{\up $}{\footnote\pard\plain{\up $} outer}
{\up #}{\footnote\pard\plain{\up #} TV3GVX}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 outer\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} applicative transformer, outer;outer}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul applicative transformer\plain\fs20\cf1\cb1 {\v applicative transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A OUTER f B   OUTER f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 cart\plain\fs20\cf1\cb1 {\v 1CM9ZGN}, \uldb inner\plain\fs20\cf1\cb1 {\v TOWAVX}\line

\par The transformer \i OUTER\plain\fs20\cf1\cb1  transforms an operation \i f\plain\fs20\cf1\cb1  to an operation that applies \i f\plain\fs20\cf1\cb1  to each item of the cartesian product of its argument.  In the case where the arguments are a pair of lists \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1 , the result is a table of the applications of \i f\plain\fs20\cf1\cb1  with every pair chosen with the first item from \i A\plain\fs20\cf1\cb1  and the second from \i B\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      1 2 3 4 5 OUTER * 1 2 3 4 5 \line
1  2  3  4  5 \line
2  4  6  8 10 \line
3  6  9 12 15 \line
4  8 12 16 20 \line
5 10 15 20 25 \line
 \line
     2 3 OUTER reshape 'abcd' \line
+---+---+---+---+ \line
|aa |bb |cc |dd | \line
+---+---+---+---+ \line
|aaa|bbb|ccc|ddd| \line
+---+---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows \i OUTER *\plain\fs20\cf1\cb1  being used to generate a multiplication table.  The second shows that it can be applied to an operation that has a non-atomic result.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      OUTER IS TRANSFORMER f OPERATION A (EACH f cart A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape OUTER f A = link EACH shape A \line
   and EACH (not empty) A B ==> A OUTER f B = mix (A EACHLEFT EACHRIGHT f B) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00d1}
{\up $}{\footnote\pard\plain{\up $} overflow}
{\up #}{\footnote\pard\plain{\up #} 1MYZ9HY}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 overflow\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, overflow;overflow}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}\line

\par \pard\sb95 The term \b integer overflow\plain\fs20\cf1\cb1  is used to describe the situation when an integer that is too big for the internal representation of integers is generated.  Q'Nial uses 32 bit integers and checks for overflow during computations.  If an arithmetic computation produces an overflow, a fault value is produced.  \line

\par An overflow can also develop during computation with real numbers.  The computer hardware detects such a problem and an interrupt occurs which causes Q'Nial to jump to top level.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00d2}
{\up $}{\footnote\pard\plain{\up $} pack}
{\up #}{\footnote\pard\plain{\up #} QD0ZL5}
\pard\keepn\sb95 \b\fs25 pack\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} data rearrangement operation, pack;pack}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul data rearrangement operation\plain\fs20\cf1\cb1 {\v data rearrangement operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 pack A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 eachall\plain\fs20\cf1\cb1 {\v LYL6P6}, \uldb eachboth\plain\fs20\cf1\cb1 {\v 1R110IM}\line

\par The operation \i pack\plain\fs20\cf1\cb1  interchanges the top two levels of an array with equally shaped items.  If \i A\plain\fs20\cf1\cb1  is an array with items all of the same shape, the result is an array of that shape, with items having the shape that \i A\plain\fs20\cf1\cb1  has.  If \i A\plain\fs20\cf1\cb1  does not have items of the same shape but all the items that have zero items or more than one item are of the same shape, it is modified by replicating the items with one item to that shape before interchanging levels.  Otherwise it returns the fault \i ?conform\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 The items of the result are the arrays of items of \i A\plain\fs20\cf1\cb1  from corresponding positions.  \i Pack\plain\fs20\cf1\cb1  is used implicitly in all binary pervasive and multi pervasive operations.  
\par \pard\keep\sb95 \f1\fs16      pack (2 3 4) (4 5 6) \line
+---+---+---+ \line
|2 4|3 5|4 6| \line
+---+---+---+ \line
     pack 'ab' 'cd' 'ef' 'gh' \line
+----+----+ \line
|aceg|bdfh| \line
+----+----+ \line
     pack (tell 2 3) (count 2 3) \line
+---------+---------+---------+ \line
|+---+---+|+---+---+|+---+---+| \line
||0 0|1 1|||0 1|1 2|||0 2|1 3|| \line
|+---+---+|+---+---+|+---+---+| \line
+---------+---------+---------+ \line
|+---+---+|+---+---+|+---+---+| \line
||1 0|2 1|||1 1|2 2|||1 2|2 3|| \line
|+---+---+|+---+---+|+---+---+| \line
+---------+---------+---------+ \line
 \line
     pack (2 3 4) 5 [2 3] 'abc' \line
+-----------+-----------+-----------+ \line
|+-+-+---+-+|+-+-+---+-+|+-+-+---+-+| \line
||2|5|2 3|a|||3|5|2 3|b|||4|5|2 3|c|| \line
|+-+-+---+-+|+-+-+---+-+|+-+-+---+-+| \line
+-----------+-----------+-----------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows that \i pack\plain\fs20\cf1\cb1  of a pair of triples is a triple of pairs.  The second shows that \i pack\plain\fs20\cf1\cb1  of a quadruple of pairs is a pair of quadruples.  The third shows that \i pack\plain\fs20\cf1\cb1  of a pair of 2 by 3 tables is a 2 by 3 table of pairs.  The final example shows a case where replication occurs.  The first and last items have shape [3].  The second and third items are an atom and a solitary and hence can be replicated.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    equal EACH shape A and not empty pack A ==> pack pack A = A \line
   pack pack pack A = pack A \line
   pack single A = EACH single A \line
   pack solitary A = EACH solitary A \line
   empty A ==> pack A = single A \line
   simple A ==> pack A = single A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00d3}
{\up $}{\footnote\pard\plain{\up $} pair}
{\up #}{\footnote\pard\plain{\up #} QD0ZR.}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 pair\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} construction operation, pair;pair}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul construction operation\plain\fs20\cf1\cb1 {\v construction operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A pair B   pair A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 link\plain\fs20\cf1\cb1 {\v QD77W5}, \uldb hitch\plain\fs20\cf1\cb1 {\v TNRGTN}, \uldb append\plain\fs20\cf1\cb1 {\v GFMD1P}, \uldb reshape\plain\fs20\cf1\cb1 {\v 3I4D_MA}\line

\par The operation \i pair\plain\fs20\cf1\cb1  has no effect on a pair but converts all other arrays to a pair by reshaping the array with shape 2.  Used in infix notation, it has the effect of forming a pair from the two arguments.  An explicit pair can also be achieved with list or strand notation.  The operation is useful in functional expressions where it is an argument to a transformer.  
\par \pard\keep\sb95 \f1\fs16      3 pair 4 5 \line
+-+---+ \line
|3|4 5| \line
+-+---+ \line
     pair 3 4 5 \line
3 4 \line
 \line
     pair single 3 4 5 \line
+-----+-----+ \line
|3 4 5|3 4 5| \line
+-----+-----+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The major use of \i pair\plain\fs20\cf1\cb1  is as an operation applied using a transformer.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      pair IS OPERATION A (2 reshape A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    pair pair A = pair A \line
   A OUTER pair B = A cart B \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00d4}
{\up $}{\footnote\pard\plain{\up $} parse}
{\up #}{\footnote\pard\plain{\up #} TVJF9K}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 parse\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} evaluation operation, parse;parse}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 parse Tokenstream    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 scan\plain\fs20\cf1\cb1 {\v 1CMJ16H}, \uldb deparse\plain\fs20\cf1\cb1 {\v 15N2FZO}, \uldb descan\plain\fs20\cf1\cb1 {\v 7ABG_7N}, \uldb eval\plain\fs20\cf1\cb1 {\v 40OE2Q}, \uldb execute\plain\fs20\cf1\cb1 {\v 3WULI4D}\line

\par The operation \i parse\plain\fs20\cf1\cb1  carries out the internal parsing capability of the interpreter.  Its argument is a token stream produced by \i scan\plain\fs20\cf1\cb1  or \i deparse\plain\fs20\cf1\cb1 .  The result is the parse tree recording the semantic intent of the input.  The parse tree is a highly encoded form of nested array designed for efficient processing.  
\par \pard\keep\sb95 \f1\fs16      parse scan 'sum 23 45' \line
+---+-----------------------------+ \line
|100|+-+-----+-------------------+| \line
|   ||4|3 4 3|+-+-------+-------+|| \line
|   || |     ||8|1 23 23|1 45 45||| \line
|   || |     |+-+-------+-------+|| \line
|   |+-+-----+-------------------+| \line
+---+-----------------------------+ \line
 \line
     parse scan 'foo IS first' \line
+---+-----------------------------+ \line
|100|+--+---------------+------+-+| \line
|   ||11|+--+----------+|3 47 3|1|| \line
|   ||  ||22|2 160 7459||      | || \line
|   ||  |+--+----------+|      | || \line
|   |+--+---------------+------+-+| \line
+---+-----------------------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example gives the parse tree corresponding to an application of an operation to a strand of constants.  The second example gives the parse tree for the definition of \i foo\plain\fs20\cf1\cb1  as the predefined operation \i first\plain\fs20\cf1\cb1 .  The small integers that appear as the first items of the arrays serve as tags to indicate the kind of node that is represented in the parse tree.  They are used by the \i eval\plain\fs20\cf1\cb1  and \i deparse\plain\fs20\cf1\cb1  operations.  The representation of parse trees is implementation dependent and is not intended for program manipulation.  \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    Ts a token stream ==> parse deparse parse Ts = parse Ts \line
   S a string ==> eval parse scan S = execute S \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00d5}
{\up $}{\footnote\pard\plain{\up $} partition}
{\up #}{\footnote\pard\plain{\up #} KE6GMU}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 partition\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} apply-by-partition transformer, partition;partition}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul apply-by-partition transformer\plain\fs20\cf1\cb1 {\v apply-by-partition transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 I,J] PARTITION f A   I] PARTITION f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 rank\plain\fs20\cf1\cb1 {\v QD.ZW5}, \uldb split\plain\fs20\cf1\cb1 {\v 5JDW.RI}, \uldb blend\plain\fs20\cf1\cb1 {\v THU94J}\line

\par The transformer \i PARTITION\plain\fs20\cf1\cb1  is used to apply operation \i f\plain\fs20\cf1\cb1  to partitions of the array \i A\plain\fs20\cf1\cb1 , placing the results of the applications as partitions of the result array.  \line

\par The partitions of \i A\plain\fs20\cf1\cb1  are determined by the axis numbers in \i I\plain\fs20\cf1\cb1 , using (\i I split A\plain\fs20\cf1\cb1 ) to form them implicitly.  The results of applying \i f\plain\fs20\cf1\cb1 , viewed as an intermediate array \i R\plain\fs20\cf1\cb1 , are combined into the final result, using (\i J blend R\plain\fs20\cf1\cb1 ), to place the axes of the items of \i R\plain\fs20\cf1\cb1  into the final result.  If the left argument is a solitary, it is assumed to be used as the argument to both \i split\plain\fs20\cf1\cb1  and \i blend\plain\fs20\cf1\cb1  implicitly.  \line

\par \pard\sb95 For a table \i A\plain\fs20\cf1\cb1 , \i I = 1\plain\fs20\cf1\cb1 , \i f\plain\fs20\cf1\cb1  being \i reverse\plain\fs20\cf1\cb1 , the effect is to reverse the rows of \i A\plain\fs20\cf1\cb1 .  In general, if \i I = J\plain\fs20\cf1\cb1  and is a single axis number and \i f\plain\fs20\cf1\cb1  maps a list to one of the same length, the effect is to apply \i f\plain\fs20\cf1\cb1  to the lists formed by pushing axis \i I\plain\fs20\cf1\cb1  down, resulting in an array of the same shape as \i A\plain\fs20\cf1\cb1 .  Two dimensional partitions of a three dimensional array can be mapped using an \i I\plain\fs20\cf1\cb1  with tally 2.  
\par \pard\keep\sb95 \f1\fs16      [1] PARTITION reverse (3 5 reshape count 15) \line
 5  4  3  2  1 \line
10  9  8  7  6 \line
15 14 13 12 11 \line
 \line
     [0] PARTITION (2 rotate) (6 6 reshape tell 36) \line
12 13 14 15 16 17 \line
18 19 20 21 22 23 \line
24 25 26 27 28 29 \line
30 31 32 33 34 35 \line
 0  1  2  3  4  5 \line
 6  7  8  9 10 11 \line
 \line
     setformat '%4.2f'; \line
     seed .5 ; A:=2 3 3 reshape random 18 \line
0.50 0.43 0.12   0.03 0.81 0.24 \line
0.77 0.73 0.89   0.58 0.98 0.47 \line
0.98 0.66 0.16   0.24 0.16 0.50 \line
     B gets 1 2 split A \line
+--------------+--------------+ \line
|0.50 0.43 0.12|0.03 0.81 0.24| \line
|0.77 0.73 0.89|0.58 0.98 0.47| \line
|0.98 0.66 0.16|0.24 0.16 0.50| \line
+--------------+--------------+ \line
     C gets EACH inverse B \line
+-----------------+-----------------+ \line
|-7.43  0.18  4.69|-2.51  2.21 -0.90| \line
|11.78 -0.62 -5.55| 1.09  0.25 -0.76| \line
|-3.27  1.48  0.51| 0.83 -1.13  2.69| \line
+-----------------+-----------------+ \line
     1 2 blend C \line
-7.43  0.18  4.69   -2.51  2.21 -0.90 \line
11.78 -0.62 -5.55    1.09  0.25 -0.76 \line
-3.27  1.48  0.51    0.83 -1.13  2.69 \line
     [1 2] PARTITION inverse A \line
-7.43  0.18  4.69   -2.51  2.21 -0.90 \line
11.78 -0.62 -5.55    1.09  0.25 -0.76 \line
-3.27  1.48  0.51    0.83 -1.13  2.69\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The transformer \i RANK\plain\fs20\cf1\cb1  is a simpler version of a partitioning transformer that always pushes down the right end axes.\line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16 PARTITION IS TRANSFORMER f OPERATION Ij A \{\- \line
   IF empty Ij or (tally Ij > 2) THEN \line
      fault 'invalid left arg of PARTITION transform' \line
   ELSEIF empty A THEN \line
      A \line
   ELSE \line
      IF tally Ij = 1 THEN \line
         I := J := first Ij; \line
      ELSEIF tally Ij = 2 THEN \line
         I J := Ij; \line
      ENDIF; \line
      II gets axes A except I link I; \line
      B := tally I RANK f (II fuse A); \line
      IF J = Null and (shape B = Null) THEN \line
         first B \line
      ELSEIF tally J = (valence B - (valence A - tally I)) THEN \line
         JJ gets axes B except J link J; \line
         GRADE <= JJ fuse B \line
      ELSE \line
         fault 'left arg incompatible with function in PARTITION transform' \line
      ENDIF \line
   ENDIF \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    I split A = \'5c[I,Null] PARTITION single A \line
   I blend A = \'5c[Null,I] PARTITION first A \line
   EACH f A = \'5c[Null,Null] PARTITION (single f first) A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00d6}
{\up $}{\footnote\pard\plain{\up $} pass}
{\up #}{\footnote\pard\plain{\up #} 1CMFZHM}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 pass\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} pass;reshaping operation, pass}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul reshaping operation\plain\fs20\cf1\cb1 {\v reshaping operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 pass A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 list\plain\fs20\cf1\cb1 {\v 40V8DY}, \uldb reshape\plain\fs20\cf1\cb1 {\v 3I4D_MA}\line

\par The operation \i pass\plain\fs20\cf1\cb1  is the identity operation for arrays.  It returns the argument \i A\plain\fs20\cf1\cb1 .  \i Pass\plain\fs20\cf1\cb1  is used when expressing computations in a functional style using an atlas (a list of operations).  
\par \pard\keep\sb95 \f1\fs16      pass 2 3 4 \line
2 3 4 \line
     pass 'hello world' \line
hello world\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      pass IS OPERATION A \{\- A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    pass A = first single A \line
   pass A = first solitary A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00d7}
{\up $}{\footnote\pard\plain{\up $} paste}
{\up #}{\footnote\pard\plain{\up #} TVJG0K}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 paste\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} paste;picture operation, paste}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul picture operation\plain\fs20\cf1\cb1 {\v picture operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Sw paste A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 picture\plain\fs20\cf1\cb1 {\v __8RKL}, \uldb sketch\plain\fs20\cf1\cb1 {\v .86S0D}, \uldb diagram\plain\fs20\cf1\cb1 {\v G5WG1G}, \uldb positions\plain\fs20\cf1\cb1 {\v 1AGU44_}\line

\par The operation \i paste\plain\fs20\cf1\cb1  combines character tables in a two dimensional layout.  It is used internally by \i picture\plain\fs20\cf1\cb1  and can be used to create modifications of the standard picture output to improve the display of results.  The left argument \i Sw\plain\fs20\cf1\cb1  has six parameters that control the layout and the right argument \i A\plain\fs20\cf1\cb1  is the array of tables to be combined.  The components of argument \i Sw\plain\fs20\cf1\cb1  are the following: 
\par \pard\sb95  \trowd\trgaph175\trleft-6 \cellx3885\cellx5795\pard\intbl\sb95 \b Argument \cell\pard \pard\intbl\sb95  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3885\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 Vertical edge spacing \cell\pard \pard\intbl\sb95 an integer indicating the number of blank lines to be put between the rows of items \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3885\cellx5795\pard\intbl\sb95 Horizontal edge spacing \cell\pard \pard\intbl\sb95 an integer indicating the number of blank spaces to be put between the columns of items \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3885\cellx5795\pard\intbl\sb95 Vertical line indicator \cell\pard \pard\intbl\sb95 If the value is 1, vertical lines are drawn between columns.  If it is 0, they are not \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3885\cellx5795\pard\intbl\sb95 Horizontal line indicator \cell\pard \pard\intbl\sb95 If the value is 1, horizontal lines are drawn between rows.  If it is 0, they are not \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3885\cellx5795\pard\intbl\sb95 Vertical justification indicator \cell\pard \pard\intbl\sb95 This is either a single integer indicating the same justification for all fields or an array of integers of the same shape as A indicating the justification for each item of A.  The codes are: 0 for top justification, 1 for centered and 2 for bottom justification \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3885\cellx5795\pard\intbl\sb95 Horizontal justification indicator \cell\pard \pard\intbl\sb95 This is either a single integer indicating the same justification for all fields, or an array of integers of the same shape as A indicating the justification for each item of A.  The codes are: 0 for left justification, 1 for centered and 2 for right justification \cell\intbl\row
\pard\sb95 \line

\par If either line indicator is 1, the entire result is boxed.  
\par \pard\keep\sb95 \f1\fs16      1 2 1 3 1 1 paste EACH sketch (2 4 reshape 'some' 'words' 'of' 'wisdom') \line
+--------+---------+------+----------+ \line
|        |         |      |          | \line
|  some  |  words  |  of  |  wisdom  | \line
|        |         |      |          | \line
+--------+---------+------+----------+ \line
|        |         |      |          | \line
|  some  |  words  |  of  |  wisdom  | \line
|        |         |      |          | \line
+--------+---------+------+----------+\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00d8}
{\up $}{\footnote\pard\plain{\up $} pervasive}
{\up #}{\footnote\pard\plain{\up #} 4E_0R6}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 pervasive\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, pervasive;pervasive}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}, \uldb binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}, \uldb multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}\line

\par Some of the operations of Nial that operate on simple arrays are extended to arbitrarily nested arrays by being applied to the atoms at the deepest level.  These are called \b pervasive\plain\fs20\cf1\cb1  operations.  \line

\par There are three classes of pervasive operations: \i unary pervasive\plain\fs20\cf1\cb1 , \i binary pervasive\plain\fs20\cf1\cb1  and \i multi pervasive\plain\fs20\cf1\cb1 .  The first class applies the operations to the atoms of the array. The second class are binary operations that apply to pairs of atoms from corresponding positions in the pair of arguments. The third class applies the operation to the simple arrays formed from atoms in corresponding positions in the items of the argument, reducing the simple array to a single atom.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00d9}
{\up $}{\footnote\pard\plain{\up $} phrase}
{\up #}{\footnote\pard\plain{\up #} 4.B5_UK}
\pard\keepn\sb95 \b\fs25 phrase\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} conversion operation, phrase;phrase}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 phrase S    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 string\plain\fs20\cf1\cb1 {\v .ACHEC}, \uldb fault\plain\fs20\cf1\cb1 {\v TLJI2Z}, \uldb tonumber\plain\fs20\cf1\cb1 {\v 1_RG0DJ}, \uldb isphrase\plain\fs20\cf1\cb1 {\v E7PW.M}\line

\par The operation \i phrase\plain\fs20\cf1\cb1  converts a string into a phrase with the same content.  It returns phrases and faults unchanged and converts other atoms after coercing them to their string equivalents.  The resulting phrase may contain blanks.  There is a one-to-one correspondence between phrases and strings.  
\par \pard\keep\sb95 \f1\fs16      phrase '(613) 549-2222' \line
(613) 549-2222 \line
 \line
     set "decor ; EACH phrase o 613 3.5 `A 'Now' "Wow ?error \line
"o "613 "3.5 "A "Now "Wow "error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    isphrase P ==> phrase string P = P \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Pragmatics\plain\fs20\cf1\cb1 \line

\par The correspondence between phrases and strings is not complete in that phrase cannot hold a null character (representation 0) and attempting to build such a phrase using the operation \i phrase\plain\fs20\cf1\cb1  will result in a truncated phrase.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00da}
{\up $}{\footnote\pard\plain{\up $} pi}
{\up #}{\footnote\pard\plain{\up #} RJ2SIX}
\pard\keepn\sb95 \b\fs25 pi\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} constant expression, pi;pi}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul constant expression\plain\fs20\cf1\cb1 {\v constant expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Pi    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 random\plain\fs20\cf1\cb1 {\v X7KC2Y}, \uldb ln\plain\fs20\cf1\cb1 {\v RJ2SF2}\line

\par The expression \i Pi\plain\fs20\cf1\cb1  returns the real number which is the ratio of the circumference of a circle to its diameter.  \i Pi\plain\fs20\cf1\cb1  is useful in scientific computing.  
\par \pard\keep\sb95 \f1\fs16      setformat '%15.12f' ; Pi \line
 3.141592653590\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    Pi = arccos -1 (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00db}
{\up $}{\footnote\pard\plain{\up $} pick}
{\up #}{\footnote\pard\plain{\up #} 40Z84P}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 pick\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} pick;selection operation, pick}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 I pick A   pick I A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 choose\plain\fs20\cf1\cb1 {\v 1XQ9M0F}, \uldb take\plain\fs20\cf1\cb1 {\v 25VVYWO}, \uldb first\plain\fs20\cf1\cb1 {\v 7CFFMJ}, \uldb address\plain\fs20\cf1\cb1 {\v 63.8K7}\line

\par \i Pick\plain\fs20\cf1\cb1  is the fundamental selection operation for arrays.  The normal use is that \i I\plain\fs20\cf1\cb1  is an address for \i A\plain\fs20\cf1\cb1 .  The result is the item that is located at address \i I\plain\fs20\cf1\cb1  in 0-origin addressing.  If \i I\plain\fs20\cf1\cb1  is a solitary integer and \i A\plain\fs20\cf1\cb1  is a list, \i I\plain\fs20\cf1\cb1  is converted to an integer to make it an address for a list.  If \i I\plain\fs20\cf1\cb1  is not a valid address for \i A\plain\fs20\cf1\cb1 , the result is the fault \i ?address\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      3 pick 3 6 23 46 57 25 \line
46 \line
 \line
     [3] pick 3 6 23 46 57 25 \line
46 \line
 \line
     A := 2 3 reshape "a "list "of "words "as "phrases \line
a     list of \line
words as   phrases \line
 \line
     0 2 pick A \line
of \line
 \line
     5 5 pick A \line
?address\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the first example, \i pick\plain\fs20\cf1\cb1  selects the fourth item because of 0-origin indexing.  In the second example, [3] is not an address of the list (its addresses are integers) but it is converted to integer 3.  Thus, a solitary integer can be used as an address of a list for \i pick\plain\fs20\cf1\cb1 .  The third example shows that an address for a table is a pair of integers.  The last example shows that picking out of range returns a fault.  \line

\par The concept of picking closely corresponds to subscript notation in mathematics.  Q'Nial supports a direct notation for subscripting a variable: \i Var@I\plain\fs20\cf1\cb1 .  This notation, called the \i at notation\plain\fs20\cf1\cb1 , can be used on both the left and right of an assignment expression.  Its use on the right is equivalent to \i pick\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    I pick A = (list I) pick A \line
   I in grid A ==> I pick grid A = I \line
   I in grid A ==> I pick (EACH f A) = f (I pick A) \line
   A choose B = A EACHLEFT pick B \line
   I pick A = \'5c[I] reach A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00dc}
{\up $}{\footnote\pard\plain{\up $} picture}
{\up #}{\footnote\pard\plain{\up #} __8RKL}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 picture\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} picture;picture operation, picture}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul picture operation\plain\fs20\cf1\cb1 {\v picture operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 picture A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 sketch\plain\fs20\cf1\cb1 {\v .86S0D}, \uldb diagram\plain\fs20\cf1\cb1 {\v G5WG1G}, \uldb display\plain\fs20\cf1\cb1 {\v GH5A1S}, \uldb paste\plain\fs20\cf1\cb1 {\v TVJG0K}, \uldb positions\plain\fs20\cf1\cb1 {\v 1AGU44_}, \uldb set\plain\fs20\cf1\cb1 {\v 1_E789J}\line

\par The operation \i picture\plain\fs20\cf1\cb1  computes a character table that describes the array \i A\plain\fs20\cf1\cb1 .  \line

\par An atom is displayed directly.  A nonatomic array is displayed as a tableau of rows and columns arranged to allow sufficient space for the largest items.  In most cases, the items of the array are displayed within a frame diagram.  \line

\par \pard\sb95 The operation is affected by the setting of two internal switches: \i diagram/sketch\plain\fs20\cf1\cb1  and \i decor/nodecor\plain\fs20\cf1\cb1 .  The first controls the use of frames in the pictures.  The second controls the decoration of atoms, solitaries, strings and empty arrays.  \line

\par In \i diagram\plain\fs20\cf1\cb1  mode, a nonatomic array is displayed with a frame and the upper left corner has an \i o\plain\fs20\cf1\cb1  if it is a single.  In sketch mode, a simple array, one having atomic items, is displayed without a frame.  A non-simple array has a frame and a nonatomic single has an \i o\plain\fs20\cf1\cb1  in the upper left corner of the frame.  \line

\par \pard\sb95 The \i decor/nodecor\plain\fs20\cf1\cb1  switch pictures atoms in an undecorated manner if nodecor mode is set.  If sketch mode is also set, strings and phrases appear the same.  The decor mode pictures atoms so that they can be distinguished: characters are preceded by a grave symbol \i `\plain\fs20\cf1\cb1 , phrases by a double quote \i "\plain\fs20\cf1\cb1  and faults by a question mark \i ?\plain\fs20\cf1\cb1 .  In sketch mode with decor set, a string is enclosed in quotes and a simple solitary is placed in brackets.  \line

\par In sketch mode an empty array has an empty picture, whereas in diagram mode, the picture of an empty array is one side of a frame diagram, with no items.  \line

\par \pard\sb95 An array of dimensionality higher than two is laid out as an arrangement of tables.  If the array has valence 3, the tables are arranged horizontally.  If it has valence 4, the first axis is placed down the page and the second axis across the page.  Thus, an array of shape 3 4 5 6 is pictured as 3 rows of 4 tables each of which is a 5 by 6 tableau.  A space is left between each of the tables.  For higher dimensions, the axes continue to alternate across and down the page with greater spacing between arrangements.  \line

\par \pard\sb95 The result of \i picture\plain\fs20\cf1\cb1  coincides with the output displayed by Q'Nial in the top level loop.  \line

\par In the top level loop, the picture is wrapped around as a whole if it is too wide to fit on the screen.  
\par \pard\keep\sb95 \f1\fs16      set "sketch; set "nodecor; \line
     P := picture l 1 7 7.0 `a "a 'a' (3 4 5) Null \line
+-+-+-+--+-+-+-+-----++ \line
|l|1|7|7.|a|a|a|3 4 5|| \line
+-+-+-+--+-+-+-+-----++ \line
 \line
     set "diagram; set "nodecor; P \line
+-+-+-+--+-+-+---+-------+-+ \line
|l|1|7|7.|a|a|+-+|+-+-+-+|+| \line
| | | |  | | ||a|||3|4|5|||| \line
| | | |  | | |+-+|+-+-+-+|+| \line
+-+-+-+--+-+-+---+-------+-+ \line
 \line
     set "sketch; set "decor; P \line
+-+-+-+--+--+--+---+-----++ \line
|l|1|7|7.|`a|"a|'a'|3 4 5|| \line
+-+-+-+--+--+--+---+-----++ \line
 \line
     set "diagram; set "decor; P \line
+-+-+-+--+--+--+----+-------+-+ \line
|l|1|7|7.|`a|"a|+--+|+-+-+-+|+| \line
| | | |  |  |  ||`a|||3|4|5|||| \line
| | | |  |  |  |+--+|+-+-+-+|+| \line
+-+-+-+--+--+--+----+-------+-+ \line
 \line
     set "diagram; set "decor; \line
     picture 3 4 5 \line
+--+--+--+--+--+--+--+ \line
|`+|`-|`+|`-|`+|`-|`+| \line
+--+--+--+--+--+--+--+ \line
|`||`3|`||`4|`||`5|`|| \line
+--+--+--+--+--+--+--+ \line
|`+|`-|`+|`-|`+|`-|`+| \line
+--+--+--+--+--+--+--+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first four examples illustrate the same array pictured with the four combinations of the mode settings.  The final example illustrates that if the result of \i picture\plain\fs20\cf1\cb1  is displayed at top level in diagram - decor mode, the implicit use of \i picture\plain\fs20\cf1\cb1  on the resulting character table causes it to be decorated.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    write A = writescreen picture A \line
   valence picture A = 2 \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00dd}
{\up $}{\footnote\pard\plain{\up $} place}
{\up #}{\footnote\pard\plain{\up #} TVU4TK}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 place\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} insertion operation, place;place}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul insertion operation\plain\fs20\cf1\cb1 {\v insertion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 B I place A   place (B I) A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 pick\plain\fs20\cf1\cb1 {\v 40Z84P}, \uldb placeall\plain\fs20\cf1\cb1 {\v 1_2.DUD}, \uldb deepplace\plain\fs20\cf1\cb1 {\v 0UY7YL}, \uldb update\plain\fs20\cf1\cb1 {\v 4AIR_VK}\line

\par The operation \i place\plain\fs20\cf1\cb1  is the fundamental insertion operation for arrays.  The normal use is that \i I\plain\fs20\cf1\cb1  is the address where \i B\plain\fs20\cf1\cb1  is to be placed in a modified version of \i A\plain\fs20\cf1\cb1 .  The result is the modified array.  If \i I\plain\fs20\cf1\cb1  is a solitary integer and \i A\plain\fs20\cf1\cb1  is a list, \i I\plain\fs20\cf1\cb1  is converted to an integer before being used.  If \i I\plain\fs20\cf1\cb1  is not a valid address for \i A\plain\fs20\cf1\cb1 , the result is the fault \i ?address\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      "abc 2 place 2 3 4 5 6 \line
2 3 abc 5 6 \line
     place (`_ 2) 'my work' \line
my_work \line
     A := 4 5 6 7 \line
4 5 6 7 \line
     A := 27 2 place A; A \line
4 5 27 7 \line
     50 100 place A \line
?address\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The fourth example shows the use of \i place\plain\fs20\cf1\cb1  in updating the value of a variable \i A\plain\fs20\cf1\cb1 .  The last example illustrates an out of range use of \i place\plain\fs20\cf1\cb1 .  \line

\par Nial provides a simpler notation for updating a variable.  \i A@I\plain\fs20\cf1\cb1  (pronounced \i A at I\plain\fs20\cf1\cb1 ) can be used on the left of assignment to update the item at location \i I\plain\fs20\cf1\cb1 .  If the address is out of range a fault occurs.  
\par \pard\keep\sb95 \f1\fs16      A@1 := 25 \line
4 25 27 7 \line
     A@5 := 7 \line
?address \line
     A \line
4 25 27 7\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The semantics of using the \i at notation\plain\fs20\cf1\cb1  on the left in assignment can be achieved using the operation \i update\plain\fs20\cf1\cb1 .  The \i at notation\plain\fs20\cf1\cb1  and the \i update\plain\fs20\cf1\cb1  operation are usually more efficient than \i place\plain\fs20\cf1\cb1  because they avoid doing a copy of the right argument of \i place\plain\fs20\cf1\cb1 .\line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    I in grid A ==> (I pick A) I place A = A \line
   B \'5c[I] deepplace A = B I place A \line
   I in grid A ==>shape(B I place A) = shape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00de}
{\up $}{\footnote\pard\plain{\up $} placeall}
{\up #}{\footnote\pard\plain{\up #} 1_2.DUD}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 placeall\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} insertion operation, placeall;placeall}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul insertion operation\plain\fs20\cf1\cb1 {\v insertion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 B I placeall A   placeall (B I) A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 place\plain\fs20\cf1\cb1 {\v TVU4TK}, \uldb deepplace\plain\fs20\cf1\cb1 {\v 0UY7YL}, \uldb updateall\plain\fs20\cf1\cb1 {\v I.4L_C}\line

\par The operation \i placeall\plain\fs20\cf1\cb1  generalizes the operation \i place\plain\fs20\cf1\cb1  to modify a collection of items of \i A\plain\fs20\cf1\cb1 .  It returns a modified version of array \i A\plain\fs20\cf1\cb1  with the items at the addresses \i I\plain\fs20\cf1\cb1  replaced by the items of \i B\plain\fs20\cf1\cb1 .  It corresponds to the sequential use of \i place\plain\fs20\cf1\cb1  with corresponding items from \i B\plain\fs20\cf1\cb1  and \i I\plain\fs20\cf1\cb1 .  If an item of \i I\plain\fs20\cf1\cb1  is repeated, its last occurrence will determine the effect on \i A\plain\fs20\cf1\cb1 .  If \i B\plain\fs20\cf1\cb1  has fewer items than \i I\plain\fs20\cf1\cb1 , its items are used cyclically (the first item is used after the last and the list repeated).  
\par \pard\keep\sb95 \f1\fs16      ("abc "def) (2 3) placeall 2 3 4 5 6 \line
2 3 abc def 6 \line
 \line
     Text := 'my work is fun'; \line
     placeall ('_' (`  findall Text)) Text \line
my_work_is_fun \line
 \line
     A := 4 5 6 7 ; \line
     A := (27 28) (3 2) placeall A; A \line
4 5 28 27\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The last example shows the use of \i placeall\plain\fs20\cf1\cb1  to update the value of a variable \i A\plain\fs20\cf1\cb1 .  \line

\par Q'Nial provides a simpler notation for updating a variable at several locations.  The notation \i A#I\plain\fs20\cf1\cb1  (pronounced \i A at all I\plain\fs20\cf1\cb1 ) can be used on the left of assignment to indicate the update of the items at the addresses given by \i I\plain\fs20\cf1\cb1 .  If an item of \i I\plain\fs20\cf1\cb1  is out of range, the result is a fault but the variable is modified by the assignments done to locations that precede the invalid one.  
\par \pard\keep\sb95 \f1\fs16      A#(0 1) := 25 26 \line
25 26 27 7 \line
     A#(2 100) := 50 51 \line
?addresses \line
     A \line
25 26 50 7\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The semantics of using the \i at all\plain\fs20\cf1\cb1  notation on the left in assignment can be achieved using the operation updateall.  \line

\par The \i at all\plain\fs20\cf1\cb1  notation and the \i updateall\plain\fs20\cf1\cb1  operation are usually more efficient than \i placeall\plain\fs20\cf1\cb1  as they avoid doing a copy of the entire right argument of \i placeall\plain\fs20\cf1\cb1 .  \line

\par \i Placeall\plain\fs20\cf1\cb1  is not the same as \i (pack B I) EACHBOTH place A\plain\fs20\cf1\cb1 .  The latter results in an array of modifications of \i A\plain\fs20\cf1\cb1 , one for each item to be replaced.  \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    I allin grid A ==> (I choose A) I placeall A = A \line
   I allin grid A ==> shape (B I placeall A) = shape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00df}
{\up $}{\footnote\pard\plain{\up $} plus}
{\up #}{\footnote\pard\plain{\up #} 1CMG0JM}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 plus\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, plus;plus}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A plus B   plus A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 sum\plain\fs20\cf1\cb1 {\v 1_E78IC}, \uldb minus\plain\fs20\cf1\cb1 {\v 7JFBOI}, \uldb mod\plain\fs20\cf1\cb1 {\v 1_E72C0}, \uldb opposite\plain\fs20\cf1\cb1 {\v 18Y3XQ}, \uldb times\plain\fs20\cf1\cb1 {\v 5JEP_NH}\line

\par The operation \i plus\plain\fs20\cf1\cb1  is the same as \i sum\plain\fs20\cf1\cb1  except that \i plus\plain\fs20\cf1\cb1  enforces the rule that it must be applied to a pair.  \line

\par \i Sum\plain\fs20\cf1\cb1  is multi pervasive and can add up any number of items.  The symbol \i +\plain\fs20\cf1\cb1  is a synonym for \i sum\plain\fs20\cf1\cb1 .
\par \pard\keep\sb95 \f1\fs16      7 plus 9 \line
16 \line
 \line
     (2 3 4) plus (12 22 33) \line
14 25 37 \line
 \line
     plus 2 3 4 \line
?plus expects a pair\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00e0}
{\up $}{\footnote\pard\plain{\up $} positions}
{\up #}{\footnote\pard\plain{\up #} 1AGU44_}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 positions\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} picture operation, positions;positions}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul picture operation\plain\fs20\cf1\cb1 {\v picture operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 positions A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 sketch\plain\fs20\cf1\cb1 {\v .86S0D}, \uldb diagram\plain\fs20\cf1\cb1 {\v G5WG1G}, \uldb picture\plain\fs20\cf1\cb1 {\v __8RKL}, \uldb display\plain\fs20\cf1\cb1 {\v GH5A1S}, \uldb paste\plain\fs20\cf1\cb1 {\v TVJG0K}\line

\par The operation \i positions\plain\fs20\cf1\cb1  is used in conjunction with \i picture\plain\fs20\cf1\cb1  on singles, lists or tables.  For such arrays, it returns an array of the same shape with the items being the addresses at which the pictures of the corresponding items of \i A\plain\fs20\cf1\cb1  appear in the picture of \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      A gets 2 3 reshape "cat 'fish' 34.5 "dog 'meat' 26.5 \line
+---+----+----+ \line
|cat|fish|34.5| \line
+---+----+----+ \line
|dog|meat|26.5| \line
+---+----+----+ \line
 \line
     positions A \line
+---+---+----+ \line
|1 1|1 5|1 10| \line
+---+---+----+ \line
|3 1|3 5|3 10| \line
+---+---+----+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The operation \i positions\plain\fs20\cf1\cb1  is useful in applications that do interactive editing of data from its display on the screen.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00e1}
{\up $}{\footnote\pard\plain{\up $} post}
{\up #}{\footnote\pard\plain{\up #} 1CMG_HN}
\pard\keepn\sb95 \b\fs25 post\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} post;reshaping operation, post}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul reshaping operation\plain\fs20\cf1\cb1 {\v reshaping operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 post A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 reshape\plain\fs20\cf1\cb1 {\v 3I4D_MA}, \uldb list\plain\fs20\cf1\cb1 {\v 40V8DY}, \uldb pass\plain\fs20\cf1\cb1 {\v 1CMFZHM}, \uldb cols\plain\fs20\cf1\cb1 {\v QCY_U_}\line

\par The operation \i post\plain\fs20\cf1\cb1  restructures an array \i A\plain\fs20\cf1\cb1  to be a table with one column holding the items of \i A\plain\fs20\cf1\cb1  in row major order.  
\par \pard\keep\sb95 \f1\fs16      post 3 4 5 \line
3 \line
4 \line
5 \line
 \line
     post 'Now is the time' \line
          'for all good men' \line
          'to come to the aid' \line
          'of the party' \line
+------------------+ \line
|Now is the time   | \line
+------------------+ \line
|for all good men  | \line
+------------------+ \line
|to come to the aid| \line
+------------------+ \line
|of the party      | \line
+------------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The major purpose of post is to restructure data for display.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      post IS OPERATION A \{\- (tally A) 1 reshape A\'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape post A = (tally A) 1 \line
   post post A = post A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00e2}
{\up $}{\footnote\pard\plain{\up $} power}
{\up #}{\footnote\pard\plain{\up #} TVXJVX}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 power\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, power;power}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A power B   power A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}, \uldb sqrt\plain\fs20\cf1\cb1 {\v 47GO_O8}, \uldb divide\plain\fs20\cf1\cb1 {\v 6242D6P}, \uldb ln\plain\fs20\cf1\cb1 {\v RJ2SF2}, \uldb exp\plain\fs20\cf1\cb1 {\v 1_E6ULF}\line

\par The operation \i power\plain\fs20\cf1\cb1  returns the result of raising the number \i A\plain\fs20\cf1\cb1  to the power \i B\plain\fs20\cf1\cb1 .  The result is an integer if both \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  are boolean or integer and \i B\plain\fs20\cf1\cb1  is non-negative.  If \i B\plain\fs20\cf1\cb1  is an integer, the power is done by multiplication.  Otherwise it uses \i exp (B * ln A)\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      R gets l 2 2.5 `a "abc ??error \line
l 2 2.5 a abc ?error \line
 \line
     R OUTER power R \line
     1        1        1.  ?A  ?A  ?error \line
     2        4   5.65685  ?A  ?A  ?error \line
   2.5     6.25   9.88212  ?A  ?A  ?error \line
?A      ?A       ?A        ?A  ?A  ?A \line
?A      ?A       ?A        ?A  ?A  ?A \line
?error  ?error   ?error    ?A  ?A  ?error \line
 \line
     2 power 3 \line
8 \line
 \line
     2 power -3 \line
0.125 \line
 \line
     16 power .5 \line
4.\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The examples show that \i power\plain\fs20\cf1\cb1  has different meanings depending on the right argument \i B\plain\fs20\cf1\cb1 .  If \i B\plain\fs20\cf1\cb1  is a positive integer, the result is \i A\plain\fs20\cf1\cb1  multiplied by itself \i B\plain\fs20\cf1\cb1  times.  If \i B\plain\fs20\cf1\cb1  is a negative integer, the result is the reciprocal of the result when \i B\plain\fs20\cf1\cb1  is positive.  The last case illustrates that if \i B\plain\fs20\cf1\cb1  is 0.5, the result is a real number that is a square root of \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    isreal B ==> A power B = exp (B * ln A) \line
   sqrt A = A power 0.5   (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00e3}
{\up $}{\footnote\pard\plain{\up $} predicate}
{\up #}{\footnote\pard\plain{\up #} QJ_HSO}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 predicate\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} operation property, predicate;predicate}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul operation property\plain\fs20\cf1\cb1 {\v operation property}\line

\par \pard\sb95 A \b predicate\plain\fs20\cf1\cb1  is an operation that tests a condition and returns true if the condition holds and false otherwise.  A predicate is not pervasive.  \line

\par The predefined predicate operations include:
\par  \trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 \b Operation \cell\pard \pard\intbl\sb95 Test \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 allin \cell\pard \pard\intbl\sb95 set-like inclusion \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 atomic \cell\pard \pard\intbl\sb95 an array is an atom \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 diverse \cell\pard \pard\intbl\sb95 all items differ \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 empty \cell\pard \pard\intbl\sb95 an array has no items \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 equal \cell\pard \pard\intbl\sb95 all items are equal \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 isboolean \cell\pard \pard\intbl\sb95 arg is a boolean atom \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 ischar \cell\pard \pard\intbl\sb95 arg is a character atom \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 isfault \cell\pard \pard\intbl\sb95 arg is a fault symbol \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 isinteger \cell\pard \pard\intbl\sb95 arg is a integer number \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 isphrase \cell\pard \pard\intbl\sb95 arg is a symbol \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 isreal \cell\pard \pard\intbl\sb95 arg is a real number \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 isstring \cell\pard \pard\intbl\sb95 arg is a list of characters \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 like \cell\pard \pard\intbl\sb95 two arrays contain same items \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 regexp_match \cell\pard \pard\intbl\sb95 string matches a regular expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 simple \cell\pard \pard\intbl\sb95 all items are atoms \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 unequal \cell\pard \pard\intbl\sb95 items are not all equal \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 up \cell\pard \pard\intbl\sb95 lexical ordering \cell\intbl\row
\pard \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00e4}
{\up $}{\footnote\pard\plain{\up $} prefix notation}
{\up #}{\footnote\pard\plain{\up #} 16XL468}
\pard\keepn\sb95 \b\fs25 prefix notation\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} prefix notation;syntax, prefix notation}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 infix notation\plain\fs20\cf1\cb1 {\v 50FXVP}\line

\par An operation-expression can precede an array-expression.  This is called a \b prefix\plain\fs20\cf1\cb1  use of the operation expression.
\par \pard\keep\sb95 \f1\fs16         + 7 5 \line
12 \line
 \line
     reshape [2 3,1 2 3 4 5 6] \line
1 2 3 \line
4 5 6 \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00e5}
{\up $}{\footnote\pard\plain{\up $} prelattice of atoms}
{\up #}{\footnote\pard\plain{\up #} 1N6N36O}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 prelattice of atoms\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, prelattice of atoms;prelattice of atoms}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 lte\plain\fs20\cf1\cb1 {\v 1ZNC14K}, \uldb up\plain\fs20\cf1\cb1 {\v RJ2SO4}, \uldb max\plain\fs20\cf1\cb1 {\v 1_E725N}\line

\par The ordering sequence of the characters for sorting purposes is fixed for each Q'Nial version.  \line

\par The binary and multi pervasive comparative operations of Nial organize the atoms of Nial in a \b prelattice\plain\fs20\cf1\cb1  or sorting sequence.  The operation \i lte\plain\fs20\cf1\cb1  (or \i <=\plain\fs20\cf1\cb1 ) does a less than or equal comparison between atoms.  The numeric atoms are comparable, with a coercion being done if the arguments are of different numeric type.  The \i nadir\plain\fs20\cf1\cb1 , represented by the fault \i ?O\plain\fs20\cf1\cb1 , is less than or equal to all atoms.  The \i zenith\plain\fs20\cf1\cb1 , \i ?I\plain\fs20\cf1\cb1 , is greater than or equal to all atoms.  Except for these two special cases, literal atoms are incomparable with atoms of different type.  However, they can be compared within the same type using a character collating sequence that is version specific.  \line

\par \pard\sb95 Phrases are compared lexicographically, such that \i "apple\plain\fs20\cf1\cb1  is after \i "ape\plain\fs20\cf1\cb1  but before \i "apt\plain\fs20\cf1\cb1 .  Strings, being character lists, produce a list of results when compared.  \line

\par Comparisons are of two forms: binary pervasive predicates which return boolean values and multi pervasive predicates that obtain the largest or smallest item in a list.  If two atoms are incomparable, the predicates return \i false\plain\fs20\cf1\cb1 , whereas \i max\plain\fs20\cf1\cb1  returns the \i zenith\plain\fs20\cf1\cb1  and \i min\plain\fs20\cf1\cb1  returns the \i nadir\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 These rules were chosen so that the following laws hold for all arrays \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1 : 
\par \pard\keep\sb95 \f1\fs16    max A <= B = and (A EACHLEFT <= B) \line
   A <= min B = and (A EACHRIGHT <= B) \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 See the entry for \i up\plain\fs20\cf1\cb1  for a discussion of the lexicographic ordering in Q'Nial.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00e6}
{\up $}{\footnote\pard\plain{\up $} product}
{\up #}{\footnote\pard\plain{\up #} 2H9LPX5}
\pard\keepn\sb95 \b\fs25 product\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, product;product}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Properties:  \uldb \plain\uldb\fs20\cf1\cb1 multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}, \uldb reductive\plain\fs20\cf1\cb1 {\v 7GGROL}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 product A   * A   A product B   A * B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 times\plain\fs20\cf1\cb1 {\v 5JEP_NH}, \uldb divide\plain\fs20\cf1\cb1 {\v 6242D6P}, \uldb sum\plain\fs20\cf1\cb1 {\v 1_E78IC}, \uldb plus\plain\fs20\cf1\cb1 {\v 1CMG0JM}, \uldb minus\plain\fs20\cf1\cb1 {\v 7JFBOI}\line

\par The operation \i product\plain\fs20\cf1\cb1  multiplies the items of a simple array of numbers, reducing them to a single number that is their product.  The type of the result is the highest type of the items.  The operation is extended to non-simple arrays by the multi pervasive mechanism.  The symbol \i *\plain\fs20\cf1\cb1  and \i prod\plain\fs20\cf1\cb1  are synonyms for \i product\plain\fs20\cf1\cb1 .  The operation \i times\plain\fs20\cf1\cb1  is \i product\plain\fs20\cf1\cb1  restricted to use on pairs.  \line

\par \pard\sb95 For an empty array, the result is 1.
\par \pard\keep\sb95 \f1\fs16      R gets l 2 2.5 `a "abc ??error \line
l 2 2.5 a abc ?error \line
 \line
     R OUTER product R \line
     1       2      2.5  ?A  ?A  ?error \line
     2       4       5.  ?A  ?A  ?error \line
   2.5      5.     6.25  ?A  ?A  ?error \line
?A      ?A      ?A       ?A  ?A  ?A \line
?A      ?A      ?A       ?A  ?A  ?A \line
?error  ?error  ?error   ?A  ?A  ?error \line
 \line
     product 3. 45. 23. 18. 3.5 \line
195615. \line
 \line
     product (3 4 5)(2 3 2)(0 2 4)(1 1 1) \line
0 24 40\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows the result of \i product\plain\fs20\cf1\cb1  on all combinations of types of atoms.  The last example shows that pervasive extension of \i product\plain\fs20\cf1\cb1  multiples a list of triples in an item by item fashion.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A product B = B product B \line
   product single A = EACH(product single) A \line
   product EACH product A =f= product link A \line
   shape cart A = product EACH tally A \line
   product shape A = tally A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00e7}
{\up $}{\footnote\pard\plain{\up $} profile}
{\up #}{\footnote\pard\plain{\up #} FHUFEL}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 profile\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} profile;profiling operation, profile}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul profiling operation\plain\fs20\cf1\cb1 {\v profiling operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 profile Fnm    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 setprofile\plain\fs20\cf1\cb1 {\v H2UBBE}, \uldb clearprofile\plain\fs20\cf1\cb1 {\v 90MFAZ}, \uldb profiletable\plain\fs20\cf1\cb1 {\v _8MA7D}, \uldb profiletree\plain\fs20\cf1\cb1 {\v H3PT41}, \uldb profiling\plain\fs20\cf1\cb1 {\v 1_IJW3H}\line

\par The operation \i profile\plain\fs20\cf1\cb1  is used to convert the profiling statistics into a displayable form.  If \i Fnm\plain\fs20\cf1\cb1  is a file name, as a string or a phrase, then the output is written to the file.  If it is the empty string, then the profiling information is displayed on the screen.  If logging is on, it will be copied to the log file.  The gathering of profile statistics must be turned off when \i profile\plain\fs20\cf1\cb1  is called.  \line

\par \pard\sb95 A detailed example of the output is given in the help entry on profiling.  \line

\par Examples of use: 
\par \pard\keep\sb95 \f1\fs16      profile "myprofl \line
 \line
     profile '' \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00e8}
{\up $}{\footnote\pard\plain{\up $} profiletable}
{\up #}{\footnote\pard\plain{\up #} _8MA7D}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 profiletable\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} profiletable;profiling expression, profiletable}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul profiling expression\plain\fs20\cf1\cb1 {\v profiling expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Profiletable    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 profile\plain\fs20\cf1\cb1 {\v FHUFEL}, \uldb setprofile\plain\fs20\cf1\cb1 {\v H2UBBE}, \uldb clearprofile\plain\fs20\cf1\cb1 {\v 90MFAZ}, \uldb profiling\plain\fs20\cf1\cb1 {\v 1_IJW3H}\line

\par The expression \i Profiletable\plain\fs20\cf1\cb1  is used to summarize the internal data structures that are used in the gathering of profiling statistics to produce the same information that is displayed by the operation \i profile\plain\fs20\cf1\cb1 .  It produces a list of entries, one for each definition that has been encountered during execution with profiling on.  Each entry includes the name, the number of direct calls, the number of recursive calls, the execution time, and a list of subentries for the definitions directly called by the definition.  The subentries summarize the information for the called definitions in the same format except that no further breakdown is given on definitions they call.  \line

\par \pard\sb95 A detailed example of the output of \i Profiletable\plain\fs20\cf1\cb1  is given in the help entry on profiling.  
\par \pard\keep\sb95 \f1\fs16      Profiletable \line
+-----------------+-------------------------------------+--- \line
|+----+--+-+----++|+-----+--+-+----+-------------------+|+-- \line
||test|12|0|4.12||||tryit|11|0|4.12|+-----------------+|||ag \line
|+----+--+-+----++||     |  | |    ||+----+--+-+----++||||   \line
|                 ||     |  | |    |||test|11|0|4.12||||||   \line
|                 ||     |  | |    ||+----+--+-+----++||||   \line
|                 ||     |  | |    |+-----------------+|||   \line
|                 |+-----+--+-+----+-------------------+|+-- \line
+-----------------+-------------------------------------+--- \line
 \line
----------------------------------+ \line
---+-+-+----+--------------------+| \line
ain|1|0|3.96|+------------------+|| \line
   | | |    ||+-----+--+-+----++||| \line
   | | |    |||tryit|10|0|3.96||||| \line
   | | |    ||+-----+--+-+----++||| \line
   | | |    |+------------------+|| \line
---+-+-+----+--------------------+| \line
----------------------------------+\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00e9}
{\up $}{\footnote\pard\plain{\up $} profiletree}
{\up #}{\footnote\pard\plain{\up #} H3PT41}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 profiletree\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} profiletree;profiling expression, profiletree}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul profiling expression\plain\fs20\cf1\cb1 {\v profiling expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Profiletree    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 profile\plain\fs20\cf1\cb1 {\v FHUFEL}, \uldb setprofile\plain\fs20\cf1\cb1 {\v H2UBBE}, \uldb clearprofile\plain\fs20\cf1\cb1 {\v 90MFAZ}, \uldb profiletable\plain\fs20\cf1\cb1 {\v _8MA7D}, \uldb profiling\plain\fs20\cf1\cb1 {\v 1_IJW3H}\line

\par The expression \i Profiletree\plain\fs20\cf1\cb1  is used to display the detailed information from the internal data structures that are used in the gathering of profiling statistics.  It produces a nested list of entries showing the calling dynamic calling sequence from top level, with the amount of time and number of calls at each level.  Each entry includes the name, the number of direct calls, the execution time, and a list of subentries for the definitions directly called by the definition.  The subentries provide the same information for the called definitions in the same format including entries on all the definitions that they call in turn.  \line

\par \pard\sb95 A detailed example of the output of \i Profiletable\plain\fs20\cf1\cb1  is given in the help entry on profiling.  \line

\par Example of use: 
\par \pard\keep\sb95 \f1\fs16      Profiletree \line
+--------+-+----+------------------------------------------- \line
|TOPLEVEL|0|4.18|+------------+----------------------------- \line
|        | |    ||+----+-+--++|+-----+-+----+--------------- \line
|        | |    |||test|1|0.||||tryit|1|0.16|+-------------- \line
|        | |    ||+----+-+--++||     | |    ||+----+-+----++ \line
|        | |    ||            ||     | |    |||test|1|0.16|| \line
|        | |    ||            ||     | |    ||+----+-+----++ \line
|        | |    ||            ||     | |    |+-------------- \line
|        | |    ||            |+-----+-+----+--------------- \line
|        | |    ||            |                              \line
|        | |    ||            |                              \line
|        | |    ||            |                              \line
|        | |    ||            |                              \line
|        | |    |+------------+----------------------------- \line
+--------+-+----+------------------------------------------- \line
 \line
------------------------------------------------------+ \line
--+--------------------------------------------------+| \line
-+|+-----+-+----+-----------------------------------+|| \line
+|||again|1|3.96|+---------------------------------+||| \line
||||     | |    ||+-----+--+----+-----------------+|||| \line
||||     | |    |||tryit|10|3.96|+---------------+||||| \line
||||     | |    |||     |  |    ||+----+--+----++|||||| \line
+|||     | |    |||     |  |    |||test|10|3.96|||||||| \line
-+||     | |    |||     |  |    ||+----+--+----++|||||| \line
  ||     | |    |||     |  |    |+---------------+||||| \line
  ||     | |    ||+-----+--+----+-----------------+|||| \line
  ||     | |    |+---------------------------------+||| \line
  |+-----+-+----+-----------------------------------+|| \line
--+--------------------------------------------------+| \line
------------------------------------------------------+\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ea}
{\up $}{\footnote\pard\plain{\up $} profiling}
{\up #}{\footnote\pard\plain{\up #} 1_IJW3H}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 profiling\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, profiling;profiling}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 setprofile\plain\fs20\cf1\cb1 {\v H2UBBE}, \uldb profile\plain\fs20\cf1\cb1 {\v FHUFEL}\line

\par \b Q'Nial Profiling Facility\plain\fs20\cf1\cb1 \line

\par Q'Nial has a profiling capability that is used to gather relative execution times for operations, transformers and defined expressions written in Nial.  The profiling capability has the following features: 
\par  \trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 \b Command \cell\pard \pard\intbl\sb95 Purpose \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 setprofile A \cell\pard \pard\intbl\sb95 turns on or off the internal routines that collect the statistics \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 profile Fnm \cell\pard \pard\intbl\sb95 that displays the profile data to the screen or writes it to a file \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 Clearprofile \cell\pard \pard\intbl\sb95 clears the current profile information and reinitializes the profiling system \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 Profiletable \cell\pard \pard\intbl\sb95 provides the profile information as a table \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 Profiletree \cell\pard \pard\intbl\sb95 provides the detailed profile information in terms of the call tree \cell\intbl\row
\pard\sb95 \line

\par The operation \i setprofile\plain\fs20\cf1\cb1  is called with argument \i l\plain\fs20\cf1\cb1  to turn on the collection of data for a profiling session.  It is called with argument \i o\plain\fs20\cf1\cb1  to suspend gathering statistics for a session. Both calls to \i setprofile\plain\fs20\cf1\cb1  should be in the same scope, and cannot be nested. Only one profiling session can be underway at a time.\line

\par The operation \i profile\plain\fs20\cf1\cb1  is called with a text argument (string or phrase) that is used as the file name for the profile information. If an empty string is the argument, the output is sent directly to the screen. It computes the statistics on the profiling session underway, prepares the output, and writes it to the file.\line

\par \pard\sb95 The expression \i Clearprofile\plain\fs20\cf1\cb1  clears the two internal data structures that are built as execution is profiled so that a new profiling session can be started. \line

\par The expression \i Profiletree\plain\fs20\cf1\cb1  provides the summary data that is displayed in the output produced by \i profile\plain\fs20\cf1\cb1 , but stores it in a Nial array.\line

\par The expression \i Profiletree\plain\fs20\cf1\cb1  provides a dynamic call tree of the execution with related times. This provides a more detailed breakdown of the profile data.  The following session illustrates the use of the profiling capability: 
\par \pard\keep\sb95 \f1\fs16 \tab setwidth 60; \line
 \line
     test is op n \{\- \line
       z := random n n; \line
       max abs (z - inv inv z) \'7d \line
 \line
     tryit is  op N \{\- test N \'7d \line
 \line
     again is op M N \{\- sum EACH tryit (M reshape N) \'7d \line
 \line
     fact is op n \{\-  \line
       IF n<=1 THEN 1 ELSE n * fact (n - 1) ENDIF \'7d \line
 \line
# first profiling session \line
 \line
     setprofile l \line
o \line
 \line
     test 20  \line
3.86843e-15 \line
 \line
     tryit 50 \line
2.83107e-14 \line
 \line
     again 10 75 \line
6.72483e-13 \line
 \line
     setprofile o \line
l \line
 \line
     profile '' \line
 \line
Total execution time of profile session: \tab 4.780000 \line
Total execution time in top level calls:  \tab 4.420000 \line
 \line
op name[.tr arg]                 calls[rec]    time time/call  % time \line
test..........................   12           4.42   0.3683    100.0< \line
 \line
tryit.........................   11           4.31   0.3918     97.5< \line
 test.........................   11           4.31   0.3918   100.00 \line
 \line
again.........................    1           4.04   4.0400     91.4< \line
 tryit........................   10           4.04   0.4040   100.00 \line
 \line
 \line
 \line
\tab profiletree \line
+--------+-+----+------------------------------------------- \line
|TOPLEVEL|0|4.78|+--------------+--------------------------- \line
|        | |    ||+----+-+----++|+-----+-+----+------------- \line
|        | |    |||test|1|0.11||||tryit|1|0.27|+------------ \line
|        | |    ||+----+-+----++||     | |    ||+----+-+---- \line
|        | |    ||              ||     | |    |||test|1|0.27 \line
|        | |    ||              ||     | |    ||+----+-+---- \line
|        | |    ||              ||     | |    |+------------ \line
|        | |    ||              |+-----+-+----+------------- \line
|        | |    ||              |                            \line
|        | |    ||              |                            \line
|        | |    ||              |                            \line
|        | |    ||              |                            \line
|        | |    |+--------------+--------------------------- \line
+--------+-+----+------------------------------------------- \line
 \line
--------------------------------------------------------+ \line
----+--------------------------------------------------+| \line
---+|+-----+-+----+-----------------------------------+|| \line
--+|||again|1|4.04|+---------------------------------+||| \line
++||||     | |    ||+-----+--+----+-----------------+|||| \line
||||||     | |    |||tryit|10|4.04|+---------------+||||| \line
++||||     | |    |||     |  |    ||+----+--+----++|||||| \line
--+|||     | |    |||     |  |    |||test|10|4.04|||||||| \line
---+||     | |    |||     |  |    ||+----+--+----++|||||| \line
    ||     | |    |||     |  |    |+---------------+||||| \line
    ||     | |    ||+-----+--+----+-----------------+|||| \line
    ||     | |    |+---------------------------------+||| \line
    |+-----+-+----+-----------------------------------+|| \line
----+--------------------------------------------------+| \line
--------------------------------------------------------+ \line
 \line
# second profiling session \line
 \line
     clearprofile \line
 \line
     setprofile l \line
o \line
 \line
     test 30 \line
1.72085e-14 \line
 \line
     fact 4 \line
24 \line
 \line
     setprofile o \line
l \line
 \line
     profile '' \line
 \line
Total execution time of profile session: \tab 0.330000 \line
Total execution time in top level calls:  \tab 0.050000 \line
 \line
op name[.tr arg]                 calls[rec]    time time/call  % time \line
test..........................    1           0.01   0.0100     20.0< \line
 \line
fact..........................    1[    3]    0.04   0.0400     80.0< \line
 \line
 \line
 \line
     profiletree \line
+--------+-+----+------------------------------------------- \line
|TOPLEVEL|0|0.33|+--------------+--------------------------- \line
|        | |    ||+----+-+----++|+----+-+----+-------------- \line
|        | |    |||test|1|0.01||||fact|1|0.04|+------------- \line
|        | |    ||+----+-+----++||    | |    ||+----+-+--+-- \line
|        | |    ||              ||    | |    |||fact|1|0.|+- \line
|        | |    ||              ||    | |    |||    | |  ||+ \line
|        | |    ||              ||    | |    |||    | |  ||| \line
|        | |    ||              ||    | |    |||    | |  ||| \line
|        | |    ||              ||    | |    |||    | |  ||| \line
|        | |    ||              ||    | |    |||    | |  ||| \line
|        | |    ||              ||    | |    |||    | |  ||| \line
|        | |    ||              ||    | |    |||    | |  ||+ \line
|        | |    ||              ||    | |    |||    | |  |+- \line
|        | |    ||              ||    | |    ||+----+-+--+-- \line
|        | |    ||              ||    | |    |+------------- \line
|        | |    ||              |+----+-+----+-------------- \line
|        | |    |+--------------+--------------------------- \line
+--------+-+----+------------------------------------------- \line
 \line
------------------------------+ \line
-----------------------------+| \line
----------------------------+|| \line
---------------------------+||| \line
--------------------------+|||| \line
-------------------------+||||| \line
----+-+--+--------------+|||||| \line
fact|1|0.|+------------+||||||| \line
    | |  ||+----+-+--++|||||||| \line
    | |  |||fact|1|0.|||||||||| \line
    | |  ||+----+-+--++|||||||| \line
    | |  |+------------+||||||| \line
----+-+--+--------------+|||||| \line
-------------------------+||||| \line
--------------------------+|||| \line
---------------------------+||| \line
----------------------------+|| \line
-----------------------------+| \line
------------------------------+ \line
 \line
 % end of session     \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The profile statistics show the division of time between the various definitions. For each definition called during the profiling session there is a summary of the number of calls and time used. For each definition there is also a breakdown on the time spent in other definitions that were directly called from that definition.\line

\par Entries in the profile statistics that have a "<" to the right of the last value are top level calls.  All other entries have been called by these top level calls.\line

\par \pard\sb95 The time spent in direct recursive calls is counted in the original call. The number of such calls is placed in brackets after the number of top level calls.\line

\par The statistics do not account for local definitions within global ones; their execution time is simply added to the time for the global definition.\line

\par A feature of the profiler not shown in the above example is that when timing a transformer definition, the time spent executing the argument operation(s) is computed in order to understand how much of the cost of the transformer is due to applying the argument operation(s).\line

\par \pard\sb95 The accuracy of the timing information is limited by the precision of the information available through system calls to the host system.  For very small definitions the statistics may show no execution time.  Usually their effect can be estimated by considering the execution time of the calling definition.\line

\par The \i Profiletable\plain\fs20\cf1\cb1  result provides the summarized profile statistics as a quintuple consisting of the name of the definition, the number of calls, the number of recursive calls, the time, and a list of records for each definition it directly calls. Each of the latter records has the same information provided for the routine itself, but does not report on the definitions it itself calls.\line

\par \pard\sb95 The \i Profiletree\plain\fs20\cf1\cb1  result starts with a node indicating the toplevel and the total execution time. It has a list of subnodes for each definition called from the top level. Each of these has the number of calls, the execution time and nodes for each definition it calls. A recursive call is reported directly in a subnode and hence a deeply recursive routine will produce a deeply nested array of profile information.    \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00eb}
{\up $}{\footnote\pard\plain{\up $} program fragment}
{\up #}{\footnote\pard\plain{\up #} 1QC9YUE}
\pard\keepn\sb95 \b\fs25 program fragment\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, program fragment;program fragment}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 expression\plain\fs20\cf1\cb1 {\v FD5QFK}\line

\par Nial is a programming language specifically designed for use in an interactive environment.  The formal description of the language describes the valid language constructs that can be entered in one interaction; and explains the meaning of one such entry in terms of the environment created by earlier interactions in the same session.  The term \b program fragment\plain\fs20\cf1\cb1  is used to describe a meaningful piece of program text.  \line

\par The rules for writing well formed program fragments in Nial are called the \i syntax rules\plain\fs20\cf1\cb1  of Nial.  A program fragment that is well formed is said to be syntactically correct.  The syntax rules are analogous to the rules of grammar that determine the correctness of English.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ec}
{\up $}{\footnote\pard\plain{\up $} putfile}
{\up #}{\footnote\pard\plain{\up #} IMUFEL}
\pard\keepn\sb95 \b\fs25 putfile\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} file operation, putfile;putfile}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul file operation\plain\fs20\cf1\cb1 {\v file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 putfile Filename A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 getfile\plain\fs20\cf1\cb1 {\v 45R7_SO}, \uldb appendfile\plain\fs20\cf1\cb1 {\v 3AAL9Q}\line

\par The operation \i putfile\plain\fs20\cf1\cb1  writes the rows of items of \i A\plain\fs20\cf1\cb1  as text records to the file with name \i Filename\plain\fs20\cf1\cb1 .  It is used in conjunction with \i getfile\plain\fs20\cf1\cb1 .  The file must not be open.  Items of \i A\plain\fs20\cf1\cb1  are arrays of characters of any valence.  \line

\par In the following example, three strings would be written to the file Maillist.  
\par \pard\keep\sb95 \f1\fs16      putfile "Maillist ['Now is the time' 'for all good \line
men','to come to the aid']\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      putfile IS OPERATION File A \{\-  \line
        IF not isfault (Filenum := open File "w) THEN  \line
           ITERATE (Filenum writefile) (link EACH rows A) ;  \line
           close Filenum ;  \line
        ELSE  \line
           Filenum  \line
        ENDIF \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ed}
{\up $}{\footnote\pard\plain{\up $} quiet_fault}
{\up #}{\footnote\pard\plain{\up #} 1EEKEB1}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 quiet_fault\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} conversion operation, quiet_fault;quiet_fault}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 quiet_fault A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 fault\plain\fs20\cf1\cb1 {\v TLJI2Z}\line

\par The operation \i quiet_fault\plain\fs20\cf1\cb1  is a version of operation \i fault\plain\fs20\cf1\cb1  that turns off fault triggering before producing the fault and restores the triggering switch to its prior value after producing the fault.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      quiet_fault IS OPERATION Str \{\-  \line
        Oldsetting := settrigger o;  \line
        Res := fault Str;  \line
        settrigger Oldsetting;  \line
        Res \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ee}
{\up $}{\footnote\pard\plain{\up $} quotient}
{\up #}{\footnote\pard\plain{\up #} KJKAFK}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 quotient\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, quotient;quotient}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A quotient B   quotient A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 mod\plain\fs20\cf1\cb1 {\v 1_E72C0}, \uldb floor\plain\fs20\cf1\cb1 {\v 7CICIH}, \uldb divide\plain\fs20\cf1\cb1 {\v 6242D6P}\line

\par The operation \i quotient\plain\fs20\cf1\cb1  returns the quotient of dividing integer \i A\plain\fs20\cf1\cb1  by integer \i B\plain\fs20\cf1\cb1 .  If the divisor \i B\plain\fs20\cf1\cb1  is zero, the result is zero.  If it is negative, the result is the fault \i ?negative divisor\plain\fs20\cf1\cb1 .  The operation \i quotient\plain\fs20\cf1\cb1  converts boolean arguments to integer but otherwise produces a fault if either argument is not an integer.  
\par \pard\keep\sb95 \f1\fs16      R gets l 2 2.5 `a "abc ??error; \line
     R OUTER quotient R \line
     1       0  ?A      ?A  ?A  ?error \line
     2       1  ?A      ?A  ?A  ?error \line
?A      ?A      ?A      ?A  ?A  ?error \line
?A      ?A      ?A      ?A  ?A  ?A \line
?A      ?A      ?A      ?A  ?A  ?A \line
?error  ?error  ?error  ?A  ?A  ?error \line
 \line
     (5 quotient 2) (-5 quotient 2) \line
2 -3 \line
 \line
     (5 quotient -2) (5 quotient 0) \line
?negative divisor 0\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example illustrates all combinations of atom types for the two arguments to \i quotient\plain\fs20\cf1\cb1 .  \line

\par The quotient on division by a positive integer \i B\plain\fs20\cf1\cb1  is always an integer on the same side of the origin as \i A\plain\fs20\cf1\cb1 .  The result of \i A quotient 0\plain\fs20\cf1\cb1  is 0 rather than a fault since this rule is compatible with the choice that \i A mod 0\plain\fs20\cf1\cb1  is \i A\plain\fs20\cf1\cb1 .  \line

\par The operation \i quotient\plain\fs20\cf1\cb1  is used in place of \i divide\plain\fs20\cf1\cb1  in situations where the result must be an integer.  \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    isinteger A ==> A quotient 0 = 0 \line
   floor (A - (B*(A quotient B))) =f= A mod B \line
   A quotient B =f=  floor (A / B) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ef}
{\up $}{\footnote\pard\plain{\up $} raise}
{\up #}{\footnote\pard\plain{\up #} TXJ_9K}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 raise\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} nesting restructuring operation, raise;raise}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nesting restructuring operation\plain\fs20\cf1\cb1 {\v nesting restructuring operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 N raise A   raise N A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 split\plain\fs20\cf1\cb1 {\v 5JDW.RI}, \uldb rows\plain\fs20\cf1\cb1 {\v 1CMI_LM}, \uldb cols\plain\fs20\cf1\cb1 {\v QCY_U_}, \uldb mix\plain\fs20\cf1\cb1 {\v 1_E72_N}, \uldb rank\plain\fs20\cf1\cb1 {\v QD.ZW5}\line

\par The operation \i raise\plain\fs20\cf1\cb1  is used to partition an array \i A\plain\fs20\cf1\cb1  along its axes by indicating that the first \i N\plain\fs20\cf1\cb1  axes are to be retained in the result.  The remaining axes become axes of the items of the result.  \i N\plain\fs20\cf1\cb1  must be an integer in the range from 0 to \i valence A\plain\fs20\cf1\cb1 .  The result is an array of shape given by taking the first \i N\plain\fs20\cf1\cb1  items of \i shape A\plain\fs20\cf1\cb1 .  The items of the result have the shape given by dropping the first \i N\plain\fs20\cf1\cb1  items of \i shape A\plain\fs20\cf1\cb1 .  Thus, the \i 2 raise\plain\fs20\cf1\cb1  of an array of shape 3 4 2 is a 3 by 4 table of pairs.  The \i 1 raise\plain\fs20\cf1\cb1  of the same array is a triple of 4 by 2 tables.  
\par \pard\keep\sb95 \f1\fs16      A := 3 4 2 reshape 'ABCDEFGHIJKLMNOPQRSTUVWX' \line
AB  IJ  QR \line
CD  KL  ST \line
EF  MN  UV \line
GH  OP  WX \line
     2 raise A \line
+--+--+--+--+ \line
|AB|CD|EF|GH| \line
+--+--+--+--+ \line
|IJ|KL|MN|OP| \line
+--+--+--+--+ \line
|QR|ST|UV|WX| \line
+--+--+--+--+ \line
     1 raise A \line
+--+--+--+ \line
|AB|IJ|QR| \line
|CD|KL|ST| \line
|EF|MN|UV| \line
|GH|OP|WX| \line
+--+--+--+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      raise IS OPERATION A \{\- N drop axes A split A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    N a nonnegative integer <= valence A and not empty A ==> shape (N raise A) = N take shape A \line
   shape first (N raise A) = N drop shape A ==> mix (N raise A) = A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00f0}
{\up $}{\footnote\pard\plain{\up $} random}
{\up #}{\footnote\pard\plain{\up #} X7KC2Y}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 random\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} array generation operation, random;random}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul array generation operation\plain\fs20\cf1\cb1 {\v array generation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 random S    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 seed\plain\fs20\cf1\cb1 {\v 25VV2QN}\line

\par The operation \i random\plain\fs20\cf1\cb1  is used to generate pseudo-random real numbers in the range from 0.  to 1.  The argument \i S\plain\fs20\cf1\cb1  is a shape and \i random\plain\fs20\cf1\cb1  generates \i product S\plain\fs20\cf1\cb1  numbers storing them in an array of shape \i S\plain\fs20\cf1\cb1 . \i Random\plain\fs20\cf1\cb1  uses a congruential method with period 2147483647.  The random generator generates a sequence of integers using the formula: \i R := 16807 * R mod 214783647 starting with R = 314159262.  The result is the real R/2147483647.  The sequence can be initialized using the operation seed\plain\fs20\cf1\cb1  with an argument \i N\plain\fs20\cf1\cb1 , where \i 0. < N < 1.0\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 \i Seed\plain\fs20\cf1\cb1  resets the random number generator to use R = floor (R1 * 214783647.).  
\par \pard\keep\sb95 \f1\fs16      seed 0.314159; random 5 \line
0.070 0.743 0.240 0.627 0.309 \line
 \line
     floor ( 100. * random 2 5 ) \line
98 19 94 47 36  \line
88 44 47 82 38\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows the five random numbers generated after a seed of 0.314159 is used.  The second example illustrates how to use the operation \i random\plain\fs20\cf1\cb1  to generate 10 random integers between 0 and 99 and store them in an array of shape 2 5.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00f1}
{\up $}{\footnote\pard\plain{\up $} rank}
{\up #}{\footnote\pard\plain{\up #} QD.ZW5}
\pard\keepn\sb95 \b\fs25 rank\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} apply-by-partition transformer, rank;rank}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul apply-by-partition transformer\plain\fs20\cf1\cb1 {\v apply-by-partition transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 N RANK f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 byrows\plain\fs20\cf1\cb1 {\v 3.ITLBI}, \uldb bycols\plain\fs20\cf1\cb1 {\v 10XLMGD}, \uldb partition\plain\fs20\cf1\cb1 {\v KE6GMU}, \uldb raise\plain\fs20\cf1\cb1 {\v TXJ_9K}\line

\par The transformer \i RANK\plain\fs20\cf1\cb1  applies an operation \i f\plain\fs20\cf1\cb1  to arrays formed from the last \i N\plain\fs20\cf1\cb1  axes of \i A\plain\fs20\cf1\cb1 .  The results of the applications of \i f\plain\fs20\cf1\cb1  must all be the same shape and are combined to form a result array using \i mix\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      2 RANK reverse (3 4 5 reshape count 60) \line
20 19 18 17 16   40 39 38 37 36   60 59 58 57 56 \line
15 14 13 12 11   35 34 33 32 31   55 54 53 52 51 \line
10  9  8  7  6   30 29 28 27 26   50 49 48 47 46 \line
 5  4  3  2  1   25 24 23 22 21   45 44 43 42 41 \line
 \line
     1 RANK sum (3 4 reshape count 12) \line
10 26 42 \line
     \plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example reverses the planes of the generated array.  The second example sums the rows of the generated matrix.\line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      RANK IS TRANSFORMER f OPERATION N A \{\-  \line
        mix EACH f (N lower A) \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00f2}
{\up $}{\footnote\pard\plain{\up $} reach}
{\up #}{\footnote\pard\plain{\up #} TXN4TN}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 reach\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} reach;selection operation, reach}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 P reach A   reach P A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 pick\plain\fs20\cf1\cb1 {\v 40Z84P}, \uldb choose\plain\fs20\cf1\cb1 {\v 1XQ9M0F}, \uldb deepplace\plain\fs20\cf1\cb1 {\v 0UY7YL}\line

\par The operation \i reach\plain\fs20\cf1\cb1  is used to select an array at an arbitrary path \i P\plain\fs20\cf1\cb1  within the nested structure of \i A\plain\fs20\cf1\cb1 .  \i P\plain\fs20\cf1\cb1  is a list of addresses where the first item of \i P\plain\fs20\cf1\cb1  selects an item of \i A\plain\fs20\cf1\cb1 , the second selects an item of that item, etc.  If \i P\plain\fs20\cf1\cb1  is empty, the result is \i A\plain\fs20\cf1\cb1 .  The operation is implemented as an iterated \i pick\plain\fs20\cf1\cb1  and hence the addresses in the path are converted using first if they are solitary integers.  If one of the picks attempts a selection out of bounds, the result is fault \i ?path\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      A := 3 4 reshape (pack 'ABCDEFGHIJKL' '1234567890ab') \line
+--+--+--+--+ \line
|A1|B2|C3|D4| \line
+--+--+--+--+ \line
|E5|F6|G7|H8| \line
+--+--+--+--+ \line
|I9|J0|Ka|Lb| \line
+--+--+--+--+ \line
 \line
     (2 0) 1 reach A \line
9\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the example, the path (2 0) 1 picks the item with address 1 of the location with address 2 0.  \line

\par Q'Nial supports a direct notation for doing a \i reach\plain\fs20\cf1\cb1  into an array associated with a variable: \i Var@@I\plain\fs20\cf1\cb1  (pronounced \i Var at path I\plain\fs20\cf1\cb1 ).  The \i at path\plain\fs20\cf1\cb1  notation can be used on both the left and right of an assignment expression.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      reach IS P A \{\-  \line
        IF empty P THEN  \line
           A  \line
        ELSE  \line
           rest P reach (first P pick A)  \line
        ENDIF \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    P reach A = (EACH list P) reach A \line
   items of P are valid addresses where used ==> (P reach A) P deepplace A = A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00f3}
{\up $}{\footnote\pard\plain{\up $} read}
{\up #}{\footnote\pard\plain{\up #} QD_3IY}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 read\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} interactive input/output operation, read;read}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul interactive input/output operation\plain\fs20\cf1\cb1 {\v interactive input/output operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 read P    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 readscreen\plain\fs20\cf1\cb1 {\v F7V7GJ}, \uldb write\plain\fs20\cf1\cb1 {\v 5JHY020}, \uldb writescreen\plain\fs20\cf1\cb1 {\v 9TD.YB}, \uldb execute\plain\fs20\cf1\cb1 {\v 3WULI4D}\line

\par The operation \i read\plain\fs20\cf1\cb1  is used in an interaction with the user running a program to obtain an array value from the keyboard after issuing a prompt given by the string or character \i P\plain\fs20\cf1\cb1 .  After receiving the prompt, the user types a sequence of characters and then presses the \i Return\plain\fs20\cf1\cb1  key.  The sequence of characters, excluding the \i Return\plain\fs20\cf1\cb1 , becomes the string entered.  The string is executed to give the result of \i read\plain\fs20\cf1\cb1 .  If the string being executed contains an integer representation that would convert to a number outside the range of integers, the corresponding real number is returned.  
\par \pard\keep\sb95 \f1\fs16      A := read 'Type an expression : '; \line
Type an expression : 3 + count 10 \line
 \line
     A \line
4 5 6 7 8 9 10 11 12 13\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The operation \i read\plain\fs20\cf1\cb1  is similar to operation \i readscreen\plain\fs20\cf1\cb1 .  The difference is that in \i read\plain\fs20\cf1\cb1  the string received from the keyboard is evaluated, whereas in \i readscreen\plain\fs20\cf1\cb1 , the string is returned.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      read IS OPERATION P \{\- execute readscreen P \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00f4}
{\up $}{\footnote\pard\plain{\up $} readarray}
{\up #}{\footnote\pard\plain{\up #} 7HVXYZ}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 readarray\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} nial direct access file operation, readarray;readarray}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nial direct access file operation\plain\fs20\cf1\cb1 {\v nial direct access file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 readarray Fnum N    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 readrecord\plain\fs20\cf1\cb1 {\v 6J72_OO}, \uldb writearray\plain\fs20\cf1\cb1 {\v 18CILAO}, \uldb filetally\plain\fs20\cf1\cb1 {\v 1E5.ZTN}, \uldb eraserecord\plain\fs20\cf1\cb1 {\v LE6Z0M}, \uldb open\plain\fs20\cf1\cb1 {\v 25VR_QX}, \uldb close\plain\fs20\cf1\cb1 {\v TIUC9K}\line

\par The operation \i readarray\plain\fs20\cf1\cb1  is used to read the component or components indicated by \i N\plain\fs20\cf1\cb1  from the direct access file with file port \i Fnum\plain\fs20\cf1\cb1 .  The file must have been created using \i writearray\plain\fs20\cf1\cb1  and must have been opened as a direct file using \i open\plain\fs20\cf1\cb1 .  \line

\par If \i N\plain\fs20\cf1\cb1  is an integer, the result is the array stored at record position \i N\plain\fs20\cf1\cb1  of the file.  \line

\par \pard\sb95 If \i N\plain\fs20\cf1\cb1  is a list of integers, the result is a list of the corresponding records.  If there is no record at position \i N\plain\fs20\cf1\cb1 , the result is the fault \i ?missing\plain\fs20\cf1\cb1 .  If \i N\plain\fs20\cf1\cb1  is greater than \i filetally A\plain\fs20\cf1\cb1 , the result is the fault \i ?eof\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      readarray Fnum [23,24,25];\plain\fs20\cf1\cb1 \line

\par \pard\sb95 If \i N\plain\fs20\cf1\cb1  is a solitary integer, the result is a solitary holding the selected item. \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00f5}
{\up $}{\footnote\pard\plain{\up $} readchar}
{\up #}{\footnote\pard\plain{\up #} RSJV13}
\pard\keepn\sb95 \b\fs25 readchar\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} interactive input/output expression, readchar;readchar}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul interactive input/output expression\plain\fs20\cf1\cb1 {\v interactive input/output expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Readchar    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 read\plain\fs20\cf1\cb1 {\v QD_3IY}, \uldb readscreen\plain\fs20\cf1\cb1 {\v F7V7GJ}, \uldb writechars\plain\fs20\cf1\cb1 {\v 30680BN}, \uldb write\plain\fs20\cf1\cb1 {\v 5JHY020}\line

\par The expression \i Readchar\plain\fs20\cf1\cb1  is used to obtain the result of a single keystroke on the keyboard.  The character is not displayed on the screen automatically.  If the keystroke corresponds to a single displayable ASCII character, the result is that character.  Otherwise, the result is a phrase indicating the function key pressed.  \line

\par Q'Nial supports all the standard keys of the IBMPC keyboard.  On a non-IBMPC version of Q'Nial, these keys are available through use of escape sequences.  \line

\par \pard\sb95 The input from \i Readchar\plain\fs20\cf1\cb1  can be displayed by the use of \i writechars\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      writechars Readchar \line
Backspace\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the example, the user responded by pressing the backspace key.  \line

\par \i Readchar\plain\fs20\cf1\cb1  is used when developing an interactive program in which the user uses keystrokes to indicate requested actions.  The decision whether or not to display a character on the screen can be made by the program rather than done automatically.  \line

\par The following table lists the non-character keystrokes recognized on the IBMPC keypad and gives the default sequences accepted by an ASCII terminal when the corresponding keystroke is not present.  The two keyboard layouts on SUN workstations behave like an IBMPC keyboard.  \line

\par \pard\sb95 \b IBMPC\plain\fs20\cf1\cb1 
\par  \trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 \b IBMPC Keystroke  \cell\pard \pard\intbl\sb95 Sun Console  \cell\pard \pard\intbl\sb95 Ascii Terminal  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 Return  \cell\pard \pard\intbl\sb95 Return  \cell\pard \pard\intbl\sb95 Return  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Backspace  \cell\pard \pard\intbl\sb95 Backspace  \cell\pard \pard\intbl\sb95 Backspace  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Del  \cell\pard \pard\intbl\sb95 Del  \cell\pard \pard\intbl\sb95 Del  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Ins  \cell\pard \pard\intbl\sb95 Esc Esc i  \cell\pard \pard\intbl\sb95 Esc Esc i  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Up_Arrow  \cell\pard \pard\intbl\sb95 Up_Arrow  \cell\pard \pard\intbl\sb95 Up_Arrow  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Down_Arrow  \cell\pard \pard\intbl\sb95 Down_Arrow  \cell\pard \pard\intbl\sb95 Down_Arrow  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Right_Arrow  \cell\pard \pard\intbl\sb95 Right_Arrow  \cell\pard \pard\intbl\sb95 Right_Arrow  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Left_Arrow  \cell\pard \pard\intbl\sb95 Left_Arrow  \cell\pard \pard\intbl\sb95 Left_Arrow  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Home  \cell\pard \pard\intbl\sb95 Home  \cell\pard \pard\intbl\sb95 Esc Esc h  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 End  \cell\pard \pard\intbl\sb95 End  \cell\pard \pard\intbl\sb95 Esc Esc e  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 PgUp  \cell\pard \pard\intbl\sb95 PgUp  \cell\pard \pard\intbl\sb95 Esc Esc u  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 PgDn  \cell\pard \pard\intbl\sb95 PgDn  \cell\pard \pard\intbl\sb95 Esc Esc d  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Ctrl Left_Arrow  \cell\pard \pard\intbl\sb95 Esc Left_Arrow  \cell\pard \pard\intbl\sb95 Esc Esc c l  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Ctrl Right_Arrow  \cell\pard \pard\intbl\sb95 Esc Right_Arrow  \cell\pard \pard\intbl\sb95 Esc Esc c r  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Ctrl PgUp  \cell\pard \pard\intbl\sb95 Esc PgUp  \cell\pard \pard\intbl\sb95 Esc Esc c u  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Ctrl PgDn  \cell\pard \pard\intbl\sb95 Esc PgDn  \cell\pard \pard\intbl\sb95 Esc Esc c d  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Ctrl Home  \cell\pard \pard\intbl\sb95 Esc Home  \cell\pard \pard\intbl\sb95 Esc Esc c h  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Ctrl End  \cell\pard \pard\intbl\sb95 Esc End  \cell\pard \pard\intbl\sb95 Esc Esc c e  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Tab  \cell\pard \pard\intbl\sb95 Tab  \cell\pard \pard\intbl\sb95 Tab  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Shift Tab  \cell\pard \pard\intbl\sb95 Esc Tab  \cell\pard \pard\intbl\sb95 Esc Tab  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 Esc  \cell\pard \pard\intbl\sb95 Esc Esc Esc  \cell\pard \pard\intbl\sb95 Esc Esc Esc  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 F1 to F10  \cell\pard \pard\intbl\sb95 F1 to F10  \cell\pard \pard\intbl\sb95 Esc 1 to Esc 0  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 <Alt F1> to <Alt F10>  \cell\pard \pard\intbl\sb95 Esc F1 to Esc F12  \cell\pard \pard\intbl\sb95 Esc Esc 1 to Esc Esc 0  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2775\cellx4995\cellx5795\pard\intbl\sb95 <Alt A> to <Alt Z>  \cell\pard \pard\intbl\sb95 <Esc a> to <Esc z>  \cell\pard \pard\intbl\sb95 <Esc a> to <Esc z>  \cell\intbl\row
\pard\sb95 \line

\par The IBMPC keyboard support also recognizes the function keys modified by Shift and Ctrl and <Alt 0> to <Alt 9> but these are not mapped onto corresponding escape sequences in the Unix version.  \line

\par The keyboard mappings are set by default but may be controlled by description files stored in the \i initial\plain\fs20\cf1\cb1  directory.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00f6}
{\up $}{\footnote\pard\plain{\up $} readfield}
{\up #}{\footnote\pard\plain{\up #} 7MML9E}
\pard\keepn\sb95 \b\fs25 readfield\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} host direct access file operation, readfield;readfield}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul host direct access file operation\plain\fs20\cf1\cb1 {\v host direct access file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 readfield Filename Start Size    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 readrecord\plain\fs20\cf1\cb1 {\v 6J72_OO}, \uldb readarray\plain\fs20\cf1\cb1 {\v 7HVXYZ}, \uldb filelength\plain\fs20\cf1\cb1 {\v 34SOEI}\line

\par The operation \i readfield\plain\fs20\cf1\cb1  is used to read a portion of an existing host file as a character string.  The string or phrase \i Filename\plain\fs20\cf1\cb1  is the name of the file, the integer \i Start\plain\fs20\cf1\cb1  is the offset to the beginning of the field to be read and integer \i Size\plain\fs20\cf1\cb1  is the size of the field to be read.  The result is character string of the items read.  If the logical field extends across a line boundary the field will include the newline indicator appropriate for the host system (either linefeed or return-linefeed).  \line

\par \pard\sb95 \b Example\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      readfield "Myfile 80 20\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The result is the string beginning at offset 80 in file \i Myfile\plain\fs20\cf1\cb1  of length 20.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00f7}
{\up $}{\footnote\pard\plain{\up $} readfile}
{\up #}{\footnote\pard\plain{\up #} 5JAWOA}
\pard\keepn\sb95 \b\fs25 readfile\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} file operation, readfile;readfile}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul file operation\plain\fs20\cf1\cb1 {\v file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 readfile Fnum   readfile Fnum N    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 writefile\plain\fs20\cf1\cb1 {\v 1DNB1GE}, \uldb getfile\plain\fs20\cf1\cb1 {\v 45R7_SO}, \uldb open\plain\fs20\cf1\cb1 {\v 25VR_QX}, \uldb close\plain\fs20\cf1\cb1 {\v TIUC9K}, \uldb readscreen\plain\fs20\cf1\cb1 {\v F7V7GJ}\line

\par The operation \i readfile\plain\fs20\cf1\cb1  is used to read the next record from the sequential text file designated by file port \i Fnum\plain\fs20\cf1\cb1 .  The file port \i Fnum\plain\fs20\cf1\cb1  is the integer returned by \i open\plain\fs20\cf1\cb1 , which must have been called before executing the \i readfile\plain\fs20\cf1\cb1 .  \line

\par A record of text in a text file is a sequence of characters up to but excluding an end-of-line indication.  The end-of-line indication is system dependent and may be one or more characters.  The interface between Q'Nial and the host system recognizes end-of-line and, on successive readfile requests, returns the records of the text file with the end-of-line indications removed.  \line

\par \pard\sb95 If \i readfile\plain\fs20\cf1\cb1  is used with a second argument \i N\plain\fs20\cf1\cb1 , it reads the next \i N\plain\fs20\cf1\cb1  bytes of the text file and returns them as a string.  In this usage, end-of-line characters are processed as any other character and are not removed.  This second form is intended for reading information from device drivers or a communications port, where end-of-line indications may not be given.  \line

\par The following example shows a text file, Myfile being opened and its records being gathered as a list of strings.  The example has the same effect as the expression \i getfile "Myfile\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      File_number := open "Myfile "r ; \line
     Records := '' ; \line
     Record := readfile File_number ; \line
     WHILE Record ~= ??eof DO \line
          Records gets Records append Record ; \line
          Record := readfile File_number ; \line
     ENDWHILE ; \line
     close File_number ;\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00f8}
{\up $}{\footnote\pard\plain{\up $} readrecord}
{\up #}{\footnote\pard\plain{\up #} 6J72_OO}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 readrecord\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} nial direct access file operation, readrecord;readrecord}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nial direct access file operation\plain\fs20\cf1\cb1 {\v nial direct access file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 readrecord Fnum N    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 readarray\plain\fs20\cf1\cb1 {\v 7HVXYZ}, \uldb writerecord\plain\fs20\cf1\cb1 {\v V4AFRH}, \uldb filetally\plain\fs20\cf1\cb1 {\v 1E5.ZTN}, \uldb eraserecord\plain\fs20\cf1\cb1 {\v LE6Z0M}, \uldb open\plain\fs20\cf1\cb1 {\v 25VR_QX}, \uldb close\plain\fs20\cf1\cb1 {\v TIUC9K}\line

\par The operation \i readrecord\plain\fs20\cf1\cb1  is used to read the component or components indicated by \i N\plain\fs20\cf1\cb1  from the direct access file with file port \i Fnum\plain\fs20\cf1\cb1 .  If \i N\plain\fs20\cf1\cb1  is an integer, the result is the string stored at component position \i N\plain\fs20\cf1\cb1  of the file.  The file must have been opened as a direct file and must have been created using \i writerecord\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 If \i N\plain\fs20\cf1\cb1  is a list of integers, the result is a list of the corresponding records.  If there is no component at \i N\plain\fs20\cf1\cb1 , the result is the fault \i ?missing\plain\fs20\cf1\cb1 .  If \i N\plain\fs20\cf1\cb1  is greater than \i filetally A\plain\fs20\cf1\cb1 , the result is the fault \i ?eof\plain\fs20\cf1\cb1 .  \line

\par A direct access file is stored as two host system files: a \i .ndx\plain\fs20\cf1\cb1  file holding index information and a \i .rec\plain\fs20\cf1\cb1  file holding the records.  
\par \pard\keep\sb95 \f1\fs16      readrecord Fnum [23,24,25]; \line
 \line
     convert_records IS OP Filein Fileout \{\-  \line
        Fin := open Filein "d ;  \line
        Fout := open Fileout "d ;  \line
        Num := filetally Fin ;  \line
        writerecord Fout (tell Num)  \line
        (EACH convert_op (readrecord Fin (tell Num)));  \line
        EACH close Fin Fout ; \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows a call of \i readrecord\plain\fs20\cf1\cb1  that returns three records.  The second example shows an operation \i convert_records\plain\fs20\cf1\cb1  that reads all the records in direct file \i Filein\plain\fs20\cf1\cb1 , modifies them by \i convert_op\plain\fs20\cf1\cb1  and writes them to direct file \i Fileout\plain\fs20\cf1\cb1 .  For a very large file, it may be necessary to replace the use of \i EACH\plain\fs20\cf1\cb1  with a loop.  \line

\par The \i readrecord\plain\fs20\cf1\cb1  operation can access fields of a fixed format file created external to Q'Nial.  If the component number used in a \i readrecord\plain\fs20\cf1\cb1  is beyond the end of file as indicated by the \i filetally Fnum\plain\fs20\cf1\cb1 , stored in the \i .ndx\plain\fs20\cf1\cb1  file, the \i .rec\plain\fs20\cf1\cb1  file is checked to see if the host file information indicates that the \i .rec\plain\fs20\cf1\cb1  file extends beyond the length expected for a file created by the Q'Nial operations.  If so, the \i .rec\plain\fs20\cf1\cb1  file is assumed to consist of a sequence of blocks of records, with each block having fields of the sizes indicated by the \i .ndx\plain\fs20\cf1\cb1  file.  The index information for the record at \i (N mod filetally Fnum)\plain\fs20\cf1\cb1  is used to find the requested component within the block of records found from \i (N quotient filetally Fnum)\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 To use this feature, a separate process must be followed to create the \i .ndx\plain\fs20\cf1\cb1  file corresponding to one block of records in the external file.  This is done by writing a sequence of strings of the lengths of the records to a dummy direct access file and then renaming the resulting index file and the external file to be names expected by the Q'Nial direct access facility.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00f9}
{\up $}{\footnote\pard\plain{\up $} readscreen}
{\up #}{\footnote\pard\plain{\up #} F7V7GJ}
\pard\keepn\sb95 \b\fs25 readscreen\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} interactive input/output operation, readscreen;readscreen}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul interactive input/output operation\plain\fs20\cf1\cb1 {\v interactive input/output operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 readscreen P    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 read\plain\fs20\cf1\cb1 {\v QD_3IY}, \uldb readchar\plain\fs20\cf1\cb1 {\v RSJV13}, \uldb readfile\plain\fs20\cf1\cb1 {\v 5JAWOA}, \uldb writescreen\plain\fs20\cf1\cb1 {\v 9TD.YB}\line

\par The operation \i readscreen\plain\fs20\cf1\cb1  is used to obtain a string from the keyboard after issuing the prompt \i P\plain\fs20\cf1\cb1 .  The prompt \i P\plain\fs20\cf1\cb1  must be a character or a string.  After receiving the prompt, the user types a sequence of characters and then presses the \i Return\plain\fs20\cf1\cb1  key.  The sequence of characters, excluding the \i Return\plain\fs20\cf1\cb1 , is the string returned as the result of \i readscreen\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      Name := readscreen 'Your name? : ' ; \line
Your name? : Mike \line
 \line
     Name \line
Mike \line
 \line
     Answer := first 'Do you wish to continue? y/n: ' ; \line
     IF Answer in 'yY' THEN ...\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The operation \i readscreen\plain\fs20\cf1\cb1  is similar to the operation \i read\plain\fs20\cf1\cb1 , the difference being that in \i read\plain\fs20\cf1\cb1 , the string received from the keyboard is evaluated, whereas with \i readscreen\plain\fs20\cf1\cb1 , the string is returned.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00fa}
{\up $}{\footnote\pard\plain{\up $} reciprocal}
{\up #}{\footnote\pard\plain{\up #} AJCGJN}
\pard\keepn\sb95 \b\fs25 reciprocal\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, reciprocal;reciprocal}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 reciprocal A   recip A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 divide\plain\fs20\cf1\cb1 {\v 6242D6P}, \uldb quotient\plain\fs20\cf1\cb1 {\v KJKAFK}, \uldb opposite\plain\fs20\cf1\cb1 {\v 18Y3XQ}\line

\par The operation \i reciprocal\plain\fs20\cf1\cb1  or \i recip\plain\fs20\cf1\cb1  for short, returns a real number which is the reciprocal value of a numeric atom.  \line

\par \i Reciprocal\plain\fs20\cf1\cb1  produces the following results when applied to atoms of the six types: 
\par 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 reciprocal of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 reciprocal of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 1.0 / A if A ~= 0.; ?div if A = 0. \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      reciprocal l -2 3.5 `a "abc ??error \line
1. -0.5 0.285714 ?A ?A ?error \line
 \line
     reciprocal -2 (3 -4.5) \line
+----+------------------+ \line
|-0.5|0.333333 -0.222222| \line
+----+------------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      reciprocal IS OPERATION A (1 divide A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A divide B = A * reciprocal B \line
   reciprocal reciprocal reciprocal A = reciprocal A   (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00fb}
{\up $}{\footnote\pard\plain{\up $} recover}
{\up #}{\footnote\pard\plain{\up #} 7L0TNT}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 recover\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} recover;user defined operation, recover}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul user defined operation\plain\fs20\cf1\cb1 {\v user defined operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 recover Msg    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 toplevel\plain\fs20\cf1\cb1 {\v 3A08M4I}, \uldb latent\plain\fs20\cf1\cb1 {\v 4YEDEP}, \uldb checkpoint\plain\fs20\cf1\cb1 {\v 4LLHD1P}, \uldb restart\plain\fs20\cf1\cb1 {\v 3I4P_OP}\line

\par The operation \i recover\plain\fs20\cf1\cb1  is prepared by the user of Q'Nial to handle the action to be taken on detection of \i <Ctrl c>\plain\fs20\cf1\cb1  or any other situation that forces a return to top level.  If a \i recover\plain\fs20\cf1\cb1  operation does not exist in the workspace, Q'Nial returns to the top level loop on a \i <Ctrl c>\plain\fs20\cf1\cb1 .  This operation is necessary to provide control over \b closed\plain\fs20\cf1\cb1  applications which do not permit the user to access Q'Nial at the top level loop.  On its call the argument provided to the operation will be a character string giving the nature of the interruption, for example \i 'user interrupt'\plain\fs20\cf1\cb1  if a Ctrl-C has occurred or \i 'programmed interrupt'\plain\fs20\cf1\cb1  if \i toplevel\plain\fs20\cf1\cb1  has been called.  
\par \pard\keep\sb95 \f1\fs16      recover IS OP Msg \{\- Continue; \'7d \plain\fs20\cf1\cb1 
\par \f1\fs16      recover IS Op Msg \{\-  \line
        IF Msg = 'user interrupt' THEN  \line
           IF first readscreen 'Do you wish to restart? y or n : ' in 'yY' THEN  \line
              Restart  \line
           ELSE  \line
              Continue  \line
           ENDIF  \line
        ELSE  \line
           Continue  \line
        ENDIF \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the first example, if \i <Ctrl c>\plain\fs20\cf1\cb1  is pressed or some other action forces a jump to top level, the session ends saving the workspace in \i continue.nws\plain\fs20\cf1\cb1 .  The message parameter is ignored.  \line

\par In the second example of a definition for \i recover\plain\fs20\cf1\cb1 , a jump to top level by a \i <Ctrl-C>\plain\fs20\cf1\cb1  interrupt results in the display of the prompt: 
\par \pard\keep\sb95 \f1\fs16      Do you wish to restart? y or n :\plain\fs20\cf1\cb1 \line

\par \pard\sb95 If the response is text that begins with y or Y, the expression \i Restart\plain\fs20\cf1\cb1  is executed.  If the session had begun with a workspace named on the command line, the workspace would be reloaded and its \i Latent\plain\fs20\cf1\cb1  expression, if any, evaluated.  If the response begins with something other than y or Y, or the interrupt was of some other kind then the current session ends by executing \i Continue\plain\fs20\cf1\cb1 .  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00fc}
{\up $}{\footnote\pard\plain{\up $} recur}
{\up #}{\footnote\pard\plain{\up #} 7OB7OH}
\pard\keepn\sb95 \b\fs25 recur\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} recur;recursion transformer, recur}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul recursion transformer\plain\fs20\cf1\cb1 {\v recursion transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 RECUR [test, endf, parta, joinf, partb] A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 across\plain\fs20\cf1\cb1 {\v G9ON74}, \uldb down\plain\fs20\cf1\cb1 {\v 25VG_8X}\line

\par RECUR is a general recursion transformer with five operation arguments: \i test\plain\fs20\cf1\cb1  checks that the argument meets an end condition, \i endf\plain\fs20\cf1\cb1  is applied to the end argument before starting to build the result, \i parta\plain\fs20\cf1\cb1  computes the left value from the argument, which is stacked, \i joinf\plain\fs20\cf1\cb1  combines the left and right values as the recursion unwinds, and \i partb\plain\fs20\cf1\cb1  gives the value to be recurred on to produce the right value.The recursion terminates provided the repeated application of the operation \i partb\plain\fs20\cf1\cb1  results in an array that satisfies \i test\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      RECUR [ 0 =, 1 first, pass, product, -1 +] 4 \line
24 \line
     RECUR [ empty, 0 first, first, plus, rest ] 3 4 5 \line
12 \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16  RECUR is TR test endf parta joinf partb OP A \{\- \line
    Elements := Null; \line
    WHILE not test A DO \line
      Elements := Elements append parta A; \line
      A := partb A; \line
    ENDWHILE; \line
    Res := endf A; \line
    FOR E WITH reverse Elements DO \line
      Res := E joinf Res; \line
    ENDFOR; \line
    Res \'7d \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    RECUR [test, endf, parta, joinf, partb] A = FORK [test, endf, joinf [parta, RECUR [test, endf, parta, joinf, partb] partb]] A \line
   RECUR [ 0 =, 1 first, pass, product, -1 +] N = factorial N \line
   RECUR [ empty, 0 first, first, plus, rest ] A = sum A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00fd}
{\up $}{\footnote\pard\plain{\up $} reduce}
{\up #}{\footnote\pard\plain{\up #} 2.MYRUF}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 reduce\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} reduce;reduction transformer, reduce}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul reduction transformer\plain\fs20\cf1\cb1 {\v reduction transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 REDUCE f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 accumulate\plain\fs20\cf1\cb1 {\v 2_FBXZ}, \uldb reductive\plain\fs20\cf1\cb1 {\v 7GGROL}\line

\par The transformer \i REDUCE\plain\fs20\cf1\cb1  transforms an operation \i f\plain\fs20\cf1\cb1  into an operation which, when applied to an array \i A\plain\fs20\cf1\cb1 , has the same effect as evaluating an expression in which \i f\plain\fs20\cf1\cb1  is placed between the items of the array, with grouping done in a right-to-left manner.  If \i f\plain\fs20\cf1\cb1  is an operation that maps a pair of atoms to an atom, \i REDUCE f\plain\fs20\cf1\cb1  reduces a simple array to an atom.  For the built-in reductive operations: \i sum\plain\fs20\cf1\cb1 , \i product\plain\fs20\cf1\cb1 , \i and\plain\fs20\cf1\cb1 , \i or\plain\fs20\cf1\cb1 , \i max\plain\fs20\cf1\cb1 , \i min\plain\fs20\cf1\cb1 , and \i link\plain\fs20\cf1\cb1 , \i REDUCE f\plain\fs20\cf1\cb1  is the same as \i f\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      REDUCE divide 3 4 5 6 \line
.625 \line
 \line
     3 divide (4 divide ( 5 divide 6 ) ) \line
.625 \line
 \line
     REDUCE plus (count 10) \line
55 \line
 \line
     REDUCE hitch 'abcde' \line
abcde \line
 \line
     REDUCE append 'abcde' \line
+-+----------+ \line
|a|+-+------+| \line
| ||b|+-+--+|| \line
| || ||c|de||| \line
| || |+-+--+|| \line
| |+-+------+| \line
+-+----------+ \line
 \line
     REDUCE pass 73 45 39 97 \line
+--+----------+ \line
|73|+--+-----+| \line
|  ||45|39 97|| \line
|  |+--+-----+| \line
+--+----------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      REDUCE IS TRANSFORMER f OPERATION A \{\- \line
        % if f is reductive, apply f directly;  \line
        IF empty A THEN  \line
           Res := ??identity;  \line
        ELSE  \line
           Res := last A;  \line
           FOR B WITH reverse front A DO  \line
              Res := B f Res;  \line
           ENDFOR;  \line
        ENDIF;  \line
        Res \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    REDUCE f solitary A = A \line
   REDUCE f single A = A \line
   REDUCE f A B C = A f (B f C) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00fe}
{\up $}{\footnote\pard\plain{\up $} reducecols}
{\up #}{\footnote\pard\plain{\up #} 2SIMTO}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 reducecols\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} apply-by-partition transformer, reducecols;reducecols}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul apply-by-partition transformer\plain\fs20\cf1\cb1 {\v apply-by-partition transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 REDUCECOLS f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 reduce\plain\fs20\cf1\cb1 {\v 2.MYRUF}, \uldb reducerows\plain\fs20\cf1\cb1 {\v 2SXN4O}, \uldb bycols\plain\fs20\cf1\cb1 {\v 10XLMGD}\line

\par The transformer \i REDUCECOLS\plain\fs20\cf1\cb1  does the reduction of the columns of \i A\plain\fs20\cf1\cb1  with the operation \i f\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      REDUCECOLS sum (5 6 reshape count 30) \line
65 70 75 80 85 90\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The example returns the sum of the columns of the generated table.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    REDUCECOLS IS TRANSFORMER f OPERATION A \{\-  \line
      [valence A - 2 max 0,axes first A] PARTITION REDUCE f A \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:00ff}
{\up $}{\footnote\pard\plain{\up $} reducerows}
{\up #}{\footnote\pard\plain{\up #} 2SXN4O}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 reducerows\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} apply-by-partition transformer, reducerows;reducerows}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul apply-by-partition transformer\plain\fs20\cf1\cb1 {\v apply-by-partition transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 REDUCEROWS f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 reduce\plain\fs20\cf1\cb1 {\v 2.MYRUF}, \uldb reducecols\plain\fs20\cf1\cb1 {\v 2SIMTO}, \uldb byrows\plain\fs20\cf1\cb1 {\v 3.ITLBI}\line

\par The transformer \i REDUCEROWS\plain\fs20\cf1\cb1  does the reduction of the rows of \i A\plain\fs20\cf1\cb1  with the operation \i f\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      REDUCEROWS product (3 4 reshape count 12) \line
24 1680 11880\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The example returns the product of the rows of the generated table.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    REDUCEROWS IS TRANSFORMER f OPERATION A \{\-  \line
      BYROWS (REDUCE f) A \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0100}
{\up $}{\footnote\pard\plain{\up $} reductive}
{\up #}{\footnote\pard\plain{\up #} 7GGROL}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 reductive\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} operation property, reductive;reductive}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul operation property\plain\fs20\cf1\cb1 {\v operation property}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}, \uldb reduce\plain\fs20\cf1\cb1 {\v 2.MYRUF}\line

\par A \b reductive\plain\fs20\cf1\cb1  operation is one that extends a functional capability normally defined on a pair to a list, reducing the result by pairwise application of the function. \line

\par The predefined reductive operations include:
\par  \trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 \b Operation \cell\pard \pard\intbl\sb95 Function  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 and \cell\pard \pard\intbl\sb95 logical "and" of a boolean array  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 link \cell\pard \pard\intbl\sb95 the list of all the items of the items in the array \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 max \cell\pard \pard\intbl\sb95 highest item in the array  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 min \cell\pard \pard\intbl\sb95 lowest item in the array  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 or \cell\pard \pard\intbl\sb95 logical "or" of a boolean array  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 product \cell\pard \pard\intbl\sb95 arithmetic product of an array of numbers  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 sum \cell\pard \pard\intbl\sb95 arithmetic sum of an array of numbers  \cell\intbl\row
\pard\sb95 \line

\par All of the above operations except \i link\plain\fs20\cf1\cb1  are also multi pervasive.\line

\par The transformer \i REDUCE\plain\fs20\cf1\cb1  can be used to produce a reductive operation from a binary one.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0101}
{\up $}{\footnote\pard\plain{\up $} regexp}
{\up #}{\footnote\pard\plain{\up #} 1JDPCSA}
\pard\keepn\sb95 \b\fs25 regexp\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} regexp;string manipulation operation, regexp}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul string manipulation operation\plain\fs20\cf1\cb1 {\v string manipulation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 R regexp S   regexp R S    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 regular expression notation\plain\fs20\cf1\cb1 {\v 6YYA_NK}, \uldb regexp_match\plain\fs20\cf1\cb1 {\v 1ZS..XB}, \uldb regexp_substitute\plain\fs20\cf1\cb1 {\v 16UK_E6}\line

\par The operation \i regexp\plain\fs20\cf1\cb1  is used to find the first substring in a string \i S\plain\fs20\cf1\cb1  that matches a regular expression pattern given by \i R\plain\fs20\cf1\cb1 . The pattern can contain subgroups indicated by parentheses. If there are no subgroups in \i R\plain\fs20\cf1\cb1  then the result is a pair consisting of a boolean indicating if the search succeeded and the first substring in \i S\plain\fs20\cf1\cb1  matched by \i R\plain\fs20\cf1\cb1 . Otherwise it is a longer list with the additional items being the substrings that match the subgroups in \i R\plain\fs20\cf1\cb1 .
\par \pard\keep\sb95 \f1\fs16      'def' regexp 'abcdefghi' \line
+-+---+ \line
|l|def| \line
+-+---+ \line
 \line
     'deg' regexp 'abcdefghi' \line
+-++ \line
|o|| \line
+-++ \line
 \line
     '^(.)[bg](..)[eh]' regexp 'abcdefghi' \line
+-+-----+-+--+ \line
|l|abcde|a|cd| \line
+-+-----+-+--+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the first example, the string \i 'def'\plain\fs20\cf1\cb1  matches a substring of the right argument. In the second example the string \i 'deg'\plain\fs20\cf1\cb1  does not match. In the third example, the regular expression pattern searches for a string anchored at the beginning (by using ^) and consisting of any character followed by a "b" or a "g", followed by any two characters followed by a "c" or a "d". The result finds a match and picks out the two substrings corresponding to the two subgroups.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0102}
{\up $}{\footnote\pard\plain{\up $} regexp_match}
{\up #}{\footnote\pard\plain{\up #} 1ZS..XB}
\pard\keepn\sb95 \b\fs25 regexp_match\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} regexp_match;string manipulation operation, regexp_match}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul string manipulation operation\plain\fs20\cf1\cb1 {\v string manipulation operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 regexp_match R S [O]    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 regular expression notation\plain\fs20\cf1\cb1 {\v 6YYA_NK}, \uldb regexp\plain\fs20\cf1\cb1 {\v 1JDPCSA}, \uldb regexp_substitute\plain\fs20\cf1\cb1 {\v 16UK_E6}\line

\par The operation \i regexp_match\plain\fs20\cf1\cb1  is used to test whether there is a substring in a string \i S\plain\fs20\cf1\cb1  that matches a regular expression pattern given by \i R\plain\fs20\cf1\cb1 . It returns \i true\plain\fs20\cf1\cb1  if a match is found and \i false\plain\fs20\cf1\cb1  otherwise. If the optional argument \i O\plain\fs20\cf1\cb1  is \i "i\plain\fs20\cf1\cb1  then the search is case insensitive.
\par \pard\keep\sb95 \f1\fs16      regexp_match 'def' 'abcdefghi' \line
l \line
 \line
     regexp_match 'deg' 'abcdefghi' \line
o \line
 \line
     regexp_match '^.[bg]..[eh]' 'abcdefghi' \line
l \line
 \line
     regexp_match '^(.)[bg](..)[eh]' 'abcdefghi' \line
l \line
 \line
     regexp_match 'DEF' 'abcdefghi' "i \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the first example, the string \i 'def'\plain\fs20\cf1\cb1  matches a substring of the right argument. In the second example the string \i 'deg'\plain\fs20\cf1\cb1  does not match. In the third example, the regular expression pattern searches for a string anchored at the beginning (by using ^) and consisting of any character followed by a "b" or a "g", followed by any two characters followed by a "c" or a "d". A match is found. Example four shows that subgroups are allowed in the pattern and do not affect the match. The final example shows a case insensitive search.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0103}
{\up $}{\footnote\pard\plain{\up $} regexp_substitute}
{\up #}{\footnote\pard\plain{\up #} 16UK_E6}
\pard\keepn\sb95 \b\fs25 regexp_substitute\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} regexp_substitute;string manipulation operation, regexp_substitute}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul string manipulation operation\plain\fs20\cf1\cb1 {\v string manipulation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 regexp_substitute R S T [O]    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 regular expression notation\plain\fs20\cf1\cb1 {\v 6YYA_NK}, \uldb regexp\plain\fs20\cf1\cb1 {\v 1JDPCSA}, \uldb regexp_match\plain\fs20\cf1\cb1 {\v 1ZS..XB}\line

\par The operation \i regexp_substitute\plain\fs20\cf1\cb1  is used to replace one or more substrings in string \i T\plain\fs20\cf1\cb1  that match the regular expression pattern \i R\plain\fs20\cf1\cb1  with string \i S\plain\fs20\cf1\cb1 . If the optional argument is \i "i\plain\fs20\cf1\cb1  then the search is case insensitive. If it is \i "g\plain\fs20\cf1\cb1  then all substitutions are done.
\par \pard\keep\sb95 \f1\fs16      regexp_substitute 'def' 'XX' 'abcdefghi' \line
abcXXghi \line
 \line
     regexp_substitute 'xyz' '456' 'abcdefghi' \line
abcdefghi \line
 \line
     regexp_substitute 'DEF' 'YY' 'abcdefghi' "i \line
abcYYghi \line
 \line
     regexp_substitute 'a' '3' 'all able apes pay attention' "g \line
3ll 3ble 3pes p3y 3ttention \line
 \line
     regexp_substitute 'A' '3' 'all able apes pay attention' "ig \line
3ll 3ble 3pes p3y 3ttention\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the first example, the string \i 'def'\plain\fs20\cf1\cb1  is replaced by \i 'XX'\plain\fs20\cf1\cb1 . In the second example the string \i 'deg'\plain\fs20\cf1\cb1  does not match and \i T\plain\fs20\cf1\cb1  is returned. In the third example, the regular expression pattern matches with a case insensitive search and the substitution is done. Examples four and five show multiple substitutions first with a case sensitive pattern and then with a case insensitive one.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0104}
{\up $}{\footnote\pard\plain{\up $} registerdllfun}
{\up #}{\footnote\pard\plain{\up #} R.9.XP}
\pard\keepn\sb95 \b\fs25 registerdllfun\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} registerdllfun;system operation, registerdllfun}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 registerdllfun Nm Dllnm Path Restype Argtypes   registerdllfun Nm    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 calldllfun\plain\fs20\cf1\cb1 {\v 201S2GS}, \uldb dlllist\plain\fs20\cf1\cb1 {\v 1YSI_GC}\line

\par A Prototype DLL calling interface has been added to the Windows versions of Q'Nial (Console, GUI and DLL version).  This ability allows NIAL code to call external routines in DLL libraries.  These libraries can be user written, part of the Operating System, or 3rd party DLLs.\line

\par The DLL interface routines manage an internal table that keeps track of the currently installed DLLs and their argument types and result type.  This table also tracks if the actual library has been loaded (by a call to \i calldllfun\plain\fs20\cf1\cb1 ).  The table is preserved as part of the workspace, and once DLL functions have been registered in a workspace,  they are still available if the workspace is saved and subsequently loaded.  The CallDLL facility assures that the DLL files are loaded and unloaded appropriately.  \line

\par \pard\sb95 Every time a workspace is saved all DLL libraries are unloaded and the internal table is adjusted to reflect that.  When a workspace is loaded, none of the DLL libraries will be loaded until a specific call to \i calldllfun\plain\fs20\cf1\cb1  brings in the DLL.  This process assures that resources are not wasted on registered DLL calls that are never used.  \line

\par The \i registerdllfun\plain\fs20\cf1\cb1  routine must always be called first to enter DLL function into the internal mapping table.  This table keeps track of the name and DLL file for the routine and all of the argument types and function results.  The DLL file is \b not\plain\fs20\cf1\cb1  loaded until the routine is called with the \i calldllfun\plain\fs20\cf1\cb1  routine.  So errors involving paths to the DLL file or other related problems are not reported until the first call to \i calldllfun\plain\fs20\cf1\cb1 .\line

\par \pard\sb95 The operation \i registerdllfun\plain\fs20\cf1\cb1  initiates an interface to an external routine implemented as a DLL for 32-bit Windows. The name \i Nm\plain\fs20\cf1\cb1  is the name associated with the routine, \i Dllnm\plain\fs20\cf1\cb1  is the actual name of the DLL routine, \i Path\plain\fs20\cf1\cb1  is the path/filename to the DLL executable file, \i Restype\plain\fs20\cf1\cb1  is the result type and \i Argtypes\plain\fs20\cf1\cb1  is the list of argument types.\line

\par \i Nm\plain\fs20\cf1\cb1  is a phrase or string that is used to identify the requested DLL routine when using the \i calldllfun\plain\fs20\cf1\cb1  operation.  It can be any name you desire.  Duplicates are not allowed and the registration routine will overwrite previous table entries if the same name is used again.\line

\par \pard\sb95 \i Dllnm\plain\fs20\cf1\cb1  must be the exact name of the routine in the DLL library (case sensitive, including underscores, etc.).\line

\par \i Path\plain\fs20\cf1\cb1  must the full path to the DLL library file.  If the DLL library file is in the standard search path for DLLs then the full path is not required.\line

\par \i Restype\plain\fs20\cf1\cb1  must be a string or phrase of one the valid types described below.\line

\par \i Argtypes\plain\fs20\cf1\cb1  must be a list of the valid types described below.\line

\par If the only argument is \i Nm\plain\fs20\cf1\cb1  and this names an already installed DLL routine, then the routine is unregistered and the DLL is unloaded.\line

\par \pard\sb95 \b Calling Conventions (C or Pascal)\plain\fs20\cf1\cb1 \line

\par The facility is able to map in DLL routines compiled for both C and Pascal calling conventions.  The facility makes this determination by checking for a leading underscore on the internal name of the DLL routine.  If one exists, then it is assumed that the C calling style should be used, otherwise the PASCAL calling style is used.  It is possible to create DLL routines that do not follow this standard convention, so be careful.\line

\par When using either style calling conventions, the facility has a limit of up to 10 words of arguments (10 - 4 byte integers).  Pascal calling convention is  strict in that the number of supplied arguments must be the same as the number of required arguments.  The limit of 10, is a compiler option and can be extended if necessary.\line

\par \pard\sb95 \b Arguments to DLL routines\plain\fs20\cf1\cb1 \line

\par Currently, Q'Nial is able to pass only simple types to DLL routines.  The following is a list of the types that can be passed and returned as results:
\par  \trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 \b Type in DLL routine \cell\pard \pard\intbl\sb95 Nial Type \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 CHAR \cell\pard \pard\intbl\sb95 character \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 SHORT \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 LONG \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 WCHAR \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 LPSTR \cell\pard \pard\intbl\sb95 string \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 LPTSTR \cell\pard \pard\intbl\sb95 string \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 HANDLE \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 DWORD \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 LPDWORD \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 WORD \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 BOOL \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 HWND \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 UINT \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 DOUBLE \cell\pard \pard\intbl\sb95 real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 FLOAT \cell\pard \pard\intbl\sb95 real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 LRESULT \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 LPARAM \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 LRESULT \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 HMENU \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 LPCTSTR \cell\pard \pard\intbl\sb95 string \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 SCHAR \cell\pard \pard\intbl\sb95 char \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 SDWORD \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 SWORD \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 UDWORD \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 UWORD \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 SLONG \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 SSHORT \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 ULONG \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 USHORT \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx3325\cellx5795\pard\intbl\sb95 INT \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\pard\sb95 \line

\par These type are the simple base types used in the Windows (Win32) API (plus common types which are bolded).  The above type names (in string or phrase form) can be used as the type names required as arguments to the \i registerdllfun\plain\fs20\cf1\cb1  operation.  Each particular type affects Nial values in a different way.  Use of types other than common types generally requires a knowledge of C/C++ types and casting.  The Windows types are supplied to easily map in Windows API DLL calls.\line

\par \pard\sb95 When calling DLL routines using \i calldllfun\plain\fs20\cf1\cb1 , the facility will properly cast the incoming Nial type/value to the type of the particular argument specified by the \i registerdllfun\plain\fs20\cf1\cb1  operation.  If the Nial type cannot be converted, then \i calldllfun\plain\fs20\cf1\cb1  will report an error and exit.\line

\par \b Variable Parameters\plain\fs20\cf1\cb1 \line

\par Variable parameters are supported.  Arguments that are marked as \b variable parameters\plain\fs20\cf1\cb1 , have the returning value of the parameter added to the result list with the first element being the  normal result of the called DLL routine.  The Nial user must then select the portions of the result that are desired.\line

\par \pard\sb95 This feature also provides the ability to pass buffers to DLL routines.  Many Windows OS DLL routines require a (char *) type pointer to a pre-allocated buffer and a buffer size.   The routine places the result in the buffer up to the specified size.  The interface to such a routine can be accomplished by sending a Nial string of the desired buffer size and the accompanying size integer as the arguments, having specified the first argument as a variable parameter.  The resulting string is added to the result list  with the first element being the normal result of the DLL routine call.\line

\par \pard\sb95 When passing variable parameters, the facility makes an internal copy of the data being passed.  The called DLL routine uses this copy.  This approach helps prevent the possibility of a DLL routine incorrectly manipulating the actual contents of a Nial array and causing a corruption of the workspace.\line

\par To specify that an argument is a variable parameter in the \i registerdllfun\plain\fs20\cf1\cb1  call prepend a \i *\plain\fs20\cf1\cb1  (asterisk) to the beginning of the type name (i.e. *CHAR).  This indicates that the type is to be passed as a pointer (if it is not already a pointer), and that the result for that parameter is to be appended to the result of the entire call.  Any, none or all of the parameters may be variable.\line

\par \pard\sb95 \b Functions Requiring Pointers to Data\plain\fs20\cf1\cb1 \line

\par Another common requirement of Windows OS DLL calls (and others too), is that they require the \i address\plain\fs20\cf1\cb1  of a variable to be passed as an argument instead of the actual value.  The DLL function uses the value at the supplied memory address.\line

\par This capability is supported, and can be denoted by prepending a \i &\plain\fs20\cf1\cb1  (ampersand) to the beginning of the type name (i.e. &INT). At the Nial level, you still pass the \i calldllfun\plain\fs20\cf1\cb1  call a plain integer for that particular argument, but the CallDLL interface allocates memory for that argument, copies the value into the new memory, and passes the address of the memory cell to the DLL call.  Upon return, the allocated memory is deallocated.  \line

\par \pard\sb95 The \i &\plain\fs20\cf1\cb1  modifier can be used in conjunction with the \i *\plain\fs20\cf1\cb1  modifier.  This usage generally denotes an argument that is a pointer to a type and whose value you wish returned along with the result.\line

\par \b Example 1\plain\fs20\cf1\cb1 \line

\par Let say we have a DLL routine that takes 3 argument.  The first argument is the true argument and the next two are pointers to memory locations where two additional results are to be placed.  The function also returns an integer result.\line

\par The routine squares the first argument and places the result at the memory location specified by the second argument.  It also cubes the first argument and place the result in the location specified by the third argument.  The function result is what is supplied as the first argument.
\par \pard\keep\sb95 \f1\fs16      registerdllfun "sq "_squarecube 'c:\'5cmyops.dll' "INT ["INT,"&*INT,"&*INT] \line
 \line
     calldllfun "sq 5 -10 -10 \line
+---+----+-----+ \line
| 5 | 25 | 125 | \line
+---+----+-----+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 So the call passes in 5 as the true argument and two -10 values as dummy values for the next two arguments (it is possible that the function might require all arguments to specify proper values).  The result is an array of 3 items, one is the function result and an additional item for every variable parameter in the argument list.  \line

\par \b Example 2\plain\fs20\cf1\cb1 \line

\par The following is a call to a Windows API routines that requires a string buffer to be passed to the call:
\par \pard\keep\sb95 \f1\fs16      registerdllfun "_GetComputerName "GetComputerNameA  \line
        'kernel32.dll' "BOOL ['*LPTSTR', 'LPDWORD']; \line
 \line
GetComputerName IS \{\- \line
   res name := calldllfun "_GetComputerName (1000 reshape ' ') 1000; \line
   IF res = 1 THEN \line
     name \line
   ELSE \line
     'Error Getting Computer Name' \line
   ENDIF \line
\'7d \line
 \line
     GetComputerName \line
INIGO\plain\fs20\cf1\cb1 \line

\par \pard\sb95 Notice how the above code calls the DLL routine with an empty string buffer (1000 reshape ' ') and also passes the size of the buffer (1000).  The Windows API requires this in order to safely write the Computer name in the buffer without overflowing the string buffer.  The buffer argument is marked as a variable argument, so the result is passed back in the \i calldllfun\plain\fs20\cf1\cb1  call.\line

\par \b A Word of Warning\plain\fs20\cf1\cb1 \line

\par Use of DLL routines can cause unexpected results if incorrect parameters as passed.  It is reasonable easy to crash the Nial application with a bad DLL call.  Additionally, memory allocated inside a DLL function is not deallocated by Nial.  Unless there is a symmetric DLL routine to deallocate memory, a memory leak will result if such a routine is used.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0105}
{\up $}{\footnote\pard\plain{\up $} regular expression notation}
{\up #}{\footnote\pard\plain{\up #} 6YYA_NK}
\pard\keepn\sb95 \b\fs25 regular expression notation\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, regular expression notation;regular expression notation}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 regexp\plain\fs20\cf1\cb1 {\v 1JDPCSA}, \uldb regexp_match\plain\fs20\cf1\cb1 {\v 1ZS..XB}, \uldb regexp_substitute\plain\fs20\cf1\cb1 {\v 16UK_E6}\line

\par The following table gives the standard notations used in regular expressions:
\par  \trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 \b Notation \cell\pard \pard\intbl\sb95 Matching String \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 . \cell\pard \pard\intbl\sb95 any character \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 * \cell\pard \pard\intbl\sb95 the previous character zero or more times \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 + \cell\pard \pard\intbl\sb95 the previous character 1 or more times \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 ^ \cell\pard \pard\intbl\sb95 when at the beginning of a regular expression, matches the beginning of the string. \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 $ \cell\pard \pard\intbl\sb95 when at the end of a regular expression, matches the end of the string. \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 [xyz] \cell\pard \pard\intbl\sb95 any character in the sequence of characters "xyz" where "xyz" can be almost any sequence of characters. \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 [^xyz] \cell\pard \pard\intbl\sb95 any character NOT in the sequence of characters "xyz". \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 [x-y] \cell\pard \pard\intbl\sb95 any character in the range of x to y. \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 | \cell\pard \pard\intbl\sb95 allows the optional match of the regular expression on the left or the right of the "|". \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 () \cell\pard \pard\intbl\sb95 bracketing allows the specification of groups.  Anything that is matched between a set of brackets can later be extracted. Also used for bracketing regular expressions to force order of precedence. \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 <other char> \cell\pard \pard\intbl\sb95 itself \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 \'5c<any char> \cell\pard \pard\intbl\sb95 the character \cell\intbl\row
\pard \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0106}
{\up $}{\footnote\pard\plain{\up $} repeat-loop}
{\up #}{\footnote\pard\plain{\up #} 12OGSY0}
\pard\keepn\sb95 \b\fs25 repeat-loop\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} control structure, repeat-loop;repeat-loop}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul control structure\plain\fs20\cf1\cb1 {\v control structure}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 REPEAT expression_sequence UNTIL conditional_expression ENDREPEAT    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 while-loop\plain\fs20\cf1\cb1 {\v TQAIFP}, \uldb for-loop\plain\fs20\cf1\cb1 {\v MT.6OU}\line

\par The \i REPEAT-loop\plain\fs20\cf1\cb1  notation is used when executing an expression sequence repeatedly until a conditional expression returns \i true\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      F := open Filenm "r; \line
     Lines := ''; \line
     Done := o; \line
     REPEAT \line
       Line := readfile F; \line
       IF isfault Line THEN \line
         Done := l; \line
       ELSE \line
         Lines := Lines append Line; \line
       ENDIF; \line
     UNTIL Done ENDREPEAT;\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0107}
{\up $}{\footnote\pard\plain{\up $} reserved words}
{\up #}{\footnote\pard\plain{\up #} 10F734O}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 reserved words\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} reserved words;syntax, reserved words}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}\line

\par \pard\sb95 A \b reserved word\plain\fs20\cf1\cb1  or \b keyword\plain\fs20\cf1\cb1  is one that has a special usage in a Nial construct and must be used only for that purpose.  A \i block\plain\fs20\cf1\cb1  delimits a local environment.  It allows new uses of names which do not interfere with uses of those names outside the block.  For example, within a block, a predefined operation name can be redefined and used for a different purpose.  Only the reserved words of Q'Nial cannot be reused in this fashion.  \line

\par An identifier, which is spelled the same, ignoring case, as any of the reserved words given below cannot be used to name a variable or a definition.  In a local environment, an identifier can be chosen that is the same as a predefined or user-defined global definition name.  Such a choice makes the global use of the name unavailable in the local context.  \line

\par \pard\sb95 A reserved word is displayed in upper case in canonical form.  
\par  \trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 \b Reserved Word \cell\pard \pard\intbl\sb95 Construct \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 BEGIN \cell\pard \pard\intbl\sb95 Synonym for \{\- in block \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 CASE \cell\pard \pard\intbl\sb95 case-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 DO \cell\pard \pard\intbl\sb95 for-expression, while-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 ELSE \cell\pard \pard\intbl\sb95 if-expression, case-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 ELSEIF \cell\pard \pard\intbl\sb95 if-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 END \cell\pard \pard\intbl\sb95 case-expression, synonym for \'7d in block \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 ENDCASE \cell\pard \pard\intbl\sb95 case_expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 ENDFOR \cell\pard \pard\intbl\sb95 for-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 ENDIF \cell\pard \pard\intbl\sb95 if-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 ENDREPEAT \cell\pard \pard\intbl\sb95 repeat-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 ENDWHILE \cell\pard \pard\intbl\sb95 while-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 EXIT \cell\pard \pard\intbl\sb95 exit-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 EXPRESSION \cell\pard \pard\intbl\sb95 declaration \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 EXTERNAL \cell\pard \pard\intbl\sb95 declaration \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 FOR \cell\pard \pard\intbl\sb95 for-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 FROM \cell\pard \pard\intbl\sb95 case-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 GETS \cell\pard \pard\intbl\sb95 assign-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 IF \cell\pard \pard\intbl\sb95 if-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 IS \cell\pard \pard\intbl\sb95 definition \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 LOCAL \cell\pard \pard\intbl\sb95 declaration \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 NONLOCAL \cell\pard \pard\intbl\sb95 declaration \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 OP \cell\pard \pard\intbl\sb95 synonym for operation \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 OPERATION \cell\pard \pard\intbl\sb95 operation-form, declaration \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 REPEAT \cell\pard \pard\intbl\sb95 repeat-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 THEN \cell\pard \pard\intbl\sb95 if-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 TR \cell\pard \pard\intbl\sb95 synonym for transformer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 TRANSFORMER \cell\pard \pard\intbl\sb95 transformer-form, declaration \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 UNTIL \cell\pard \pard\intbl\sb95 repeat-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 VARIABLE \cell\pard \pard\intbl\sb95 declaration \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 WHILE \cell\pard \pard\intbl\sb95 while-expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx2325\cellx5795\pard\intbl\sb95 WITH \cell\pard \pard\intbl\sb95 for-expression \cell\intbl\row
\pard \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0108}
{\up $}{\footnote\pard\plain{\up $} reshape}
{\up #}{\footnote\pard\plain{\up #} 3I4D_MA}
\pard\keepn\sb95 \b\fs25 reshape\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} reshape;reshaping operation, reshape}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul reshaping operation\plain\fs20\cf1\cb1 {\v reshaping operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A reshape B   reshape A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 post\plain\fs20\cf1\cb1 {\v 1CMG_HN}, \uldb shape\plain\fs20\cf1\cb1 {\v TYQ56K}, \uldb tally\plain\fs20\cf1\cb1 {\v 5JEH.UN}\line

\par The operation \i reshape\plain\fs20\cf1\cb1  is the major mechanism in Nial for creating multivalent arrays.  The operation requires \i A\plain\fs20\cf1\cb1  to be a shape, either \i Null\plain\fs20\cf1\cb1  or a list of integers.  If \i A\plain\fs20\cf1\cb1  is an integer, it is converted to the solitary holding the integer.  If \i A\plain\fs20\cf1\cb1  is not a shape, the result is the fault \i ?shape\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 The result of \i reshape\plain\fs20\cf1\cb1  is an array of shape \i A\plain\fs20\cf1\cb1  with items chosen from the list of items of \i B\plain\fs20\cf1\cb1 .  If the number of items to be used to fill the result is less than the tally of \i B\plain\fs20\cf1\cb1 , the remaining items of \i B\plain\fs20\cf1\cb1  are ignored.  If the number is more than the tally of \i B\plain\fs20\cf1\cb1 , the items of \i B\plain\fs20\cf1\cb1  are used cyclically.  If \i B\plain\fs20\cf1\cb1  has no items, fault \i ?fill\plain\fs20\cf1\cb1  is used as the items of the result.  
\par \pard\keep\sb95 \f1\fs16      2 3 reshape 4 6 (4 5) 3 "abc \line
+-+---+---+ \line
|4|  6|4 5| \line
+-+---+---+ \line
|3|abc|  4| \line
+-+---+---+ \line
     2 3 reshape 'abcdefghij' \line
abc \line
def \line
     5 reshape solitary 3 4 \line
+---+---+---+---+---+ \line
|3 4|3 4|3 4|3 4|3 4| \line
+---+---+---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The last example illustrates that to replicate an arbitrary array, in this case the pair 3 4, \i reshape\plain\fs20\cf1\cb1  is applied to the solitary holding the array.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape A reshape A = A \line
   shape A reshape list A = A \line
   shape A reshape (first A hitch rest A) =f= A \line
   A a shape implies ==> shape (A reshape B) = A \line
   A reshape list B = A reshape B \line
   A is a shape ==> EACH f (A reshape B) = A reshape EACH f B \line
   tally A reshape A = list A \line
   (tally A) 1 reshape A = post A \line
   single A = Null reshape solitary A \line
   solitary A = [ 1 ] reshape single A \line
   Null = [ 0 ] reshape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0109}
{\up $}{\footnote\pard\plain{\up $} rest}
{\up #}{\footnote\pard\plain{\up #} 1CMI3HN}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 rest\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} rest;selection operation, rest}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 rest A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 first\plain\fs20\cf1\cb1 {\v 7CFFMJ}, \uldb front\plain\fs20\cf1\cb1 {\v 7COCHJ}, \uldb drop\plain\fs20\cf1\cb1 {\v 5FYX_OT}, \uldb sublist\plain\fs20\cf1\cb1 {\v 88JHY6}\line

\par The operation \i rest\plain\fs20\cf1\cb1  returns the list of \i A\plain\fs20\cf1\cb1  after dropping the first item of the list.  If the argument of \i rest\plain\fs20\cf1\cb1  is not a list, it is treated as a list.  
\par \pard\keep\sb95 \f1\fs16      rest 3 4 5 6 \line
4 5 6 \line
     rest tell 2 3 \line
+---+---+---+---+---+ \line
|0 1|0 2|1 0|1 1|1 2| \line
+---+---+---+---+---+ \line
     rest 7 = Null \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The last example shows that the rest of an atom is the empty list \i Null\plain\fs20\cf1\cb1 .  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      rest IS OPERATION A (1 drop list A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    rest A = rest list A \line
   not empty A ==> first A hitch rest A = list A \line
   tally rest A = 0 max (tally A - 1) \line
   first rest A = second A \line
   rest Null = Null \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:010a}
{\up $}{\footnote\pard\plain{\up $} restart}
{\up #}{\footnote\pard\plain{\up #} 3I4P_OP}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 restart\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} restart;system expression, restart}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Restart    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 clearws\plain\fs20\cf1\cb1 {\v .C2G42}, \uldb load\plain\fs20\cf1\cb1 {\v QD7_IY}, \uldb latent\plain\fs20\cf1\cb1 {\v 4YEDEP}, \uldb recover\plain\fs20\cf1\cb1 {\v 7L0TNT}, \uldb toplevel\plain\fs20\cf1\cb1 {\v 3A08M4I}\line

\par The expression \i Restart\plain\fs20\cf1\cb1  is used to restart a Q'Nial session.  It causes the workspace to be cleared and Q'Nial to be reinitialized to be in the same state it was when the session began.  If the original invocation used a named workspace or a definition file, it is reloaded as before.  \line

\par The advantage of \i Restart\plain\fs20\cf1\cb1  over \i Clearws\plain\fs20\cf1\cb1  is that the user can start the application again using \i Restart\plain\fs20\cf1\cb1  and possibly trigger a \i Latent\plain\fs20\cf1\cb1  expression in the starting workspace.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:010b}
{\up $}{\footnote\pard\plain{\up $} resume}
{\up #}{\footnote\pard\plain{\up #} 1JE1SH6}
\pard\keepn\sb95 \b\fs25 resume\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} debugging command, resume;resume}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul debugging command\plain\fs20\cf1\cb1 {\v debugging command}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 resume    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 break\plain\fs20\cf1\cb1 {\v 2V9T7BV}, \uldb step\plain\fs20\cf1\cb1 {\v 1CMJB0J}, \uldb next\plain\fs20\cf1\cb1 {\v 40X4IY}, \uldb toend\plain\fs20\cf1\cb1 {\v 7QL9H0}, \uldb debugging\plain\fs20\cf1\cb1 {\v PP0_XH}, \uldb setdeftrace\plain\fs20\cf1\cb1 {\v 1O7K0X3}\line

\par When \i break debug mode\plain\fs20\cf1\cb1  is initiated by means of the \i Break\plain\fs20\cf1\cb1  expression or the operation \i breakin\plain\fs20\cf1\cb1  (or by using \i <Ctrl b>\plain\fs20\cf1\cb1  while awaiting input in window mode on a console version), a break loop is initiated with output like: 
\par \pard\keep\sb95 \f1\fs16 -------------------------------------------------------------- \line
    Break debug loop: enter debug commands, expressions or  \line
      type: resume    to exit debug loop \line
      <Return> executes the indicated debug command \line
    current call stack : \line
foo \line
------------------------------------------------------------- \line
?.. C := A + ( + A + A ) \line
-->[stepv]\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the above example the break loop awaits input with the default command \i stepv\plain\fs20\cf1\cb1  assumed.  If \i resume\plain\fs20\cf1\cb1  is typed then the break loop is exited and control returns to the expression following the break point.  
\par \pard\keep\sb95 \f1\fs16      Break \line
-------------------------------------------------------------- \line
    Break debug loop: enter debug commands, expressions or  \line
      type: resume    to exit debug loop \line
      <Return> executes the indicated debug command \line
    current call stack : \line
------------------------------------------------------------- \line
?.. C := A + ( + A + A ) \line
-->[stepv] resume\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:010c}
{\up $}{\footnote\pard\plain{\up $} reverse}
{\up #}{\footnote\pard\plain{\up #} U_.PHW}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 reverse\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} data rearrangement operation, reverse;reverse}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul data rearrangement operation\plain\fs20\cf1\cb1 {\v data rearrangement operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 reverse A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 transpose\plain\fs20\cf1\cb1 {\v 2UPAHZ}, \uldb rotate\plain\fs20\cf1\cb1 {\v 72C..35}, \uldb list\plain\fs20\cf1\cb1 {\v 40V8DY}\line

\par The operation \i reverse\plain\fs20\cf1\cb1  returns an array of the same shape as \i A\plain\fs20\cf1\cb1  having the items in reverse order.  
\par \pard\keep\sb95 \f1\fs16      reverse 4 5 6 7 \line
7 6 5 4 \line
 \line
     reverse 'able was I ere I saw Melba' \line
ableM was I ere I saw elba \line
     EACH reverse 'This' 'seems' 'too' 'wonderful' \line
+----+-----+---+---------+ \line
|sihT|smees|oot|lufrednow| \line
+----+-----+---+---------+ \line
 \line
     reverse count 3 4 \line
+---+---+---+---+ \line
|3 4|3 3|3 2|3 1| \line
+---+---+---+---+ \line
|2 4|2 3|2 2|2 1| \line
+---+---+---+---+ \line
|1 4|1 3|1 2|1 1| \line
+---+---+---+---+ \line
 \line
     reverse (10 take) reverse sketch 1.23 \line
      1.23\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The fourth example illustrates that the reverse of a 3 by 4 table is a 3 by 4 table with the list of items reversed.  The last example shows the use of \i take\plain\fs20\cf1\cb1  and \i reverse\plain\fs20\cf1\cb1  to right-justify text in a field.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      reverse IS OPERATION A \{\-  \line
        shape A reshape (tally A - count tally A choose A) \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape reverse A = shape A \line
   reverse reverse A = A \line
   reverse A = shape A reshape reverse list A \line
   front A = reverse rest reverse A \line
   last A = first reverse A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:010d}
{\up $}{\footnote\pard\plain{\up $} role}
{\up #}{\footnote\pard\plain{\up #} QD__TZ}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 role\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, role;role}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 global environment\plain\fs20\cf1\cb1 {\v 0.KANS}\line

\par The term \b role\plain\fs20\cf1\cb1  is used to describe the class of object associated with an identifier in Nial. The possible roles are: reserved word, variable, expression, operation or transformer. An identifier that corresponds to a reserved word can play no other role in a workspace. An identifier that corresponds to a predefined object in Nial cannot be changed in the global environment, but can take on a different object association in a local environment. In the global environment, once the role of an identifier is established, it must keep the same role, but may have its association changed to another object of the same role.\line

\par \pard\sb95 An external-declaration assigns a role to a name in the global environment so that the name can be used in other definitions before it is completely specified.  This mechanism is useful for creating mutually recursive definitions.  An external declaration is made only in the global environment.  \line

\par If the name is already defined with the same role, the declaration has no effect.  If the name has another role, a fault is reported.  \line

\par If the expression on the right of \i IS\plain\fs20\cf1\cb1  in a definition uses the name being defined, the definition is assumed to be recursive.  The name is assigned a role compatible with its use on the right if it does not already have a role.  \line

\par \pard\sb95 If a definition appears within a block, the association between the name of the identifier and its meaning is made in the local environment.  Otherwise, the association is made in the global environment and the definition assigns a role to the name as representing that kind of expression.  \line

\par If the name being associated in a definition is already in use, the new definition must be for a construct of the same role and the earlier definition is replaced.  The use of a defined name always refers to its most recent definition.  \line

\par \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:010e}
{\up $}{\footnote\pard\plain{\up $} rotate}
{\up #}{\footnote\pard\plain{\up #} 72C..35}
\pard\keepn\sb95 \b\fs25 rotate\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} data rearrangement operation, rotate;rotate}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul data rearrangement operation\plain\fs20\cf1\cb1 {\v data rearrangement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A rotate B   rotate A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 reverse\plain\fs20\cf1\cb1 {\v U_.PHW}, \uldb transpose\plain\fs20\cf1\cb1 {\v 2UPAHZ}, \uldb list\plain\fs20\cf1\cb1 {\v 40V8DY}\line

\par The operation \i rotate\plain\fs20\cf1\cb1  shifts the items of array \i B\plain\fs20\cf1\cb1  to the left \i A\plain\fs20\cf1\cb1  places, inserting the items that drop off the front of the list on the back.  If \i A\plain\fs20\cf1\cb1  is a negative number, the shift is to the right.  
\par \pard\keep\sb95 \f1\fs16      2 rotate 24 35 46 57 12 24 39 \line
46 57 12 24 39 24 35 \line
 \line
     -5 rotate tell 3 5 \line
+---+---+---+---+---+ \line
|2 0|2 1|2 2|2 3|2 4| \line
+---+---+---+---+---+ \line
|0 0|0 1|0 2|0 3|0 4| \line
+---+---+---+---+---+ \line
|1 0|1 1|1 2|1 3|1 4| \line
+---+---+---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The second example shows that on a table \i rotate\plain\fs20\cf1\cb1  works on the list of items in row major order.\line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      rotate IS OPERATION N A \{\-  \line
        Newlist :=  tally A + N + grid A mod tally A choose list A; \line
        shape A reshape Newlist \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    N an integer ==> shape (N rotate A) = shape A \line
   N rotate A = shape A reshape (N rotate list A) \line
   N rotate A = N mod tally A rotate A \line
   N rotate A = opposite(tally A-N) rotate A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:010f}
{\up $}{\footnote\pard\plain{\up $} rows}
{\up #}{\footnote\pard\plain{\up #} 1CMI_LM}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 rows\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} nesting restructuring operation, rows;rows}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nesting restructuring operation\plain\fs20\cf1\cb1 {\v nesting restructuring operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 rows A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 cols\plain\fs20\cf1\cb1 {\v QCY_U_}, \uldb split\plain\fs20\cf1\cb1 {\v 5JDW.RI}, \uldb mix\plain\fs20\cf1\cb1 {\v 1_E72_N}, \uldb rank\plain\fs20\cf1\cb1 {\v QD.ZW5}\line

\par The operation \i rows\plain\fs20\cf1\cb1  is normally used on a table \i A\plain\fs20\cf1\cb1 .  In this case, it returns a list of lists, with each item being a list of items from one row of the table.  For a multidimensional array, the result is an array of lists of length equal to the length of the last axis of \i A\plain\fs20\cf1\cb1 .  The valence of the result is one less than the valence of \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      A := 2 3 reshape "Bill "Tom "Mary "Jack "Dawn "Alice \line
Bill Tom  Mary \line
Jack Dawn Alice \line
 \line
     rows A \line
+-------------+---------------+ \line
|Bill Tom Mary|Jack Dawn Alice| \line
+-------------+---------------+ \line
 \line
     A :=  2 2 2 3 reshape count 32 \line
1 2 3       7  8  9 \line
4 5 6      10 11 12\plain\fs20\cf1\cb1 
\par \f1\fs16      rows A \line
+-----+--------+  +--------+--------+ \line
|1 2 3|4 5 6   |  |13 14 15|16 17 18| \line
+-----+--------+  +--------+--------+ \line
|7 8 9|10 11 12|  |19 20 21|22 23 24| \line
+-----+--------+ +--------+--------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      rows IS OPERATION A ( valence A - 1 max 0 raise A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape rows A = front shape A not empty A ==> shape first rows A = last shape A \line
   not empty A ==> mix rows A = A \line
   T a variable associated with a table ==> I pick rows T = T|[I,] \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0110}
{\up $}{\footnote\pard\plain{\up $} save}
{\up #}{\footnote\pard\plain{\up #} 25VUZ7O}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 save\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} save;system operation, save}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 save Wsname    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 load\plain\fs20\cf1\cb1 {\v QD7_IY}, \uldb checkpoint\plain\fs20\cf1\cb1 {\v 4LLHD1P}, \uldb recover\plain\fs20\cf1\cb1 {\v 7L0TNT}, \uldb latent\plain\fs20\cf1\cb1 {\v 4YEDEP}, \uldb restart\plain\fs20\cf1\cb1 {\v 3I4P_OP}\line

\par The operation \i save\plain\fs20\cf1\cb1  is used to save a workspace with the name given by the phrase or string \i Wsname\plain\fs20\cf1\cb1 .  The convention in Q'Nial is to name workspaces with the extension \i .nws\plain\fs20\cf1\cb1  so that they are easy to find in the directory.  When saving or loading a workspace, the extension may be omitted.  \line

\par The effect of saving a workspace is to place the contents of the current workspace in the named file in an internal format.  The contents of the current workspace are unchanged by doing a \i save\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      save "mywork\plain\fs20\cf1\cb1 \line

\par \pard\sb95 A \i save\plain\fs20\cf1\cb1  operation may be executed within an operation or expression.  The effect is to interrupt the execution and do the save at the top level.  If the saved workspace contains a user-defined expression with the name \i Checkpoint\plain\fs20\cf1\cb1 , at the termination of the \i save\plain\fs20\cf1\cb1 , \i Checkpoint\plain\fs20\cf1\cb1  is executed.  \i Checkpoint\plain\fs20\cf1\cb1  can be used to restart the computation.  \line

\par If the saved workspace contains an expression with the name \i Latent\plain\fs20\cf1\cb1 , whenever the workspace is loaded, the \i load\plain\fs20\cf1\cb1  operation will execute the \i Latent\plain\fs20\cf1\cb1  expression.  This can be used to have a workspace automatically begin an application, or to set up desired default values for various switch settings.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0111}
{\up $}{\footnote\pard\plain{\up $} scan}
{\up #}{\footnote\pard\plain{\up #} 1CMJ16H}
\pard\keepn\sb95 \b\fs25 scan\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} evaluation operation, scan;scan}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 scan S    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 parse\plain\fs20\cf1\cb1 {\v TVJF9K}, \uldb eval\plain\fs20\cf1\cb1 {\v 40OE2Q}, \uldb descan\plain\fs20\cf1\cb1 {\v 7ABG_7N}, \uldb deparse\plain\fs20\cf1\cb1 {\v 15N2FZO}, \uldb execute\plain\fs20\cf1\cb1 {\v 3WULI4D}\line

\par The operation \i scan\plain\fs20\cf1\cb1  translates Nial program text to internal form.  This process is called tokenizing as it results in a list containing tokens.  The argument \i S\plain\fs20\cf1\cb1  is a string.  The result is a list beginning with 99 and followed by an alternating sequence of integer codes and phrases.  
\par \pard\keep\sb95 \f1\fs16      scan 'A := 3 * 5.2' \line
99 2 A 1 := 16 3 2 * 18 5.2 \line
 \line
     scan 'sum 2 (35 + 42.7)' \line
99 2 SUM 16 2 1 ( 16 35 2 + 18 42.7 1 ) \line
 \line
     scan 'foo IS first rest' \line
99 2 FOO 1 IS 2 FIRST 2 REST\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example has 5 tokens, the second has 7 and the third has 4.  In a token stream, the token for an identifier is in upper case.  \line

\par The \i scan\plain\fs20\cf1\cb1  token codes are given below:
\par  \trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 \b Code \cell\pard \pard\intbl\sb95 Meaning \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 1 \cell\pard \pard\intbl\sb95 reserved word or delimiter \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 2 \cell\pard \pard\intbl\sb95 identifier \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 14 \cell\pard \pard\intbl\sb95 string \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 15 \cell\pard \pard\intbl\sb95 phrase \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 16 \cell\pard \pard\intbl\sb95 integer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 18 \cell\pard \pard\intbl\sb95 real number \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 22 \cell\pard \pard\intbl\sb95 fault \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 42 \cell\pard \pard\intbl\sb95 atomic character \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 40 \cell\pard \pard\intbl\sb95 atomic boolean or bitstring \cell\intbl\row
\pard\sb95 \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    S a string ==> execute S = eval parse scan S \line
   S a string ==> scan descan scan A = scan A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0112}
{\up $}{\footnote\pard\plain{\up $} scope of a variable}
{\up #}{\footnote\pard\plain{\up #} 42GY_XT}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 scope of a variable\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, scope of a variable;scope of a variable}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 local environment\plain\fs20\cf1\cb1 {\v BN.OFR}, \uldb role\plain\fs20\cf1\cb1 {\v QD__TZ}\line

\par The use of an assign-expression indicates that a name (identifier) is to be treated as a variable in the context surrounding the assign-expression.  This context is called the \b scope\plain\fs20\cf1\cb1  of the variable.  The context may be global, in which case the variable may be visible at all levels; or it may be local to some region of program text.  A local scope is created for the parameters of operation forms and for variables created within a block.  \line

\par \pard\sb95 Because operation forms or blocks may appear within other operation forms or blocks, it is possible to have one scope for a name nested within another.  A name is said to be visible at a point in a program text if it has a local meaning at that point or has a meaning in some surrounding scope or is a global name.  When a name is used in a local scope, it is the local association in the innermost scope that is used, instead of an association with the same name in a surrounding scope.  \line

\par \pard\sb95 A block is a scope-creating mechanism that permits an expression-sequence to be created so that it has local definitions and variables which are visible only inside the block.  A block may appear as a primary-expression or as the body of an operation-form.  \line

\par Definitions that appear within the block have local scope.  That is, the definitions can be referenced only in the body of the block.  Variables assigned within the block may or may not have local scope, depending on the appearance of a local and/or a nonlocal declaration.  If there is no declaration, all assigned variables have local scope.  Declaring some variables as local does not change the effect on undeclared variables that are used on the left of assignment.  They are automatically localized.  \line

\par \pard\sb95 If a nonlocal declaration is used, an assigned name that is on the nonlocal list is sought in surrounding scopes.  If the name is not found, a variable is created in the global environment.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0113}
{\up $}{\footnote\pard\plain{\up $} second}
{\up #}{\footnote\pard\plain{\up #} 1KDLMI5}
\pard\keepn\sb95 \b\fs25 second\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} second;selection operation, second}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 second A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 first\plain\fs20\cf1\cb1 {\v 7CFFMJ}, \uldb third\plain\fs20\cf1\cb1 {\v 7QE_L0}, \uldb pick\plain\fs20\cf1\cb1 {\v 40Z84P}, \uldb take\plain\fs20\cf1\cb1 {\v 25VVYWO}\line

\par The operation \i second\plain\fs20\cf1\cb1  returns the second of the items of \i A\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  has only one item or it is empty, it returns the fault \i ?address\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      second 4 5 6 \line
5 \line
 \line
     second tell 3 4 \line
0 1 \line
 \line
     second Null \line
?address\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      second IS OPERATION A (1 pick list A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    second list B = second B \line
   second B = first rest B \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0114}
{\up $}{\footnote\pard\plain{\up $} see}
{\up #}{\footnote\pard\plain{\up #} 1ZNC7PK}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 see\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} see;system operation, see}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 see Defname    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 descan\plain\fs20\cf1\cb1 {\v 7ABG_7N}, \uldb deparse\plain\fs20\cf1\cb1 {\v 15N2FZO}, \uldb getdef\plain\fs20\cf1\cb1 {\v 2EC.B}\line

\par The operation \i see\plain\fs20\cf1\cb1  displays the definition of the user defined object named by the phrase or string \i Defname\plain\fs20\cf1\cb1 .  The canonical form of the definition appears directly on the screen.  The operation cannot be used on predefined names.  The display is in \i sketch/nodecor\plain\fs20\cf1\cb1  mode regardless of the current settings.  
\par \pard\keep\sb95 \f1\fs16      foo IS first rest; \line
     see "foo \line
foo IS first rest\plain\fs20\cf1\cb1 \line

\par \pard\sb95 It is possible to capture the display given by \i see\plain\fs20\cf1\cb1  using the composition of operations \i descan deparse getdef Defname\plain\fs20\cf1\cb1 , which returns the list of lines of the display.  This technique is used in the operation \i defedit\plain\fs20\cf1\cb1 .  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      see IS OPERATION A \{\-  \line
        Settings gets EACH set "sketch "decor;  \line
        ITERATE writescreen descan deparse getdef A;  \line
        EACH set Settings; \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0115}
{\up $}{\footnote\pard\plain{\up $} seed}
{\up #}{\footnote\pard\plain{\up #} 25VV2QN}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 seed\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} array generation operation, seed;seed}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul array generation operation\plain\fs20\cf1\cb1 {\v array generation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 seed Num    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 random\plain\fs20\cf1\cb1 {\v X7KC2Y}, \uldb floor\plain\fs20\cf1\cb1 {\v 7CICIH}\line

\par The operation \i seed\plain\fs20\cf1\cb1  sets the initial number for the random number generator used by \i random\plain\fs20\cf1\cb1 .  The argument \i Num\plain\fs20\cf1\cb1  is a positive decimal fraction less than 1.  \i Seed\plain\fs20\cf1\cb1  is used to get predictable results from a program that uses \i random\plain\fs20\cf1\cb1 .  \i Seed\plain\fs20\cf1\cb1  returns the value that would have been used to generate the next random number.  
\par \pard\keep\sb95 \f1\fs16      seed .25374; \line
     floor (100. * random 3) \line
60 73 83\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0116}
{\up $}{\footnote\pard\plain{\up $} seek}
{\up #}{\footnote\pard\plain{\up #} 1CMJ30E}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 seek\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} search operation, seek;seek}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul search operation\plain\fs20\cf1\cb1 {\v search operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A seek B   seek A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 in\plain\fs20\cf1\cb1 {\v RJ2SC2}, \uldb find\plain\fs20\cf1\cb1 {\v QD17VY}\line

\par The operation \i seek\plain\fs20\cf1\cb1  returns a pair of values.  The first is a boolean indicating whether or not \i A\plain\fs20\cf1\cb1  is an item of \i B\plain\fs20\cf1\cb1 .  The second is the address of the first occurrence of \i A\plain\fs20\cf1\cb1  as an item of \i B\plain\fs20\cf1\cb1 , searching \i B\plain\fs20\cf1\cb1  in row major order.  If \i A\plain\fs20\cf1\cb1  does not occur in \i B\plain\fs20\cf1\cb1 , the second item of the result is the gage of the shape of \i B\plain\fs20\cf1\cb1 .  \i Seek\plain\fs20\cf1\cb1  is the combination of \i in\plain\fs20\cf1\cb1  and \i find\plain\fs20\cf1\cb1  in one operation.  
\par \pard\keep\sb95 \f1\fs16      3 seek 56 34 3 23 57 3 \line
l 2 \line
 \line
     `a seek 'hello world' \line
o 11\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \i Seek\plain\fs20\cf1\cb1  is useful when determining whether or not \i A\plain\fs20\cf1\cb1  is in \i B\plain\fs20\cf1\cb1  and, if it is, obtaining its position in \i B\plain\fs20\cf1\cb1 .  Both results are obtained in one internal computation rather than two separate ones.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      seek IS OPERATION A B \{\- A [in,find] B \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    first (A seek B) = A in B \line
   second (A seek B) = A find B \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Pragmatics\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      The operation  \line
seek \line
 uses a linear search on the items of  \line
B \line
 if the array has not been sorted, or uses a binary search algorithm if it has.  The latter fact suggests that an array that is searched frequently should be kept in lexicographical order by applying  \line
sortup \line
 to it when it is created.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0117}
{\up $}{\footnote\pard\plain{\up $} seeprimcalls}
{\up #}{\footnote\pard\plain{\up #} 3_ALKA}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 seeprimcalls\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} seeprimcalls;system operation, seeprimcalls}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 seeprimcalls Mode    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 break\plain\fs20\cf1\cb1 {\v 2V9T7BV}, \uldb debugging\plain\fs20\cf1\cb1 {\v PP0_XH}, \uldb breaklist\plain\fs20\cf1\cb1 {\v 2JH0.LH}\line

\par The operation \i seeprimcalls\plain\fs20\cf1\cb1  sets an internal flag to the setting of the boolean argument \i Mode\plain\fs20\cf1\cb1 .  If \i Mode\plain\fs20\cf1\cb1  is \i true\plain\fs20\cf1\cb1 , subsequent execution will monitor the use of all primitive defined expressions, operations and transformers and will print out a message indicating when the named primitive has completed execution.  If \i Mode\plain\fs20\cf1\cb1  is \i false\plain\fs20\cf1\cb1  it turns off the flag that controls monitoring.  \line

\par \pard\sb95 This mode of execution is useful for following the execution flow during debugging.  
\par \pard\keep\sb95 \f1\fs16      seeprimcalls True \line
o\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0118}
{\up $}{\footnote\pard\plain{\up $} seeusercalls}
{\up #}{\footnote\pard\plain{\up #} 1O05MSU}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 seeusercalls\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} seeusercalls;system operation, seeusercalls}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 seeusercalls Mode    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 break\plain\fs20\cf1\cb1 {\v 2V9T7BV}, \uldb debugging\plain\fs20\cf1\cb1 {\v PP0_XH}, \uldb breaklist\plain\fs20\cf1\cb1 {\v 2JH0.LH}\line

\par The operation \i seeusercalls\plain\fs20\cf1\cb1  sets an internal flag to the setting of the boolean argument \i Mod\plain\fs20\cf1\cb1 .  If \i Mod\plain\fs20\cf1\cb1  is \i true\plain\fs20\cf1\cb1 , subsequent execution will monitor the use of all user defined expressions, operations and transformers and will print out a message indicating when definitions are entered and executed.  If \i Mod\plain\fs20\cf1\cb1  is \i false\plain\fs20\cf1\cb1  it turns off the flag that controls monitoring.  \line

\par \pard\sb95 This mode of execution is useful for following the execution flow during debugging.  
\par \pard\keep\sb95 \f1\fs16      seeusercalls True \line
o\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0119}
{\up $}{\footnote\pard\plain{\up $} separator}
{\up #}{\footnote\pard\plain{\up #} 35WS3GL}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 separator\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} constant expression, separator;separator}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul constant expression\plain\fs20\cf1\cb1 {\v constant expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Separator    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 nialroot\plain\fs20\cf1\cb1 {\v K_TBJ1}, \uldb library\plain\fs20\cf1\cb1 {\v 2B9L0GD}, \uldb host\plain\fs20\cf1\cb1 {\v 25VK_53}, \uldb link\plain\fs20\cf1\cb1 {\v QD77W5}\line

\par The expression \i Separator\plain\fs20\cf1\cb1  returns the character used to separate names in the directory structure for the operating system.  For DOS and Windows systems, it is the backslash symbol "\'5c".  For Unix, it is the slash symbol "/".  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:011a}
{\up $}{\footnote\pard\plain{\up $} set}
{\up #}{\footnote\pard\plain{\up #} 1_E789J}
\pard\keepn\sb95 \b\fs25 set\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} set;system operation, set}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 set Sw    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 setdeftrace\plain\fs20\cf1\cb1 {\v 1O7K0X3}, \uldb setformat\plain\fs20\cf1\cb1 {\v 1S5YZUO}, \uldb setinterrupts\plain\fs20\cf1\cb1 {\v 36DY_X6}, \uldb setlogname\plain\fs20\cf1\cb1 {\v H7O7NO}, \uldb setprompt\plain\fs20\cf1\cb1 {\v H31IJ}, \uldb setwidth\plain\fs20\cf1\cb1 {\v 40KE5L}\line

\par The operation \i set\plain\fs20\cf1\cb1  changes internal switches in the Q'Nial interpreter.  The switches are used to control the behaviour of a variety of optional features of Q'Nial.  The argument \i Sw\plain\fs20\cf1\cb1  is a string or phrase in either case.  The result of set is a phrase giving the setting of the switch as it was prior to the execution of the set operation.  The result can be used subsequently to restore the switch to its original value.  The valid phrases and their purposes are tabulated below: 
\par \pard\sb95  \trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 \b Setting  \cell\pard \pard\intbl\sb95 Description of Result  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 diagram  \cell\pard \pard\intbl\sb95 set default display mode to diagram  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 sketch  \cell\pard \pard\intbl\sb95 set default display mode to sketch  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 decor  \cell\pard \pard\intbl\sb95 turn on decoration of atoms and empty arrays  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 nodecor  \cell\pard \pard\intbl\sb95 turn off decoration of atoms and empty arrays  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 trace  \cell\pard \pard\intbl\sb95 turn on tracing of expressions at the top level  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 notrace  \cell\pard \pard\intbl\sb95 turn off tracing of expressions at the top level  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 log  \cell\pard \pard\intbl\sb95 turn on the automatic logging of the session  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx5795\pard\intbl\sb95 nolog  \cell\pard \pard\intbl\sb95 turn off the automatic logging of the session  \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      set "diagram ; \line
     displayinsketchmode IS OPERATION Result \{\-  \line
        A := set "sketch; write picture Result; set A ; \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the above definition, sketch mode is set at the beginning, saving the previous setting in the variable \i A\plain\fs20\cf1\cb1 .  When the definition is ended, the mode is reset to the value in \i A\plain\fs20\cf1\cb1 .  \line

\par The default settings are \i sketch\plain\fs20\cf1\cb1 , \i nodecor\plain\fs20\cf1\cb1 , \i notrace\plain\fs20\cf1\cb1  and \i nolog\plain\fs20\cf1\cb1 .\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:011b}
{\up $}{\footnote\pard\plain{\up $} setdeftrace}
{\up #}{\footnote\pard\plain{\up #} 1O7K0X3}
\pard\keepn\sb95 \b\fs25 setdeftrace\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} setdeftrace;system operation, setdeftrace}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 setdeftrace Defname Mode    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 set\plain\fs20\cf1\cb1 {\v 1_E789J}, \uldb step\plain\fs20\cf1\cb1 {\v 1CMJB0J}, \uldb break\plain\fs20\cf1\cb1 {\v 2V9T7BV}\line

\par The operation \i setdeftrace\plain\fs20\cf1\cb1  changes the trace mode for the user defined expression, operation or transformer definition named by the string or phrase \i Defname\plain\fs20\cf1\cb1 .  \i Mode\plain\fs20\cf1\cb1  is an optional argument.  If it is omitted, the trace mode is toggled.  If \i Mode\plain\fs20\cf1\cb1  is present and has the value 1, it turns trace on.  Otherwise it turns trace off.  The effect when the trace mode is on is to trace the execution of the body of the operation whenever the operation is executed.  \line

\par \pard\sb95 The trace mechanism shows intermediate values in the evaluation of expressions.  \line

\par The operation returns the previous setting.  If the result of \i setdeftrace\plain\fs20\cf1\cb1  is assigned to a variable, the previous setting can be restored later.  
\par \pard\keep\sb95 \f1\fs16      library "average \line
 \line
     setdeftrace "average \line
0 \line
 \line
     average 3 4 5 \line
...trace call to operation \line
...average \line
...the arguments for the opform are \line
...A \line
...A \line
3 4 5 \line
...A \line
3 4 5 \line
...sum A \line
12 \line
...sum A / tally A \line
4. \line
...end of operation call \line
4.\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The tracing facility for expressions does not trace all intermediate computations.  Parentheses around an expression will force its result to be shown during a trace.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:011c}
{\up $}{\footnote\pard\plain{\up $} setformat}
{\up #}{\footnote\pard\plain{\up #} 1S5YZUO}
\pard\keepn\sb95 \b\fs25 setformat\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} picture operation, setformat;setformat}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul picture operation\plain\fs20\cf1\cb1 {\v picture operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 setformat String    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 sketch\plain\fs20\cf1\cb1 {\v .86S0D}\line

\par The operation \i setformat\plain\fs20\cf1\cb1  controls the format used for picturing real numbers.  \i String\plain\fs20\cf1\cb1  is a format specification for real numbers using the conventions for the C library routine printf.  There are three styles of format: 
\par  \trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 \b Control \cell\pard \pard\intbl\sb95 Effect \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 %f  \cell\pard \pard\intbl\sb95 displays a fixed number of places after the decimal point in a fixed size space with no scaling of the number \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 %e  \cell\pard \pard\intbl\sb95 displays the number in scientific notation with an exponent scaling the number to have one digit before the decimal point \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 %g  \cell\pard \pard\intbl\sb95 displays the number in f format if possible but defaults to e format if the number is not within a suitable range \cell\intbl\row
\pard\sb95 \line

\par A code can be inserted between the percent sign and the letter.  Format \i '%15.5f'\plain\fs20\cf1\cb1  uses a field of width 15 to display a number in \i f\plain\fs20\cf1\cb1  format with 5 decimal places.  The first digit is the width of the field.  For \i f\plain\fs20\cf1\cb1  format, the second digit gives the number of places after the decimal while for \i e\plain\fs20\cf1\cb1  and \i g\plain\fs20\cf1\cb1  it indicates the number of significant digits to be displayed.  Either digit can be omitted.  \line

\par Q'Nial requires that the display of a real number includes a decimal point and that the display of an integer does not include a decimal point.  In a \i %g\plain\fs20\cf1\cb1  format, printf does not include a decimal point if the real number matches an integer to the specified precision.  In this case, Q'Nial makes the field one space wider than that specified in order to accommodate the decimal point.  If an \i f\plain\fs20\cf1\cb1  format is not wide enough to accommodate the number, it is widened so that the number is displayed.  \line

\par \pard\sb95 If the result of an \i f\plain\fs20\cf1\cb1  format requires more than \i 40\plain\fs20\cf1\cb1  digits to the left of the decimal point, it is converted to \i e\plain\fs20\cf1\cb1  format.  \line

\par The format \i '%.17g'\plain\fs20\cf1\cb1  is used by operation display in depicting real numbers as this format is accurate enough to reproduce the same number when executed on most systems.  The default format is \i '%g'\plain\fs20\cf1\cb1 .  It works as in C except that a period may be added to distinguish the result from an integer constant.  If the argument to setformat is \i ''\plain\fs20\cf1\cb1  then it resets the formatting to the default value.  
\par \pard\keep\sb95 \f1\fs16      setformat '%.5f' ; \line
     post exp 10. 80. 90. 100. \line
                                  22026.46579 \line
    55406223843935098300000000000000000.00000 \line
    1220403294317840830000000000000000000000. \line
2.688117141816135610000000000000000000000e+43 \line
 \line
     X := 2 2 reshape  9777.985 4464784.692 4070333.511 0.079; \line
 \line
     setformat '%15.7f' ; [pass,sqrt] X \line
+-------------------------------+-------------------------------+ \line
|   9777.9850000 4464784.6920000|     98.8836943    2113.0037132| \line
|4070333.5110000       0.0790000|   2017.5067561       0.2810694| \line
+-------------------------------+-------------------------------+ \line
     setformat  '%15.7g' ; [pass,sqrt] X \line
+---------------------------------+-------------------------------+ \line
|        9777.985         4464785.|       98.88369        2113.004| \line
|        4070334.            0.079|       2017.507       0.2810694| \line
+---------------------------------+-------------------------------+ \line
     setformat '%15.7e' ; [pass,sqrt] X \line
+-------------------------------+-------------------------------+ \line
|  9.7779850e+03   4.4647847e+06|  9.8883694e+01   2.1130037e+03| \line
|  4.0703335e+06   7.9000000e-02|  2.0175068e+03   2.8106939e-01| \line
+-------------------------------+-------------------------------+\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:011d}
{\up $}{\footnote\pard\plain{\up $} setinterrupts}
{\up #}{\footnote\pard\plain{\up #} 36DY_X6}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 setinterrupts\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} setinterrupts;system operation, setinterrupts}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 setinterrupts Boolean    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 recover\plain\fs20\cf1\cb1 {\v 7L0TNT}, \uldb toplevel\plain\fs20\cf1\cb1 {\v 3A08M4I}\line

\par The operation \i setinterrupts\plain\fs20\cf1\cb1  permits or prevents the interruption of computation by the use of \i <Ctrl C>\plain\fs20\cf1\cb1 .  If the argument is \i true\plain\fs20\cf1\cb1 , interrupts are permitted.  If it is \i false\plain\fs20\cf1\cb1 , they are blocked.  The default value is \i true\plain\fs20\cf1\cb1 .  \line

\par \i Setinterrupts\plain\fs20\cf1\cb1  is used in a closed application to prevent the user from interfering with a computation in process.  This may be critical if a file is being updated in a sequence of steps, which must all be completed for the data base to remain consistent.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:011e}
{\up $}{\footnote\pard\plain{\up $} setlogname}
{\up #}{\footnote\pard\plain{\up #} H7O7NO}
\pard\keepn\sb95 \b\fs25 setlogname\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} setlogname;system operation, setlogname}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 setlogname Filename    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 set\plain\fs20\cf1\cb1 {\v 1_E789J}\line

\par The operation \i setlogname\plain\fs20\cf1\cb1  is used to set the name of the host file in which a log of the session is recorded.  The current log file is closed and a new one opened.  The argument \i Filename\plain\fs20\cf1\cb1  must be a phrase or a string.  
\par \pard\keep\sb95 \f1\fs16      setlogname "dec17pm\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The main purpose of \i setlogname\plain\fs20\cf1\cb1  is to capture the history of part of a session in a particular file for later use.  The log file can produce documentation, for example.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:011f}
{\up $}{\footnote\pard\plain{\up $} setprofile}
{\up #}{\footnote\pard\plain{\up #} H2UBBE}
\pard\keepn\sb95 \b\fs25 setprofile\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} profiling operation, setprofile;setprofile}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul profiling operation\plain\fs20\cf1\cb1 {\v profiling operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 setprofile A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 profile\plain\fs20\cf1\cb1 {\v FHUFEL}, \uldb clearprofile\plain\fs20\cf1\cb1 {\v 90MFAZ}, \uldb profiletable\plain\fs20\cf1\cb1 {\v _8MA7D}, \uldb profiletree\plain\fs20\cf1\cb1 {\v H3PT41}, \uldb profiling\plain\fs20\cf1\cb1 {\v 1_IJW3H}\line

\par The operation \i setprofile\plain\fs20\cf1\cb1  is used to turn on or turn off the gathering of profiling statistics.  The calls must be made at the same scope level in order for profiling to work correctly.  This can either be at the top level, or within the body of some expression or operation.  \line

\par The argument is a boolean value: \i true\plain\fs20\cf1\cb1  starts the profiling process and \i false\plain\fs20\cf1\cb1  stops it.  Profiling can be turned on and off several times within one profiling session.  \line

\par \pard\sb95 A detailed explanation of the profiling mechanism is given in the help entry on \i profiling\plain\fs20\cf1\cb1 .  \line

\par Example of use: 
\par \pard\keep\sb95 \f1\fs16      setprofile True \line
o\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0120}
{\up $}{\footnote\pard\plain{\up $} setprompt}
{\up #}{\footnote\pard\plain{\up #} H31IJ}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 setprompt\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} setprompt;system operation, setprompt}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 setprompt S    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 set\plain\fs20\cf1\cb1 {\v 1_E789J}\line

\par The operation \i setprompt\plain\fs20\cf1\cb1  sets the Q'Nial prompt to be the string or phrase S.  The default prompt is the string with 5 blank spaces.  The maximum size of a prompt is forty characters.  \i Setprompt\plain\fs20\cf1\cb1  provides the facility to set a visible prompt which can be distinguished from prompts issued by other software.  
\par \pard\keep\sb95 \f1\fs16      setprompt 'qnial>' \line
qnial> \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0121}
{\up $}{\footnote\pard\plain{\up $} settrigger}
{\up #}{\footnote\pard\plain{\up #} 16TEBGX}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 settrigger\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} settrigger;system operation, settrigger}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 settrigger Switch    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 quiet_fault\plain\fs20\cf1\cb1 {\v 1EEKEB1}, \uldb fault\plain\fs20\cf1\cb1 {\v TLJI2Z}, \uldb fault triggering\plain\fs20\cf1\cb1 {\v 2JAK0C0}\line

\par The operation \i settrigger\plain\fs20\cf1\cb1  sets the action taken when a fault is generated in an operation.  If \i Switch\plain\fs20\cf1\cb1  is \i true\plain\fs20\cf1\cb1 , whenever a fault is generated, computation is interrupted, a message is displayed indicating the fault that has occurred and the expression where it occurred. Then the \i Callstack\plain\fs20\cf1\cb1  is displayed and a loop is entered that allows you to explore the cause of the fault.  If you press \i Return\plain\fs20\cf1\cb1  at the prompt, control is sent to the top level loop.\line

\par \pard\sb95 If \i Switch\plain\fs20\cf1\cb1  is \i false\plain\fs20\cf1\cb1 , fault triggering is turned off.\line

\par The default setting at the start of a session is fault triggering on.  The triggering of an interrupt by fault generation can be turned off for the session by using the -s command line option in console versions or by setting preferences in the GUI version.  
\par \pard\keep\sb95 \f1\fs16      settrigger o \line
l\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0122}
{\up $}{\footnote\pard\plain{\up $} setwidth}
{\up #}{\footnote\pard\plain{\up #} 40KE5L}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 setwidth\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} setwidth;system operation, setwidth}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 setwidth N    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 set\plain\fs20\cf1\cb1 {\v 1_E789J}, \uldb writescreen\plain\fs20\cf1\cb1 {\v 9TD.YB}\line

\par The operation \i setwidth\plain\fs20\cf1\cb1  sets the width of the display and log lines.  The argument is an integer \i N\plain\fs20\cf1\cb1 .  The result is the previous setting.  The default setting is 80.  \line

\par \i Setwidth\plain\fs20\cf1\cb1  is useful in controlling the format of display on output saved for documentation purposes.  For example, a setting of 130 allows wide Nial diagrams to be printed on a line printer even though they may not display properly on the screen.  Narrower settings are convenient for use in reports.  
\par \pard\keep\sb95 \f1\fs16      setwidth 50 \line
80\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0123}
{\up $}{\footnote\pard\plain{\up $} shape}
{\up #}{\footnote\pard\plain{\up #} TYQ56K}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 shape\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} measurement operation, shape;shape}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 shape A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 tally\plain\fs20\cf1\cb1 {\v 5JEH.UN}, \uldb valence\plain\fs20\cf1\cb1 {\v MQJNXM}, \uldb reshape\plain\fs20\cf1\cb1 {\v 3I4D_MA}\line

\par The operation \i shape\plain\fs20\cf1\cb1  returns an array that describes the rectangular structure of array \i A\plain\fs20\cf1\cb1 .  Every array has a shape.  For a single, including atoms, the shape is the empty list \i Null\plain\fs20\cf1\cb1 .  For a list, it is a solitary holding the integer giving the length of the list.  For a table or higher valence array, it is a list of integers giving the extent (number of items) along each axis.  
\par \pard\keep\sb95 \f1\fs16      shape 5 6 7 \line
3 \line
     A := 2 3 reshape 4 5 6 7 8 9; \line
     shape A \line
2 3 \line
     B := 2 3 4 5 0 2 reshape 2 ; \line
     shape B \line
2 3 4 5 0 2\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The operation \i shape\plain\fs20\cf1\cb1  always returns a list whereas \i tally\plain\fs20\cf1\cb1  returns an integer.  An empty array such as \i B\plain\fs20\cf1\cb1  is one with a zero in its shape.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    product shape A = tally A \line
   tally shape A = valence A \line
   list shape A = shape A \line
   shape A reshape list A = A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0124}
{\up $}{\footnote\pard\plain{\up $} simple}
{\up #}{\footnote\pard\plain{\up #} 1KHVNG6}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 simple\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} simple;structure testing operation, simple}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul structure testing operation\plain\fs20\cf1\cb1 {\v structure testing operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 simple A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 atomic\plain\fs20\cf1\cb1 {\v GJLKWO}, \uldb twig\plain\fs20\cf1\cb1 {\v 25VWDUQ}\line

\par The operation \i simple\plain\fs20\cf1\cb1  tests whether or not an array has all atomic items or is an empty array.  The result is \i true\plain\fs20\cf1\cb1  if the array is simple and \i false\plain\fs20\cf1\cb1  if it is not.  
\par \pard\keep\sb95 \f1\fs16      (simple 2 3 4) (simple "abc) \line
ll \line
 \line
     simple Null \line
l \line
 \line
     simple (2 3) (4 5 6) \line
o \line
 \line
     (simple tell 2 3) \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first two examples show that a list of integers, an atom and the empty list \i Null\plain\fs20\cf1\cb1  are all simple arrays.  The next two examples show that a pair of lists and the result of a \i tell\plain\fs20\cf1\cb1  are not simple.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      simple IS OPERATION A (EACH single A = A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    simple A = and EACH atomic A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0125}
{\up $}{\footnote\pard\plain{\up $} sin}
{\up #}{\footnote\pard\plain{\up #} 1_E78_D}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 sin\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} scientific operation, sin;sin}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 sin A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 sinh\plain\fs20\cf1\cb1 {\v 1CMJ7CB}, \uldb cos\plain\fs20\cf1\cb1 {\v 1_E6SCI}, \uldb pi\plain\fs20\cf1\cb1 {\v RJ2SIX}\line

\par The operation \i sin\plain\fs20\cf1\cb1  implements the sine function of mathematics.  It produces the following results when applied to atoms of the six types: 
\par 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 sine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 sine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 sine of angle A given in radians \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?sin \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?sin \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      sin  l  -1  0.5  `a  "abc  ??error \line
0.841 -0.841 0.479 ?sin ?sin ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    sin opposite A = opposite sin A \line
   (sin A power 2) + (cos A power 2) = 1.0   (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0126}
{\up $}{\footnote\pard\plain{\up $} single}
{\up #}{\footnote\pard\plain{\up #} 1KHWEG6}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 single\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} construction operation, single;single}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul construction operation\plain\fs20\cf1\cb1 {\v construction operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 single A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 solitary\plain\fs20\cf1\cb1 {\v 2BGSG4Y}, \uldb null\plain\fs20\cf1\cb1 {\v 40XD_Q}, \uldb atomic\plain\fs20\cf1\cb1 {\v GJLKWO}, \uldb reshape\plain\fs20\cf1\cb1 {\v 3I4D_MA}\line

\par The operation \i single\plain\fs20\cf1\cb1  returns an array with no axes holding \i A\plain\fs20\cf1\cb1  as its only item.  The result is an array with shape \i Null\plain\fs20\cf1\cb1  and is said to be a \b single\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      single 2 3 \line
o---+ \line
|2 3| \line
+---+ \line
     3 = single 3 \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example illustrates that a single of a pair contains the pair as its item.  In both \i diagram\plain\fs20\cf1\cb1  and \i sketch\plain\fs20\cf1\cb1  modes, the display of a nonatomic single is decorated with an \i o\plain\fs20\cf1\cb1  in the upper left corner.  The second example illustrates that the single of an atom is the atom itself.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      single IS OPERATION A \{\- Null reshape solitary A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    first single A = A \line
   shape single A = Null \line
   atomic A = single A equal A \line
   EACH f single A =  single f A \line
   A EACHLEFT f B = A EACHBOTH f single B \line
   A EACHRIGHT f B = single A EACHBOTH f B \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0127}
{\up $}{\footnote\pard\plain{\up $} sinh}
{\up #}{\footnote\pard\plain{\up #} 1CMJ7CB}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 sinh\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} scientific operation, sinh;sinh}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 sinh A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 cosh\plain\fs20\cf1\cb1 {\v 1CM0_HB}, \uldb tanh\plain\fs20\cf1\cb1 {\v 1CMJZCB}, \uldb sin\plain\fs20\cf1\cb1 {\v 1_E78_D}\line

\par The operation \i sinh\plain\fs20\cf1\cb1  implements the hyperbolic sine function of mathematics.  It produces the following results when applied to atoms of the six types: 
\par 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 hyperbolic sine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 hyperbolic sine of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 hyperbolic sine of angle A given in radians \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?sinh \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?sinh \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      sinh  l  -1  0.5  `a  "abc  ??error \line
1.1752 -1.1752 0.521095 ?sinh ?sinh ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    sinh opposite A = opposite sinh A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0128}
{\up $}{\footnote\pard\plain{\up $} sketch}
{\up #}{\footnote\pard\plain{\up #} .86S0D}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 sketch\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} picture operation, sketch;sketch}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul picture operation\plain\fs20\cf1\cb1 {\v picture operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 sketch A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 picture\plain\fs20\cf1\cb1 {\v __8RKL}, \uldb diagram\plain\fs20\cf1\cb1 {\v G5WG1G}, \uldb paste\plain\fs20\cf1\cb1 {\v TVJG0K}, \uldb positions\plain\fs20\cf1\cb1 {\v 1AGU44_}, \uldb display\plain\fs20\cf1\cb1 {\v GH5A1S}, \uldb set\plain\fs20\cf1\cb1 {\v 1_E789J}\line

\par The operation \i sketch\plain\fs20\cf1\cb1  computes a character table that gives the picture of the array \i A\plain\fs20\cf1\cb1  as it is displayed in \i sketch\plain\fs20\cf1\cb1  mode.  The details of the display of atoms and empty arrays is affected by the setting of the \i decor/nodecor\plain\fs20\cf1\cb1  switch.  
\par \pard\keep\sb95 \f1\fs16      sketch tell 1 3\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The sketch of an array provides an abbreviated display that often serves as an adequate output format for data.  The entry for \i picture\plain\fs20\cf1\cb1  has a more complete description of the picturing mechanism.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      sketch IS OPERATION A \{\-  \line
        Old_setting := set "sketch;  \line
        Result := picture A;  \line
        set Old_setting;  \line
        Result \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    sketch sketch A = sketch A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0129}
{\up $}{\footnote\pard\plain{\up $} solitary}
{\up #}{\footnote\pard\plain{\up #} 2BGSG4Y}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 solitary\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} construction operation, solitary;solitary}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul construction operation\plain\fs20\cf1\cb1 {\v construction operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 solitary A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 single\plain\fs20\cf1\cb1 {\v 1KHWEG6}, \uldb list\plain\fs20\cf1\cb1 {\v 40V8DY}, \uldb shape\plain\fs20\cf1\cb1 {\v TYQ56K}, \uldb hitch\plain\fs20\cf1\cb1 {\v TNRGTN}, \uldb link\plain\fs20\cf1\cb1 {\v QD77W5}\line

\par The operation \i solitary\plain\fs20\cf1\cb1  returns a list of length one holding \i A\plain\fs20\cf1\cb1  as its only item.  The result is said to be a \b solitary\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      solitary 2 3 \line
+---+ \line
|2 3| \line
+---+ \line
 \line
     set "diagram; solitary 3 \line
+-+ \line
|3| \line
+-+ \line
 \line
     set "sketch; solitary 3 \line
3\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example illustrates that a solitary of a pair contains the pair as its item.  The second example illustrates that the solitary of an atom is different from the atom itself.  However, as the third example shows, in sketch mode, the display of the solitary of an atom is not framed and hence may have the same display as the atom.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      solitary IS OPERATION A \{\- A hitch Null \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    first solitary A = A \line
   solitary A = A hitch Null \line
   solitary A = Null append A \line
   solitary A = list solitary A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:012a}
{\up $}{\footnote\pard\plain{\up $} solve}
{\up #}{\footnote\pard\plain{\up #} 5JDV_40}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 solve\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} linear algebra operation, solve;solve}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul linear algebra operation\plain\fs20\cf1\cb1 {\v linear algebra operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A solve B   solve A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 inverse\plain\fs20\cf1\cb1 {\v W4WJKP}, \uldb innerproduct\plain\fs20\cf1\cb1 {\v QPKGRK}, \uldb inner\plain\fs20\cf1\cb1 {\v TOWAVX}, \uldb outer\plain\fs20\cf1\cb1 {\v TV3GVX}\line

\par The operation \i solve\plain\fs20\cf1\cb1  solves the set of linear equations described by the equation \i A x = B\plain\fs20\cf1\cb1   in matrix notation, where \i A\plain\fs20\cf1\cb1  is an \i N\plain\fs20\cf1\cb1  by \i N\plain\fs20\cf1\cb1  matrix and \i B\plain\fs20\cf1\cb1  is a vector of length \i N\plain\fs20\cf1\cb1 .  Provided that the matrix \i A\plain\fs20\cf1\cb1  is not singular, the result is the vector of length \i N\plain\fs20\cf1\cb1  satisfying the equation (within roundoff error).  \line

\par \pard\sb95 In the computation, a numerical estimate is made of the singularity of \i A\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  cannot be shown to be non-singular with a safe margin, the result of the operation is the fault \i ?singular\plain\fs20\cf1\cb1 .  \line

\par The operation is extended to solve more than one right hand side.  If \i B\plain\fs20\cf1\cb1  is an \i N\plain\fs20\cf1\cb1  by \i M\plain\fs20\cf1\cb1  matrix, columns of \i N\plain\fs20\cf1\cb1  are viewed as right hand sides and the result is an \i N\plain\fs20\cf1\cb1  by \i M\plain\fs20\cf1\cb1  matrix with each column being the solution of the corresponding column.  
\par \pard\keep\sb95 \f1\fs16      seed .314159; \line
     A := ceiling (100. * (3 3 reshape random 9)) \line
 8 75 24 \line
63 31 99 \line
20 95 48 \line
 \line
     B := ceiling (10. *  random 3) \line
4 9 5 \line
 \line
     X := solve A B \line
0.787745 0.111836 -0.445402 \line
 \line
     A innerproduct X \line
4. 9. 5. \line
 \line
     I := 0 1 2 OUTER = 0 1 2 * 1.0 \line
1. 0. 0. \line
0. 1. 0. \line
0. 0. 1. \line
 \line
     A solve I \line
 0.614865   0.102516 -0.518872 \line
0.0810811 0.00745573 -0.055918 \line
-0.416667 -0.0574713  0.347701 \line
 \line
     inverse A \line
 0.614865   0.102516 -0.518872 \line
0.0810811 0.00745573 -0.055918 \line
-0.416667 -0.0574713  0.347701 \line
 \line
     A solve I = inverse A \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The final example shows that if the right hand side is set to the unit matrix of size \i N\plain\fs20\cf1\cb1 , solving it with \i A\plain\fs20\cf1\cb1  is equivalent to computing the inverse.  \line

\par For large examples, it is always faster and more accurate to solve a system of equations directly using \i A solve B\plain\fs20\cf1\cb1  than to compute the inverse and do the inner product operation \i inverse A innerproduct B\plain\fs20\cf1\cb1  .  The first form does about half as many arithmetic steps.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:012b}
{\up $}{\footnote\pard\plain{\up $} sort}
{\up #}{\footnote\pard\plain{\up #} 1CMJ_GN}
\pard\keepn\sb95 \b\fs25 sort\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} sort;sorting transformer, sort}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul sorting transformer\plain\fs20\cf1\cb1 {\v sorting transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 SORT f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 grade\plain\fs20\cf1\cb1 {\v 3HH5325}, \uldb sortup\plain\fs20\cf1\cb1 {\v ..CSLL}\line

\par The transformer \i SORT\plain\fs20\cf1\cb1  returns the list of items of array \i A\plain\fs20\cf1\cb1  ordered according to the comparator \i f\plain\fs20\cf1\cb1 .  The comparator \i f\plain\fs20\cf1\cb1  is the operation to be used in comparisons.  The operations \i <=\plain\fs20\cf1\cb1  and \i >=\plain\fs20\cf1\cb1  are the usual comparators.  If \i >=\plain\fs20\cf1\cb1  is the comparator in \i SORT\plain\fs20\cf1\cb1 , the items are returned in decreasing order.  If \i <=\plain\fs20\cf1\cb1  is the comparator in \i SORT\plain\fs20\cf1\cb1 , the items are returned in increasing order.  
\par \pard\keep\sb95 \f1\fs16      SORT >= (count 10) \line
10 9 8 7 6 5 4 3 2 1 \line
 \line
     SORT <=("some "words "not "in "order) \line
in not order some words\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      SORT IS TRANSFORMER f OPERATION A \{\- GRADE f A choose A \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape SORT f A = shape A \line
   N an integer ==> SORT <= tell N = tell N \line
   SORT f (SORT f A) = SORT f A \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The sort is done internally using either a radix sort (on integers) or a list merge sort algorithm from Knuth's Vol 3 Searching and Sorting, Algorithm 5.2.5-L, improved according to exercise 12.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:012c}
{\up $}{\footnote\pard\plain{\up $} sortup}
{\up #}{\footnote\pard\plain{\up #} ..CSLL}
\pard\keepn\sb95 \b\fs25 sortup\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} sorting operation, sortup;sortup}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul sorting operation\plain\fs20\cf1\cb1 {\v sorting operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 sortup A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 gradeup\plain\fs20\cf1\cb1 {\v 32WH0Y0}, \uldb sort\plain\fs20\cf1\cb1 {\v 1CMJ_GN}, \uldb up\plain\fs20\cf1\cb1 {\v RJ2SO4}\line

\par The operation \i sortup\plain\fs20\cf1\cb1  returns the list of items of array \i A\plain\fs20\cf1\cb1  ordered according to the lexicographical ordering comparator \i up\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      sortup 3 7 5 4 9 8 2 1 6 10 \line
1 2 3 4 5 6 7 8 9 10 \line
 \line
     sortup ("some "words "not "in "order) \line
in not order some words\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      sortup IS SORT up\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    gradeup A choose A = sortup A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:012d}
{\up $}{\footnote\pard\plain{\up $} split}
{\up #}{\footnote\pard\plain{\up #} 5JDW.RI}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 split\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} nesting restructuring operation, split;split}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nesting restructuring operation\plain\fs20\cf1\cb1 {\v nesting restructuring operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 I split A   split I A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 blend\plain\fs20\cf1\cb1 {\v THU94J}, \uldb raise\plain\fs20\cf1\cb1 {\v TXJ_9K}, \uldb rows\plain\fs20\cf1\cb1 {\v 1CMI_LM}, \uldb cols\plain\fs20\cf1\cb1 {\v QCY_U_}, \uldb rank\plain\fs20\cf1\cb1 {\v QD.ZW5}\line

\par The operation \i split\plain\fs20\cf1\cb1  restructures array \i A\plain\fs20\cf1\cb1  by partitioning the items of \i A\plain\fs20\cf1\cb1  into arrays using the given axis numbers in \i I\plain\fs20\cf1\cb1  to determine the partition.  The axis numbers in \i I\plain\fs20\cf1\cb1  indicate the axes that are to become axes of the items.  The remaining axes are axes of the result.  The argument \i I\plain\fs20\cf1\cb1  must be an array of integers in \i tell valence A\plain\fs20\cf1\cb1  without duplicates.  
\par \pard\keep\sb95 \f1\fs16      A := 2 3 reshape count 6 \line
1 2 3 \line
4 5 6 \line
 \line
     1 split A \line
+-----+-----+ \line
|1 2 3|4 5 6| \line
+-----+-----+ \line
     B := 2 3 4 reshape count 24 \line
1  2  3  4   13 14 15 16 \line
5  6  7  8   17 18 19 20 \line
9 10 11 12   21 22 23 24 \line
     2 split B \line
+-----------+-----------+-----------+ \line
|1 2 3 4    |5 6 7 8    |9 10 11 12 | \line
+-----------+-----------+-----------+ \line
|13 14 15 16|17 18 19 20|21 22 23 24| \line
+-----------+-----------+-----------+ \line
     1 split B \line
+--------+--------+--------+--------+ \line
|1 5 9   |2 6 10  |3 7 11  |4 8 12  | \line
+--------+--------+--------+--------+ \line
|13 17 21|14 18 22|15 19 23|16 20 24| \line
+--------+--------+--------+--------+ \line
     1 2 split B \line
+----------+-----------+ \line
|1  2  3  4|13 14 15 16| \line
|5  6  7  8|17 18 19 20| \line
|9 10 11 12|21 22 23 24| \line
+----------+-----------+ \line
     1 0 split B \line
+----+-----+-----+-----+ \line
|1 13| 2 14| 3 15| 4 16| \line
|5 17| 6 18| 7 19| 8 20| \line
|9 21|10 22|11 23|12 24| \line
+----+-----+-----+-----+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows that splitting along the last axis of an array is equivalent to taking its \i rows\plain\fs20\cf1\cb1 .  The second example shows that the \i split\plain\fs20\cf1\cb1  of the middle axis of a trivalent array is a table, with its shape given by the first and third axes.  The last two examples illustrate two axes being "pushed down".  The result is a list with tables as items.  The order of the axes in the item is determined by the order of the items in \i I\plain\fs20\cf1\cb1 .  \line

\par The operation \i blend\plain\fs20\cf1\cb1  uses the same control argument to undo the effect of a \i split\plain\fs20\cf1\cb1 .  A common requirement is to partition an array along its axes, apply some operation \i f\plain\fs20\cf1\cb1  to the resulting items and to rebuild the result into its original form.  Partition is used to do this without computing all the intermediate structures.  \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      split IS OPERATION I A \{\- \line
        IF empty A THEN \line
           fault '?empty right arg in split' \line
        ELSEIF not(I allin axes A and diverse I) THEN \line
           fault '?invalid left arg in split' \line
        ELSE \line
          J gets axes A except link I; \line
          tally J raise (J link I fuse A) \line
        ENDIF \'7d\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    valence A ~= 0 ==> valence A - 1 split A = rows A \line
   diverse I and (I allin tell valence A) ==> shape first (I split A) = list (I choose shape A) \line
   diverse I and (I allin tell valence A) ==> shape (I split A) = shape A except (I choose shape A) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:012e}
{\up $}{\footnote\pard\plain{\up $} sqrt}
{\up #}{\footnote\pard\plain{\up #} 47GO_O8}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 sqrt\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} scientific operation, sqrt;sqrt}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 sqrt A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 exp\plain\fs20\cf1\cb1 {\v 1_E6ULF}, \uldb ln\plain\fs20\cf1\cb1 {\v RJ2SF2}, \uldb log\plain\fs20\cf1\cb1 {\v 1_E71C_}, \uldb abs\plain\fs20\cf1\cb1 {\v 1_E6Q6I}, \uldb power\plain\fs20\cf1\cb1 {\v TVXJVX}\line

\par The operation \i sqrt\plain\fs20\cf1\cb1  implements the square root function of mathematics.  It produces the following results when applied to atoms of the six types: 
\par 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 square root of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 square root of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 square root of A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?sqrt \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?sqrt \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 \line

\par \b Example\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      sqrt  o  1  0.5  `a  "abc  ??error \line
0. 1. 0.707107 ?sqrt ?sqrt ?error \line
 \line
     sqrt  4.0 \line
2.\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      sqrt IS OPERATION A (A power .5) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    sqrt A power 2 = A (within roundoff error) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:012f}
{\up $}{\footnote\pard\plain{\up $} standard definitions}
{\up #}{\footnote\pard\plain{\up #} AXO3EN}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 standard definitions\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, standard definitions;standard definitions}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 clear workspace\plain\fs20\cf1\cb1 {\v 2R04_UA}\line

\par Q'Nial has a large set of predefined expressions, operations and transformers. Most of these are implemented directly in the interpreter. However, there are a number of them which are defined as standard definitions in the file \i defs.ndf\plain\fs20\cf1\cb1 . This file is placed in the \i initial\plain\fs20\cf1\cb1  subdirectory of nialroot that is used in initializing Q'Nial.  The definitions are embedded in the interpreter as a default set of standard definitions in case the interpreter cannot find the file.\line

\par \pard\sb95 When Q'Nial is invoked and the clear workspace is not found, the workspace is initialized with the standard definitions from \i defs.ndf\plain\fs20\cf1\cb1 . All definitions included in this stage cannot be modified or erased and the operation \i see\plain\fs20\cf1\cb1  does not display their text. A user can create their own initial set of definitions by editing \i defs.ndf\plain\fs20\cf1\cb1  to add or remove definitions.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0130}
{\up $}{\footnote\pard\plain{\up $} status}
{\up #}{\footnote\pard\plain{\up #} .A2SLO}
\pard\keepn\sb95 \b\fs25 status\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} status;system expression, status}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Status    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 filestatus\plain\fs20\cf1\cb1 {\v 0CG1FT}\line

\par The expression \i status\plain\fs20\cf1\cb1  provides seven integers indicating the use of memory by Q'Nial.  In order of display, the items are as follows: 
\par  \trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 \b Index \cell\pard \pard\intbl\sb95 Quantity  \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 0 \cell\pard \pard\intbl\sb95 Number of free words in the workspace \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 1 \cell\pard \pard\intbl\sb95 Number of words in the largest free block \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 2 \cell\pard \pard\intbl\sb95 Number of free blocks \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 3 \cell\pard \pard\intbl\sb95 Total number of words in workspace \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 4 \cell\pard \pard\intbl\sb95 Stack size in words \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 5 \cell\pard \pard\intbl\sb95 Atom table size in words \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx995\cellx5795\pard\intbl\sb95 6 \cell\pard \pard\intbl\sb95 Internal buffer size \cell\intbl\row
\pard\sb95 \line

\par The first entry is an indication of how full the workspace is when compared with the fourth entry.  A word can contain an integer, a reference to an array item, or 4 characters.  The second entry gives an upper limit to the number of integers that can be in a largest size array.  The third item is a measure of the fragmentation of memory.  The number of free words divided by the number of free blocks gives the average block size.  The fourth item gives the current size of the workspace.  It can grow provided the system has space available.  The remaining entries give the sizes of internal areas that can grow as necessary.\line

\par \pard\sb95 The starting workspace size can be specified as a parameter to the \i nial\plain\fs20\cf1\cb1  command that starts a session in console versions or in a dialog box in a GUI version.  The workspace and the other areas can grow in size provided there is sufficient space and workspace growth is allowed (the default).\line

\par In Q'Nial for Windows the status entries can be displayed in a pop up window by selecting the Status field in the Workspace menu.
\par \pard\keep\sb95 \f1\fs16      status \line
64198 63828 5 100000 4000 6000 1000\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0131}
{\up $}{\footnote\pard\plain{\up $} step}
{\up #}{\footnote\pard\plain{\up #} 1CMJB0J}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 step\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} debugging command, step;step}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul debugging command\plain\fs20\cf1\cb1 {\v debugging command}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 step    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 debugging\plain\fs20\cf1\cb1 {\v PP0_XH}, \uldb break\plain\fs20\cf1\cb1 {\v 2V9T7BV}, \uldb resume\plain\fs20\cf1\cb1 {\v 1JE1SH6}, \uldb next\plain\fs20\cf1\cb1 {\v 40X4IY}, \uldb toend\plain\fs20\cf1\cb1 {\v 7QL9H0}, \uldb stepin\plain\fs20\cf1\cb1 {\v YJBNWZ}\line

\par The command \i step\plain\fs20\cf1\cb1  is used in debugging a definition that has been suspended using Break or <Ctrl B>.  The effect of \i step\plain\fs20\cf1\cb1  is to execute the next expression in an expression sequence and to suspend execution again.  If the current expression involves a call on a defined operation or expression, execution is suspended on the first expression in its body.  If the current expression is the last one in the expression sequence where the break began, the effect is the same as using \i resume\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 The related command \i stepv\plain\fs20\cf1\cb1  displays the result of the expression executed on a step before displaying the next expression.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0132}
{\up $}{\footnote\pard\plain{\up $} stepin}
{\up #}{\footnote\pard\plain{\up #} YJBNWZ}
\pard\keepn\sb95 \b\fs25 stepin\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} debugging command, stepin;stepin}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul debugging command\plain\fs20\cf1\cb1 {\v debugging command}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 stepin    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 debugging\plain\fs20\cf1\cb1 {\v PP0_XH}, \uldb break\plain\fs20\cf1\cb1 {\v 2V9T7BV}, \uldb resume\plain\fs20\cf1\cb1 {\v 1JE1SH6}, \uldb next\plain\fs20\cf1\cb1 {\v 40X4IY}, \uldb toend\plain\fs20\cf1\cb1 {\v 7QL9H0}, \uldb step\plain\fs20\cf1\cb1 {\v 1CMJB0J}\line

\par The command \i stepin\plain\fs20\cf1\cb1  is used in debugging a definition that has been suspended using Break or <Ctrl B>.  The effect of \i stepin\plain\fs20\cf1\cb1  is to execute the next expression in an expression sequence tracing the intermediate values generated and to suspend execution again.  If the current expression involves a call on a defined operation or expression, execution is suspended on the first expression in its body.  If the current expression is the last one in the expression sequence where the break began, the effect is the same as using \i resume\plain\fs20\cf1\cb1 .  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0133}
{\up $}{\footnote\pard\plain{\up $} strand notation}
{\up #}{\footnote\pard\plain{\up #} 1N9SB86}
\pard\keepn\sb95 \b\fs25 strand notation\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} strand notation;syntax, strand notation}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 bracket-comma notation\plain\fs20\cf1\cb1 {\v 1N.QYRT}\line

\par A primary-sequence of length two or greater is called a \b strand\plain\fs20\cf1\cb1 .  The value of a strand is a list of values.  Each item of the list has the value of the primary-expression in the corresponding position in the primary-sequence.  \line

\par The elements of the primary-sequence can be constants, parenthesized expressions or lists in bracket-comma notation.
\par \pard\keep\sb95 \f1\fs16      8 9 10 \line
8 9 10 \line
 \line
     8 (3 4 5) 18 \line
+-+-----+--+ \line
|8|3 4 5|18| \line
+-+-----+--+ \line
 \line
     8 'abc' "apple \line
+-+---+-----+ \line
|8|abc|apple| \line
+-+---+-----+ \line
 \line
     6 [7,8,9] 10 \line
+-+-----+--+ \line
|6|7 8 9|10| \line
+-+-----+--+\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0134}
{\up $}{\footnote\pard\plain{\up $} string}
{\up #}{\footnote\pard\plain{\up #} .ACHEC}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 string\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} conversion operation, string;string}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 string A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 phrase\plain\fs20\cf1\cb1 {\v 4.B5_UK}, \uldb fault\plain\fs20\cf1\cb1 {\v TLJI2Z}, \uldb isstring\plain\fs20\cf1\cb1 {\v HCQ47O}, \uldb char\plain\fs20\cf1\cb1 {\v 40M72W}, \uldb charrep\plain\fs20\cf1\cb1 {\v 2W9HDTD}, \uldb tolower\plain\fs20\cf1\cb1 {\v 12BMVK4}, \uldb toupper\plain\fs20\cf1\cb1 {\v 12KNOK4}\line

\par The operation \i string\plain\fs20\cf1\cb1  is used to convert an atom to a string that corresponds to the display of the atom.  The form of the string is not sensitive to the setting of the \i decor/nodecor\plain\fs20\cf1\cb1  display mode, returning the sketch of the undecorated atom.  The string of a string is the string itself.  
\par \pard\keep\sb95 \f1\fs16      set "diagram ; string "abc \line
+-+-+-+ \line
|a|b|c| \line
+-+-+-+ \line
     string 'abc' \line
+-+-+-+ \line
|a|b|c| \line
+-+-+-+ \line
 \line
     string 2.35 \line
+-+-+-+-+ \line
|2|.|3|5| \line
+-+-+-+-+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The string of a phrase is the string of the message in the phrase.  Thus, \i string\plain\fs20\cf1\cb1  is the left inverse of \i phrase\plain\fs20\cf1\cb1 .  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    isstring S ==> string S = S \line
   isstring S ==> string phrase S = S \line
   list string S = string S \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0135}
{\up $}{\footnote\pard\plain{\up $} string_split}
{\up #}{\footnote\pard\plain{\up #} 52CEJJX}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 string_split\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} string manipulation operation, string_split;string_split}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul string manipulation operation\plain\fs20\cf1\cb1 {\v string manipulation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 string_split C S [N]    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 cut\plain\fs20\cf1\cb1 {\v 1_E6SIJ}, \uldb cutall\plain\fs20\cf1\cb1 {\v 3ZO7_NR}, \uldb regexp\plain\fs20\cf1\cb1 {\v 1JDPCSA}\line

\par The operation \i string_split\plain\fs20\cf1\cb1  is used to break string \i S\plain\fs20\cf1\cb1  into substrings using the characters in \i C\plain\fs20\cf1\cb1  as places to break the string. If two characters in \i C\plain\fs20\cf1\cb1  are adjacent in \i S\plain\fs20\cf1\cb1  then an empty string is placed in the result. The optional third argument is an integer which limits the number of substrings returned.
\par \pard\keep\sb95 \f1\fs16      string_split ' .' 'The quick brown fox.' \line
+---+-----+-----+---+ \line
|The|quick|brown|fox| \line
+---+-----+-----+---+ \line
 \line
     string_split ' .,' 'The quick, brown fox.' \line
+---+-----++-----+---+ \line
|The|quick||brown|fox| \line
+---+-----++-----+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows a string being broken on spaces and the period. The second is also broken on a comma and results in an empty string as one of the items of the result.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0136}
{\up $}{\footnote\pard\plain{\up $} string_translate}
{\up #}{\footnote\pard\plain{\up #} 4K0T_WX}
\pard\keepn\sb95 \b\fs25 string_translate\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} string manipulation operation, string_translate;string_translate}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul string manipulation operation\plain\fs20\cf1\cb1 {\v string manipulation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 string_translate C D S [O]    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 cut\plain\fs20\cf1\cb1 {\v 1_E6SIJ}, \uldb cutall\plain\fs20\cf1\cb1 {\v 3ZO7_NR}, \uldb regexp\plain\fs20\cf1\cb1 {\v 1JDPCSA}\line

\par The operation \i string_translate\plain\fs20\cf1\cb1  is used to translate characters in string \i S\plain\fs20\cf1\cb1  based on mapping characters in \i C\plain\fs20\cf1\cb1  to the corresponding ones in \i D\plain\fs20\cf1\cb1 . The optional control argument \i O\plain\fs20\cf1\cb1  is a string or phrase where \i 'd'\plain\fs20\cf1\cb1  deletes the characters in \i C\plain\fs20\cf1\cb1 , \i 'c'\plain\fs20\cf1\cb1  complements characters by replacing characters not in \i C\plain\fs20\cf1\cb1  by the last character in \i D\plain\fs20\cf1\cb1 , and \i 's'\plain\fs20\cf1\cb1  translates characters in \i C\plain\fs20\cf1\cb1  to those in \i D\plain\fs20\cf1\cb1  but also squeezes many occurrences to one.
\par \pard\keep\sb95 \f1\fs16      string_translate 'abc' 'def' 'hello able cats' \line
hello dele fdts \line
 \line
     string_translate ' ' '_' 'a whole lot of     loving' 's' \line
a_whole_lot_of_loving \line
 \line
     string_translate 'xz' '' 'extraneous zeal' 'd' \line
etraneous eal \line
 \line
     string_translate 'xz' 'b' 'extraneous zeal' 'c' \line
bxbbbbbbbbbzbbb\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example illustrates the translation of characters directly. The second shows translation with squeezing. The third example shows the use the \i 'd'\plain\fs20\cf1\cb1  option to delete characters. Example four shows the use of the complement option.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0137}
{\up $}{\footnote\pard\plain{\up $} sublist}
{\up #}{\footnote\pard\plain{\up #} 88JHY6}
\pard\keepn\sb95 \b\fs25 sublist\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} selection operation, sublist;sublist}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A sublist B   sublist A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 cull\plain\fs20\cf1\cb1 {\v 40MD_Q}, \uldb except\plain\fs20\cf1\cb1 {\v 1_WLCKE}, \uldb front\plain\fs20\cf1\cb1 {\v 7COCHJ}, \uldb rest\plain\fs20\cf1\cb1 {\v 1CMI3HN}\line

\par The operation \i sublist\plain\fs20\cf1\cb1  returns a list of items of \i B\plain\fs20\cf1\cb1  chosen according to the list of booleans given in \i A\plain\fs20\cf1\cb1 , selecting those items of \i B\plain\fs20\cf1\cb1  where the corresponding item of \i A\plain\fs20\cf1\cb1  is \i true\plain\fs20\cf1\cb1 .  If the tally of \i A\plain\fs20\cf1\cb1  is not the same as the tally of \i B\plain\fs20\cf1\cb1 , it is coerced to have the same tally as \i B\plain\fs20\cf1\cb1  using \i reshape\plain\fs20\cf1\cb1 .  If \i B\plain\fs20\cf1\cb1  is not a list, the result is the same as applying \i sublist\plain\fs20\cf1\cb1  to the list of \i B\plain\fs20\cf1\cb1 .  The tally of the result is the sum of \i A\plain\fs20\cf1\cb1  after it has been extended, if necessary.  
\par \pard\keep\sb95 \f1\fs16      lolloll sublist 2 3 4 8 5 10 6 \line
2 4 8 10 6 \line
 \line
     lo sublist 'hello world' \line
hlowrd\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows the use of \i sublist\plain\fs20\cf1\cb1  to select the items of the list that are even numbers.  The second example uses the left argument cyclically.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape (A sublist B) = sum (tally B reshape A) \line
   list (A sublist B) = A sublist B \line
   A sublist list B = A sublist B \line
   l sublist A = list A \line
   o sublist A = Null \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0138}
{\up $}{\footnote\pard\plain{\up $} sum}
{\up #}{\footnote\pard\plain{\up #} 1_E78IC}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 sum\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, sum;sum}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Properties:  \uldb \plain\uldb\fs20\cf1\cb1 multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}, \uldb reductive\plain\fs20\cf1\cb1 {\v 7GGROL}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 sum A   + A   A sum B   A + B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 plus\plain\fs20\cf1\cb1 {\v 1CMG0JM}, \uldb minus\plain\fs20\cf1\cb1 {\v 7JFBOI}, \uldb times\plain\fs20\cf1\cb1 {\v 5JEP_NH}, \uldb divide\plain\fs20\cf1\cb1 {\v 6242D6P}, \uldb opposite\plain\fs20\cf1\cb1 {\v 18Y3XQ}\line

\par The operation \i sum\plain\fs20\cf1\cb1  adds the items of a simple array of numbers, reducing them to a single number that is their sum.  The type of the result is the highest type of the items.  The operation is extended to non-simple arrays by the multi pervasive mechanism.  For an empty simple array, the result is 0.  The symbol \i +\plain\fs20\cf1\cb1  is a synonym for \i sum\plain\fs20\cf1\cb1 .  The operation \i plus\plain\fs20\cf1\cb1  is \i sum\plain\fs20\cf1\cb1  restricted to use on pairs.  
\par \pard\keep\sb95 \f1\fs16      R gets l 2 2.5 `a "abc ??error; \line
     R OUTER + R \line
     2       3     3.5  ?A  ?A  ?error \line
     3       4     4.5  ?A  ?A  ?error \line
   3.5     4.5      5.  ?A  ?A  ?error \line
?A      ?A      ?A      ?A  ?A  ?A \line
?A      ?A      ?A      ?A  ?A  ?A \line
?error  ?error  ?error  ?A  ?A  ?error \line
 \line
     sum 3. 45. 23. 18. 3.5 \line
92.5 \line
 \line
     sum (3 4 5) (2 3 2) (0 2 4) (1 1 1) \line
6 10 12 \line
 \line
     sum Null \line
0\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows the result of \i sum\plain\fs20\cf1\cb1  on all combinations of types of atoms.  The second last example shows that pervasive extension of \i sum\plain\fs20\cf1\cb1  adds a list of triples in an item by item fashion.  The last example shows that the sum of an empty array is 0.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    A sum B = B sum A \line
   sum single A = EACH (sum single) A \line
   sum EACH sum A =f= sum link A \line
   tally link A = sum EACH tally A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0139}
{\up $}{\footnote\pard\plain{\up $} symbols}
{\up #}{\footnote\pard\plain{\up #} 1KUXMUU}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 symbols\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} symbols;system operation, symbols}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 symbols Sw    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 status\plain\fs20\cf1\cb1 {\v .A2SLO}, \uldb exprs\plain\fs20\cf1\cb1 {\v 7BUDLI}, \uldb ops\plain\fs20\cf1\cb1 {\v 1_E74DI}, \uldb trs\plain\fs20\cf1\cb1 {\v 1_E79FI}, \uldb vars\plain\fs20\cf1\cb1 {\v 1CMLZGM}, \uldb see\plain\fs20\cf1\cb1 {\v 1ZNC7PK}\line

\par The operation \i symbols\plain\fs20\cf1\cb1  is used to get information on the use of names in the workspace.  If \i Sw\plain\fs20\cf1\cb1  is 0, the result is a list of pairs giving the names and roles of all the user defined names.  If \i Sw\plain\fs20\cf1\cb1  is 1, the result is the similar list for both system and user names.  The roles and their meaning are as follows: 
\par  \trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 \b Role \cell\pard \pard\intbl\sb95 Meaning \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 ident \cell\pard \pard\intbl\sb95 identifier \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 var \cell\pard \pard\intbl\sb95 variable \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 expr \cell\pard \pard\intbl\sb95 expression \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 op \cell\pard \pard\intbl\sb95 operation \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 tr \cell\pard \pard\intbl\sb95 transformer \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx775\cellx5795\pard\intbl\sb95 res \cell\pard \pard\intbl\sb95 reserved word \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      A := count 5; \line
 \line
     foo IS first rest \line
 \line
     symbols 0 \line
+-----+------+ \line
|A var|FOO op| \line
+-----+------+\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:013a}
{\up $}{\footnote\pard\plain{\up $} synonym}
{\up #}{\footnote\pard\plain{\up #} .DMN3Z}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 synonym\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} synonym;syntax, synonym}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}\line

\par \pard\sb95 A \b synonym\plain\fs20\cf1\cb1  is an alternate symbol or name that represents a Nial term.  For example, the symbol \line

\par The list of all synonyms in Nial follows: 
\par  \trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 \b div \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 divide \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 Falsehood, o \cell\pard \pard\intbl\sb95 expression \cell\pard \pard\intbl\sb95 False \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 inv \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 inverse \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 ip \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 innerproduct \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 istruthvalue \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 isboolean \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 opp \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 opposite \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 prod \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 product \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 recip \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 reciprocal \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 Truth, l \cell\pard \pard\intbl\sb95 expression \cell\pard \pard\intbl\sb95 True \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 vacate \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 Null first \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 void \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 Null first \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 + \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 sum \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 - \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 minus \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 * \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 product \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1435\cellx3105\cellx5795\pard\intbl\sb95 / \cell\pard \pard\intbl\sb95 operation \cell\pard \pard\intbl\sb95 divide \cell\intbl\row
\pard\sb95 \line

\par The following synonyms are available for keywords or delimiters used in the syntax rules:
\par  \trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 \b [ \cell\pard \pard\intbl\sb95 << \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 ] \cell\pard \pard\intbl\sb95 >> \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 := \cell\pard \pard\intbl\sb95 GETS \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 \{\- \cell\pard \pard\intbl\sb95 BEGIN \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 \'7d \cell\pard \pard\intbl\sb95 END \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 OPERATION \cell\pard \pard\intbl\sb95 OP \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1325\cellx5795\pard\intbl\sb95 TRANSFORMER \cell\pard \pard\intbl\sb95 TR \cell\intbl\row
\pard \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:013b}
{\up $}{\footnote\pard\plain{\up $} system}
{\up #}{\footnote\pard\plain{\up #} .FDS.I}
\pard\keepn\sb95 \b\fs25 system\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} constant expression, system;system}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul constant expression\plain\fs20\cf1\cb1 {\v constant expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 System    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 copyright\plain\fs20\cf1\cb1 {\v 2.MC.X4}, \uldb version\plain\fs20\cf1\cb1 {\v 4NLJMF}, \uldb nialroot\plain\fs20\cf1\cb1 {\v K_TBJ1}\line

\par The expression \i System\plain\fs20\cf1\cb1  returns a phrase indicating the operating system in use.  Possible values are EXTDOS, Windows or UNIX.  
\par \pard\keep\sb95 \f1\fs16      System \line
Windows\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:013c}
{\up $}{\footnote\pard\plain{\up $} take}
{\up #}{\footnote\pard\plain{\up #} 25VVYWO}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 take\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} selection operation, take;take}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A take B   take A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 drop\plain\fs20\cf1\cb1 {\v 5FYX_OT}, \uldb takeright\plain\fs20\cf1\cb1 {\v 149YX4U}, \uldb front\plain\fs20\cf1\cb1 {\v 7COCHJ}\line

\par The operation \i take\plain\fs20\cf1\cb1  selects a number of items from \i B\plain\fs20\cf1\cb1  as indicated by \i A\plain\fs20\cf1\cb1 .  \line

\par If \i B\plain\fs20\cf1\cb1  is a list and \i A\plain\fs20\cf1\cb1  is a non-negative integer, the result is the list formed from taking \i A\plain\fs20\cf1\cb1  items from the front of \i B\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  is negative, it takes items from the right end of \i B\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 If \i B\plain\fs20\cf1\cb1  is a table and \i A\plain\fs20\cf1\cb1  is a pair of non-negative integers, the result is the table formed by taking the number of rows and columns indicated by \i A\plain\fs20\cf1\cb1  from the upper left corner of \i B\plain\fs20\cf1\cb1 .  If one or both of the items of \i A\plain\fs20\cf1\cb1  are negative, the items are taken from the other end of the axis.  \line

\par For higher dimensional arrays \i B\plain\fs20\cf1\cb1 , the tally of \i A\plain\fs20\cf1\cb1  must equal the valence of \i B\plain\fs20\cf1\cb1  and the result is obtained by taking from the front or back of the extents along each axis according to the sign of the corresponding item of \i A\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 In all of the above cases, if an item of \i abs A\plain\fs20\cf1\cb1  is longer than the extent along the corresponding axis in \i B\plain\fs20\cf1\cb1 , the corresponding positions in the result are filled with the type of the first item of \i B\plain\fs20\cf1\cb1 .  If \i B\plain\fs20\cf1\cb1  is empty then the result is filled with the fault value \i ?fill\plain\fs20\cf1\cb1 .\line

\par If \i B\plain\fs20\cf1\cb1  is a single, the result is an array of shape \i abs A\plain\fs20\cf1\cb1 , with all its items equal to the item of \i B\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      2 take "Able "Baker "Charlie "Dog \line
Able Baker \line
 \line
     T1 := tell 2 4 \line
+---+---+---+---+ \line
|0 0|0 1|0 2|0 3| \line
+---+---+---+---+ \line
|1 0|1 1|1 2|1 3| \line
+---+---+---+---+ \line
 \line
     1 2 take T1 \line
+---+---+ \line
|0 0|0 1| \line
+---+---+ \line
 \line
     3 -5 take T1 \line
+---+---+---+---+---+ \line
|0 0|0 0|0 1|0 2|0 3| \line
+---+---+---+---+---+ \line
|0 0|1 0|1 1|1 2|1 3| \line
+---+---+---+---+---+ \line
|0 0|0 0|0 0|0 0|0 0| \line
+---+---+---+---+---+ \line
 \line
     2 3 take single 3 5 \line
+---+---+---+ \line
|3 5|3 5|3 5| \line
+---+---+---+ \line
|3 5|3 5|3 5| \line
+---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The last example shows that taking from a single repeats the item of the single in every item of the result.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape A take A = A \line
   tally A = valence B and (and EACH isinteger A) ==> shape (A take B) = list abs A \line
   valence B = 0 and (and EACH isinteger A) ==> A take B = abs A reshape B \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:013d}
{\up $}{\footnote\pard\plain{\up $} takeright}
{\up #}{\footnote\pard\plain{\up #} 149YX4U}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 takeright\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} selection operation, takeright;takeright}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A takeright B   takeright A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 take\plain\fs20\cf1\cb1 {\v 25VVYWO}, \uldb dropright\plain\fs20\cf1\cb1 {\v H_F96H}, \uldb last\plain\fs20\cf1\cb1 {\v 1CMBZHN}\line

\par The operation \i takeright\plain\fs20\cf1\cb1  is an obsolete operation that takes items from the ends of extents.  It is provided to retain compatibility with earlier versions of Q'Nial.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      takeright IS OPERATION A B \{\- opposite A take B \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:013e}
{\up $}{\footnote\pard\plain{\up $} tally}
{\up #}{\footnote\pard\plain{\up #} 5JEH.UN}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 tally\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} measurement operation, tally;tally}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 tally A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 shape\plain\fs20\cf1\cb1 {\v TYQ56K}, \uldb valence\plain\fs20\cf1\cb1 {\v MQJNXM}, \uldb grid\plain\fs20\cf1\cb1 {\v 40QA0I}, \uldb list\plain\fs20\cf1\cb1 {\v 40V8DY}\line

\par The operation \i tally\plain\fs20\cf1\cb1  returns an integer indicating the number of items of the array at the first level of nesting.  This is called the tally of the array.  The tally of a single is 1.  The tally of a list is the number of items in it.  The tally of a table is the product of the number of rows and columns.  In general, the tally of an array is the product of its shape.  
\par \pard\keep\sb95 \f1\fs16      tally "abc \line
1 \line
     tally 3 4 5 \line
3 \line
     tally 'hello world' \line
11 \line
     tally (2 3) (4 5 6) \line
2 \line
     tally tell 3 4 \line
12\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      tally IS OPERATION A (product shape A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    tally A = first shape list A \line
   tally shape A = valence A \line
   tally tally A = 1 \line
   tally A reshape A = list A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:013f}
{\up $}{\footnote\pard\plain{\up $} tan}
{\up #}{\footnote\pard\plain{\up #} 1_E795D}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 tan\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} scientific operation, tan;tan}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 tan A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 arctan\plain\fs20\cf1\cb1 {\v 1VZXQSO}, \uldb sin\plain\fs20\cf1\cb1 {\v 1_E78_D}, \uldb cos\plain\fs20\cf1\cb1 {\v 1_E6SCI}, \uldb tanh\plain\fs20\cf1\cb1 {\v 1CMJZCB}\line

\par The operation \i tan\plain\fs20\cf1\cb1  implements the tangent function of mathematics.  It produces the following results when applied to atoms of the six types: 
\par 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 tangent of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 tangent of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 tangent of angle A given in radians \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      tan  l  -1  0.5  `a  "abc  ??error \line
1.55741 -1.55741 0.546302 ?A ?A ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      tan IS OPERATION A (sin A divide cos A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    tan opposite A = opposite tan A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0140}
{\up $}{\footnote\pard\plain{\up $} tanh}
{\up #}{\footnote\pard\plain{\up #} 1CMJZCB}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 tanh\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} scientific operation, tanh;tanh}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul scientific operation\plain\fs20\cf1\cb1 {\v scientific operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 tanh A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 tan\plain\fs20\cf1\cb1 {\v 1_E795D}, \uldb arctan\plain\fs20\cf1\cb1 {\v 1VZXQSO}, \uldb sinh\plain\fs20\cf1\cb1 {\v 1CMJ7CB}, \uldb cosh\plain\fs20\cf1\cb1 {\v 1CM0_HB}\line

\par The operation \i tanh\plain\fs20\cf1\cb1  implements the hyperbolic tangent function of mathematics.  It produces the following results when applied to atoms of the six types: 
\par 
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic Type \cell\pard \pard\intbl\sb95 Result \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 hyperbolic tangent of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 hyperbolic tangent of the corresponding real \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 hyperbolic tangent of angle A given in radians \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 fault ?A \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 argument A \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      tanh  l  -1  0.5  `a  "abc  ??error \line
0.761594 -0.761594 0.462117 ?A ?A ?error\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      tanh IS OPERATION A (sinh A divide cosh A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    tanh opposite A = opposite tanh A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0141}
{\up $}{\footnote\pard\plain{\up $} team}
{\up #}{\footnote\pard\plain{\up #} 1CMK36G}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 team\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} applicative transformer, team;team}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul applicative transformer\plain\fs20\cf1\cb1 {\v applicative transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 TEAM f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 each\plain\fs20\cf1\cb1 {\v QCZZL2}, \uldb eachboth\plain\fs20\cf1\cb1 {\v 1R110IM}, \uldb eachall\plain\fs20\cf1\cb1 {\v LYL6P6}, \uldb fold\plain\fs20\cf1\cb1 {\v QD1_TY}, \uldb iterate\plain\fs20\cf1\cb1 {\v 11O99LP}\line

\par The transformer \i TEAM\plain\fs20\cf1\cb1  applies the operations of atlas \i f\plain\fs20\cf1\cb1  to corresponding items in the list of \i A\plain\fs20\cf1\cb1 .  There must be the same number of items in \i A\plain\fs20\cf1\cb1  as there are operations in the atlas \i f\plain\fs20\cf1\cb1 .  The result has the shape of \i A\plain\fs20\cf1\cb1 .  If \i f\plain\fs20\cf1\cb1  is an operation that is not an atlas, \i TEAM f A\plain\fs20\cf1\cb1  is the application of \i f\plain\fs20\cf1\cb1  to \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      TEAM [+,*,max,min] (3 2)(4 5)(2 3 4)(2 3 4) \line
5 20 4 2 \line
 \line
     TEAM [+,*,max,min] count 2 2 \line
2 2 \line
2 2 \line
 \line
     TEAM second count 5 \line
2\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0142}
{\up $}{\footnote\pard\plain{\up $} tell}
{\up #}{\footnote\pard\plain{\up #} 1CMK3AF}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 tell\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} array generation operation, tell;tell}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul array generation operation\plain\fs20\cf1\cb1 {\v array generation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 tell A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 count\plain\fs20\cf1\cb1 {\v TIXI4Z}, \uldb gage\plain\fs20\cf1\cb1 {\v QD1ZOZ}, \uldb grid\plain\fs20\cf1\cb1 {\v 40QA0I}, \uldb cart\plain\fs20\cf1\cb1 {\v 1CM9ZGN}\line

\par The operation \i tell\plain\fs20\cf1\cb1  is used to generate an array of addresses from a shape.  For a non-negative integer \i N\plain\fs20\cf1\cb1 , it generates the list of integers from 0 to \i N - 1\plain\fs20\cf1\cb1 .  For a list of non-negative integers, \i tell\plain\fs20\cf1\cb1  generates the array of all combinations of tell applied to the items of the list.  If \i list A\plain\fs20\cf1\cb1  is not a shape, the result is the fault \i ?shape\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      tell 5 \line
0 1 2 3 4 \line
 \line
     tell 3 4 \line
+---+---+---+---+ \line
|0 0|0 1|0 2|0 3| \line
+---+---+---+---+ \line
|1 0|1 1|1 2|1 3| \line
+---+---+---+---+ \line
|2 0|2 1|2 2|2 3| \line
+---+---+---+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The examples show \i tell\plain\fs20\cf1\cb1  being applied to a shape and returning the array of addresses.  \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    tell shape A choose A = A \line
   isinteger A or isshape A ==> tell A = cart EACH tell A \line
   N an integer and (N >= 0) ==> tell (N + 1) = (tell N append N) \line
   tell Null = single Null \line
   tell 0 = Null \line
   tell 1 = solitary 0 \line
   tell solitary 1 = solitary solitary 0 \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0143}
{\up $}{\footnote\pard\plain{\up $} third}
{\up #}{\footnote\pard\plain{\up #} 7QE_L0}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 third\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} selection operation, third;third}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul selection operation\plain\fs20\cf1\cb1 {\v selection operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 third A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 first\plain\fs20\cf1\cb1 {\v 7CFFMJ}, \uldb second\plain\fs20\cf1\cb1 {\v 1KDLMI5}, \uldb find\plain\fs20\cf1\cb1 {\v QD17VY}, \uldb last\plain\fs20\cf1\cb1 {\v 1CMBZHN}, \uldb pick\plain\fs20\cf1\cb1 {\v 40Z84P}\line

\par The operation \i third\plain\fs20\cf1\cb1  returns the third of the items of \i A\plain\fs20\cf1\cb1 .  \i Third\plain\fs20\cf1\cb1  is defined in terms of \i pick\plain\fs20\cf1\cb1  and its behaviour is affected by that of \i pick\plain\fs20\cf1\cb1 .  The third of a triple is its last item.  The third of a table is the third item in the list of items in row major order.  The third of an array with two or fewer items is the fault \i ?address\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      third 4 5 6 \line
6 \line
 \line
     third tell 3 4 \line
0 2 \line
 \line
     third Null \line
0\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      third IS OPERATION A \{\- 2 pick list A \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    third list A = third A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0144}
{\up $}{\footnote\pard\plain{\up $} time}
{\up #}{\footnote\pard\plain{\up #} 25VW6YO}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 time\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} system expression, time;time}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Time    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 timestamp\plain\fs20\cf1\cb1 {\v 1XKI84P}\line

\par The expression \i Time\plain\fs20\cf1\cb1  returns a real number giving the time in seconds spent in executing Q'Nial since the beginning of the session.  On systems permitting multi-processing, the time represents central processor time in seconds.  \line

\par The expression \i Time\plain\fs20\cf1\cb1  is useful for estimating the relative costs of Q'Nial operations in terms of processor time.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0145}
{\up $}{\footnote\pard\plain{\up $} times}
{\up #}{\footnote\pard\plain{\up #} 5JEP_NH}
\pard\keepn\sb95 \b\fs25 times\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} arithmetic operation, times;times}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul arithmetic operation\plain\fs20\cf1\cb1 {\v arithmetic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A times B   times A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 product\plain\fs20\cf1\cb1 {\v 2H9LPX5}, \uldb divide\plain\fs20\cf1\cb1 {\v 6242D6P}, \uldb reciprocal\plain\fs20\cf1\cb1 {\v AJCGJN}, \uldb plus\plain\fs20\cf1\cb1 {\v 1CMG0JM}\line

\par The operation \i times\plain\fs20\cf1\cb1  is the same as \i product\plain\fs20\cf1\cb1  (and synonym \i *\plain\fs20\cf1\cb1 ) except that it enforces the rule that it must be applied to a pair.  \i Product\plain\fs20\cf1\cb1  is multi pervasive and can add up any number of items.  
\par \pard\keep\sb95 \f1\fs16      7 times 9 \line
63 \line
 \line
     (2 3 4) times (12 22 33) \line
24 66 132 \line
 \line
     times 2 3 4 \line
?times expects a pair\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0146}
{\up $}{\footnote\pard\plain{\up $} timestamp}
{\up #}{\footnote\pard\plain{\up #} 1XKI84P}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 timestamp\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} system expression, timestamp;timestamp}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Timestamp    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 time\plain\fs20\cf1\cb1 {\v 25VW6YO}\line

\par The expression \i Timestamp\plain\fs20\cf1\cb1  gives the current date and time in the standard format for the host system.  The details of this expression are implementation dependent.  \line

\par The result is reported as a string giving the date and time.  \i Timestamp\plain\fs20\cf1\cb1  is useful for dating reports and messages.  
\par \pard\keep\sb95 \f1\fs16      Timestamp \line
Mon Jan 27 14:07:37 1997\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0147}
{\up $}{\footnote\pard\plain{\up $} toend}
{\up #}{\footnote\pard\plain{\up #} 7QL9H0}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 toend\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} debugging command, toend;toend}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul debugging command\plain\fs20\cf1\cb1 {\v debugging command}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 toend    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 debugging\plain\fs20\cf1\cb1 {\v PP0_XH}, \uldb break\plain\fs20\cf1\cb1 {\v 2V9T7BV}, \uldb resume\plain\fs20\cf1\cb1 {\v 1JE1SH6}, \uldb next\plain\fs20\cf1\cb1 {\v 40X4IY}, \uldb step\plain\fs20\cf1\cb1 {\v 1CMJB0J}, \uldb stepin\plain\fs20\cf1\cb1 {\v YJBNWZ}\line

\par The command \i toend\plain\fs20\cf1\cb1  is used in debugging a definition that has been suspended using Break or <Ctrl B>.  The effect of \i toend\plain\fs20\cf1\cb1  is to execute all the expressions to the end of the current loop or the end of the definition. If there is a loop then execution suspends on the expression following the loop. If the \i toend\plain\fs20\cf1\cb1  is issued when not in a loop, execution suspends on the expression being returned from the definition.\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0148}
{\up $}{\footnote\pard\plain{\up $} tolower}
{\up #}{\footnote\pard\plain{\up #} 12BMVK4}
\pard\keepn\sb95 \b\fs25 tolower\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} conversion operation, tolower;tolower}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 tolower A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 toupper\plain\fs20\cf1\cb1 {\v 12KNOK4}, \uldb tonumber\plain\fs20\cf1\cb1 {\v 1_RG0DJ}, \uldb char\plain\fs20\cf1\cb1 {\v 40M72W}, \uldb charrep\plain\fs20\cf1\cb1 {\v 2W9HDTD}, \uldb phrase\plain\fs20\cf1\cb1 {\v 4.B5_UK}, \uldb string\plain\fs20\cf1\cb1 {\v .ACHEC}\line

\par The operation \i tolower\plain\fs20\cf1\cb1  is used to ensure that a string has all its letters in lower case.  Applied to a string \i A\plain\fs20\cf1\cb1 , it results in a string with all the upper case letters converted to lower case leaving all other characters unchanged.  It can also be used on a single character.  
\par \pard\keep\sb95 \f1\fs16      tolower 'abcDE*?12xyZ' \line
abcde*?12xyz \line
 \line
     tolower 'STATEMENT IN LOWER CASE' \line
statement in lower case\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0149}
{\up $}{\footnote\pard\plain{\up $} tonumber}
{\up #}{\footnote\pard\plain{\up #} 1_RG0DJ}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 tonumber\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} conversion operation, tonumber;tonumber}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 tonumber A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 tolower\plain\fs20\cf1\cb1 {\v 12BMVK4}, \uldb toupper\plain\fs20\cf1\cb1 {\v 12KNOK4}, \uldb execute\plain\fs20\cf1\cb1 {\v 3WULI4D}, \uldb char\plain\fs20\cf1\cb1 {\v 40M72W}, \uldb charrep\plain\fs20\cf1\cb1 {\v 2W9HDTD}, \uldb string\plain\fs20\cf1\cb1 {\v .ACHEC}\line

\par The operation \i tonumber\plain\fs20\cf1\cb1  converts the string \i A\plain\fs20\cf1\cb1  holding a character representation of a number to its corresponding numeric representation.  
\par \pard\keep\sb95 \f1\fs16      tonumber '345' \line
345 \line
 \line
     tonumber '37.456' \line
37.456 \line
 \line
     tonumber '123456789012345' \line
1.23457e+14 \line
 \line
     tonumber 'l' \line
l \line
 \line
     tonumber '"abc' \line
?not a number\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    Numstr a string representing a number ==> tostring Numstr = execute Numstr  \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:014a}
{\up $}{\footnote\pard\plain{\up $} top level loop}
{\up #}{\footnote\pard\plain{\up #} 4CHEV95}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 top level loop\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, top level loop;top level loop}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 toplevel\plain\fs20\cf1\cb1 {\v 3A08M4I}, \uldb loaddefs\plain\fs20\cf1\cb1 {\v RIAXFW}\line

\par Nial program fragments are entered during interactive input with a process called the \b top level loop\plain\fs20\cf1\cb1 ; or brought into the system under the control of a systems operation, \i loaddefs\plain\fs20\cf1\cb1 .  This systems operation has the effect of loading a sequence of program fragments from a file as though the fragments had been entered interactively in the order they appear in the file.  \line

\par The global environment is the collection of associations between names and meanings that are known at the top level loop.  Such names have global scope in that they can be referenced by any program text.  All other names have a local scope that associates a meaning with the name only during execution of a specific portion of a program text.  \line

\par \pard\sb95 In direct input at the top level loop, a remark ends at the end of the line unless a backslash symbol ( \'5c ) is used to extend the line.  In a definition file, a remark ends at the first blank line.  A remark cannot appear within a definition or expression-sequence.  \line

\par The expressions in an expression-sequence are evaluated in left-to-right order.  If the sequence does not terminate with a semicolon, the array returned is the result of the last expression.  If the sequence does end with a semicolon, the array returned is the fault \i ?noexpr\plain\fs20\cf1\cb1 .  At the top level loop, if the array returned is the fault \i ?noexpr\plain\fs20\cf1\cb1 , it is not displayed.  \line

\par \pard\sb95 In window mode for a console version of Q'Nial when a window is used interactively from the top level loop, the terminal acts as though it has a screen the size of the window.  In particular, as the cursor attempts to move below the bottom line of the window, the text is scrolled one line at a time.  The speed of scrolling can be changed using the operation \i setscroll\plain\fs20\cf1\cb1 .\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:014b}
{\up $}{\footnote\pard\plain{\up $} topic}
{\up #}{\footnote\pard\plain{\up #} 7QLDC9}
\pard\keepn\sb95 \b\fs25 topic\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} system operation, topic;topic}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 topic Name    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 help\plain\fs20\cf1\cb1 {\v 40R4_U}, \uldb symbols\plain\fs20\cf1\cb1 {\v 1KUXMUU}\line

\par The operation \i topic\plain\fs20\cf1\cb1  uses the Q'Nial Help Facility for console versions to display help on the subject given as the argument to the operation.  \i Name\plain\fs20\cf1\cb1  should be a phrase or string naming a particular subject.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:014c}
{\up $}{\footnote\pard\plain{\up $} toplevel}
{\up #}{\footnote\pard\plain{\up #} 3A08M4I}
\pard\keepn\sb95 \b\fs25 toplevel\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} system expression, toplevel;toplevel}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Toplevel    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 recover\plain\fs20\cf1\cb1 {\v 7L0TNT}, \uldb continue\plain\fs20\cf1\cb1 {\v 1FW5IX}, \uldb restart\plain\fs20\cf1\cb1 {\v 3I4P_OP}, \uldb save\plain\fs20\cf1\cb1 {\v 25VUZ7O}, \uldb status\plain\fs20\cf1\cb1 {\v .A2SLO}\line

\par The expression \i Toplevel\plain\fs20\cf1\cb1  ends the execution of the definition currently being executed and returns control to the top level loop where an operation named \i recover\plain\fs20\cf1\cb1  is executed if it is present in the workspace.  \line

\par The major purpose for \i Toplevel\plain\fs20\cf1\cb1  is to handle an exception condition within a definition by forcing the definition to terminate.  Use of a \i recover\plain\fs20\cf1\cb1  operation makes it possible to recover gracefully in such cases.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:014d}
{\up $}{\footnote\pard\plain{\up $} toraw}
{\up #}{\footnote\pard\plain{\up #} TZXES2}
\pard\keepn\sb95 \b\fs25 toraw\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} conversion operation, toraw;toraw}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 toraw A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 fromraw\plain\fs20\cf1\cb1 {\v 1IXHU.}, \uldb tonumber\plain\fs20\cf1\cb1 {\v 1_RG0DJ}\line

\par The operation \i toraw\plain\fs20\cf1\cb1  converts the simple array \i A\plain\fs20\cf1\cb1  of real number, integers, or characters to a boolean array corresponding to the internal bit pattern for the data.
\par \pard\keep\sb95 \f1\fs16      toraw 'abc' \line
olloooololloooloolloooll \line
 \line
     toraw 345 \line
ooooooooooooooooooooooololollool \line
 \line
     toraw 34.5 \line
olooooooolooooololoooooooooooooooooooooooooooooooooooooooooooooo \line
 \line
     toraw lollo \line
lollo \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equation\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    simple A and and (type A match type first A) => A = fromraw (toraw A) (first A) \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:014e}
{\up $}{\footnote\pard\plain{\up $} toupper}
{\up #}{\footnote\pard\plain{\up #} 12KNOK4}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 toupper\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} conversion operation, toupper;toupper}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul conversion operation\plain\fs20\cf1\cb1 {\v conversion operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 toupper A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 tolower\plain\fs20\cf1\cb1 {\v 12BMVK4}, \uldb tonumber\plain\fs20\cf1\cb1 {\v 1_RG0DJ}, \uldb char\plain\fs20\cf1\cb1 {\v 40M72W}, \uldb charrep\plain\fs20\cf1\cb1 {\v 2W9HDTD}, \uldb string\plain\fs20\cf1\cb1 {\v .ACHEC}\line

\par The operation \i toupper\plain\fs20\cf1\cb1  is used to ensure that a string has all its letters in upper case.  Applied to a string \i A\plain\fs20\cf1\cb1 , it results in a string with all the lower case letters converted to upper case leaving all other characters unchanged.  It can also be used on a single character.  
\par \pard\keep\sb95 \f1\fs16      toupper 'abcDE*?12xyZ' \line
ABCDE*?12XYZ \line
 \line
     toupper 'a statement in upper case' \line
A STATEMENT IN UPPER CASE\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:014f}
{\up $}{\footnote\pard\plain{\up $} transformer}
{\up #}{\footnote\pard\plain{\up #} 1VQL398}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 transformer\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} concept, transformer;transformer}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul concept\plain\fs20\cf1\cb1 {\v concept}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 expression\plain\fs20\cf1\cb1 {\v FD5QFK}, \uldb operation\plain\fs20\cf1\cb1 {\v CQFG7.}, \uldb definition\plain\fs20\cf1\cb1 {\v K9LSXA}\line

\par A \b transformer\plain\fs20\cf1\cb1  is a functional object that is used to construct a new operation from a given operation argument, usually producing a modified version of the given operation.  Most transformers used in Nial are provided in the core language.  However, there is a mechanism that constructs a named transformer in terms of one or more operation parameters.  A user-defined transformer describes the modified operation as a parameterized algorithm for manipulating data.  \line

\par \pard\sb95 A transformer usually specifies a general algorithm which can have an operation as a parameter.  For example, the \i EACH\plain\fs20\cf1\cb1  family of transformers generalizes a number of looping mechanisms for applying an operation to items of arrays.  \line

\par A user-defined transformer could provide the skeleton for processing the records of a file and allow an arbitrary operation to be applied to each record.  Such a transformer is often called a filter.  \line

\par The process of evaluating an operation call of an operation modified by a transformer requires two steps.  The modified operation is formed; and then the modified operation is given the array argument which it uses to produce the result.  
\par \pard\keep\sb95 \f1\fs16      TWICE is TRANSFORMER f (f f) \line
      \line
     TWICE rest 4 5 6 7 8 \line
6 7 8\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0150}
{\up $}{\footnote\pard\plain{\up $} transformer form}
{\up #}{\footnote\pard\plain{\up #} 19VZZWW}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 transformer form\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} syntax, transformer form;transformer form}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 transformer\plain\fs20\cf1\cb1 {\v 1VQL398}, \uldb definition\plain\fs20\cf1\cb1 {\v K9LSXA}\line

\par A \b transformer-form\plain\fs20\cf1\cb1  is the syntactic structure used to describe a transformer in terms of an operation expression involving formal operation parameters.  The names that follow the keyword transformer in the transformer-form are called formal operation parameters.  The body of a transformer-form is the operation-expression which uses these names.  The first rule requires that the operation-expression be an operation-form; the second allows any operation- expression to be used.  
\par \pard\keep\sb95 \f1\fs16      transformer-form ::= TRANSFORMER \line
        \{\- identifier \'7d+ operation-form \line
        | TRANSFORMER \{\- identifier \'7d+ \line
          ( operation-expression )\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The effect of applying a transformer-form to an operation-expression is the effect of an operation formed in the body of the transformer, such that wherever one of the formal operation parameters occurs, it is replaced with the corresponding argument operation-expression.  \line

\par On the other hand, if the formal operation parameters consist of only one name, the operation formed is associated with the argument operation-expression.  If the operation formed has two or more names, the operation-expression must denote an atlas of the same length; and the formal operation parameters are associated with the operations of the atlas in their sequence.  \line

\par \pard\sb95 The associations are made with the argument operation-expression in the environment where the transformer is applied.  If there is a mismatch between the number of formal operation parameters and the argument, the result of applying the transform is the fault \i ?tr_parameter\plain\fs20\cf1\cb1 .  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0151}
{\up $}{\footnote\pard\plain{\up $} transpose}
{\up #}{\footnote\pard\plain{\up #} 2UPAHZ}
\pard\keepn\sb95 \b\fs25 transpose\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} data rearrangement operation, transpose;transpose}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul data rearrangement operation\plain\fs20\cf1\cb1 {\v data rearrangement operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 transpose A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 fuse\plain\fs20\cf1\cb1 {\v 40PDDJ}, \uldb reverse\plain\fs20\cf1\cb1 {\v U_.PHW}, \uldb pack\plain\fs20\cf1\cb1 {\v QD0ZL5}\line

\par The operation \i transpose\plain\fs20\cf1\cb1  is used to reverse the axes of a table or array of higher valence.  If \i A\plain\fs20\cf1\cb1  is an \i M\plain\fs20\cf1\cb1  by \i N\plain\fs20\cf1\cb1  table, the transpose is the \i N\plain\fs20\cf1\cb1  by \i M\plain\fs20\cf1\cb1  table whose rows are the columns of \i A\plain\fs20\cf1\cb1 .  \i Transpose\plain\fs20\cf1\cb1  has no effect on a single or a list.  
\par \pard\keep\sb95 \f1\fs16      transpose tell 2 3 \line
+---+---+ \line
|0 0|1 0| \line
+---+---+ \line
|0 1|1 1| \line
+---+---+ \line
|0 2|1 2| \line
+---+---+ \line
 \line
     A := 2 3 4 reshape count 24 \line
1  2  3  4   13 14 15 16 \line
5  6  7  8   17 18 19 20 \line
9 10 11 12   21 22 23 24 \line
 \line
     transpose A \line
1 13    2 14    3 15    4 16 \line
5 17    6 18    7 19    8 20 \line
9 21   10 22   11 23   12 24\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      transpose IS OPERATION A ( reverse tell valence A fuse A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape transpose A = reverse shape A \line
   transpose A = reverse axes A fuse A \line
   transpose transpose A = A \line
   transpose single A = single A \line
   transpose list A = list A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0152}
{\up $}{\footnote\pard\plain{\up $} trs}
{\up #}{\footnote\pard\plain{\up #} 1_E79FI}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 trs\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} system expression, trs;trs}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Trs    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 symbols\plain\fs20\cf1\cb1 {\v 1KUXMUU}, \uldb exprs\plain\fs20\cf1\cb1 {\v 7BUDLI}, \uldb ops\plain\fs20\cf1\cb1 {\v 1_E74DI}, \uldb vars\plain\fs20\cf1\cb1 {\v 1CMLZGM}\line

\par The expression \i Trs\plain\fs20\cf1\cb1  returns a list of phrases giving the names of all user defined transformers in the workspace.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      Trs IS \{\-  \line
        Names Roles := pack symbols 0;  \line
        "tr match Roles sublist Names \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0153}
{\up $}{\footnote\pard\plain{\up $} true}
{\up #}{\footnote\pard\plain{\up #} 5FZ__UI}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 true\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} constant expression, true;true}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul constant expression\plain\fs20\cf1\cb1 {\v constant expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 True    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 false\plain\fs20\cf1\cb1 {\v 4WY._DU}, \uldb isboolean\plain\fs20\cf1\cb1 {\v 1VYX20O}\line

\par The constant expression \i True\plain\fs20\cf1\cb1  denotes the boolean atom for \i true\plain\fs20\cf1\cb1 , which Nial also denotes by \i l\plain\fs20\cf1\cb1 .   It is the result of comparing two identical arrays for equality.\line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      True IS (0 equal 0) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    tally True = 1 \line
   shape True = Null \line
   single True = True \line
   not True = False \line
   max True = True \line
   abs True = 1 \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0154}
{\up $}{\footnote\pard\plain{\up $} twig}
{\up #}{\footnote\pard\plain{\up #} 25VWDUQ}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 twig\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} distributive transformer, twig;twig}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul distributive transformer\plain\fs20\cf1\cb1 {\v distributive transformer}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 TWIG f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 leaf\plain\fs20\cf1\cb1 {\v 40V42K}, \uldb each\plain\fs20\cf1\cb1 {\v QCZZL2}\line

\par The transformer \i TWIG\plain\fs20\cf1\cb1  transforms an operation \i f\plain\fs20\cf1\cb1  into an operation that applies \i f\plain\fs20\cf1\cb1  to every simple array in the nested structure of \i A\plain\fs20\cf1\cb1 .  The resulting operation is called the \i TWIG\plain\fs20\cf1\cb1  transform of \i f\plain\fs20\cf1\cb1 .  The result of applying the \i TWIG\plain\fs20\cf1\cb1  transform of \i f\plain\fs20\cf1\cb1  to \i A\plain\fs20\cf1\cb1  has the same shape as \i A\plain\fs20\cf1\cb1 .  If \i f\plain\fs20\cf1\cb1  maps simple arrays to simple arrays of the same shape, the result has the same structure as \i A\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      T1 := count 2 3 \line
+---+---+---+ \line
|1 1|1 2|1 3| \line
+---+---+---+ \line
|2 1|2 2|2 3| \line
+---+---+---+ \line
 \line
     TWIG tally T1 \line
2 2 2 \line
2 2 2 \line
 \line
     TWIG tell T1 \line
+-----+---------+-------------+ \line
|+---+|+---+---+|+---+---+---+| \line
||0 0|||0 0|0 1|||0 0|0 1|0 2|| \line
|+---+|+---+---+|+---+---+---+| \line
+-----+---------+-------------+ \line
|+---+|+---+---+|+---+---+---+| \line
||0 0|||0 0|0 1|||0 0|0 1|0 2|| \line
|+---+|+---+---+|+---+---+---+| \line
||1 0|||1 0|1 1|||1 0|1 1|1 2|| \line
|+---+|+---+---+|+---+---+---+| \line
+-----+---------+-------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example shows that the result of applying a \i TWIG\plain\fs20\cf1\cb1  transform to a table is a table of the same shape.  The items of \i T1\plain\fs20\cf1\cb1  are simple and hence have been mapped by tally to 2.  In the second example, the structure of the result is not preserved because \i tell\plain\fs20\cf1\cb1  maps a pair to a table of pairs.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      TWIG IS TRANSFORMER f OPERATION A \{\- \line
        IF simple A THEN \line
           f A \line
        ELSE \line
           EACH (TWIG f) A \line
        ENDIF \'7d \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape TWIG f A = shape A \line
   f unary pervasive ==> TWIG f A = f A \line
   (TWIG f) (TWIG g) A = TWIG (f g) A \line
   TWIG f list A = list TWIG f A \line
   A is a shape ==> TWIG f (A reshape B) = A reshape TWIG f B \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0155}
{\up $}{\footnote\pard\plain{\up $} type}
{\up #}{\footnote\pard\plain{\up #} 25VWG1O}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 type\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} measurement operation, type;type}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 unary pervasive\plain\fs20\cf1\cb1 {\v 1.T4ZU7}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 type A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 isboolean\plain\fs20\cf1\cb1 {\v 1VYX20O}\line

\par The operation \i type\plain\fs20\cf1\cb1  maps an atom \i A\plain\fs20\cf1\cb1  to the representative value of the corresponding atomic type.  It is extended to arbitrary arrays by being unary pervasive.  
\par  \trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \b Atomic type \cell\pard \pard\intbl\sb95 Representative atom \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 boolean \cell\pard \pard\intbl\sb95 o \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 integer \cell\pard \pard\intbl\sb95 0 \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 real \cell\pard \pard\intbl\sb95 0. \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 character \cell\pard \pard\intbl\sb95 <blank> \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 phrase \cell\pard \pard\intbl\sb95 " \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1995\cellx5795\pard\intbl\sb95 fault \cell\pard \pard\intbl\sb95 ? \cell\intbl\row
\pard\sb95 
\par \pard\keep\sb95 \f1\fs16      set "decor; \line
     type l  3  3.3  `3  '3.3'  "33 \line
+-+-+--+--+-----+--+ \line
|o|0|0.|` |'   '|""| \line
+-+-+--+--+-----+--+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The operation \i type\plain\fs20\cf1\cb1  is provided as a computational way of transforming an array to a standard value, while preserving structure and type information.  Executing a type test predicate, \i isboolean\plain\fs20\cf1\cb1 , \i isinteger\plain\fs20\cf1\cb1 , etc., is equivalent to testing that the type of an array is equal to the corresponding representative atom.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0156}
{\up $}{\footnote\pard\plain{\up $} unary pervasive}
{\up #}{\footnote\pard\plain{\up #} 1.T4ZU7}
\pard\keepn\sb95 \b\fs25 unary pervasive\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} operation property, unary pervasive;unary pervasive}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul operation property\plain\fs20\cf1\cb1 {\v operation property}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 f A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 binary pervasive\plain\fs20\cf1\cb1 {\v 1ML7BXF}, \uldb multi pervasive\plain\fs20\cf1\cb1 {\v EEB.UV}, \uldb pervasive\plain\fs20\cf1\cb1 {\v 4E_0R6}, \uldb each\plain\fs20\cf1\cb1 {\v QCZZL2}\line

\par A \b unary pervasive\plain\fs20\cf1\cb1  operation maps an array to another array with identical structure, mapping each atom by the function's behaviour on atoms.  All of the scientific operations and the unary operations of arithmetic and logic are unary pervasive.  \line

\par The scientific operations are implemented using the library routines provided with the C compiler used to construct Q'Nial.  The accuracy of the result is determined by the precision of the floating point number system of the computer and the accuracy of the library routine approximation.  \line

\par \pard\sb95 The following table describes the unary pervasive operations:
\par  \trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 \b Operation \cell\pard \pard\intbl\sb95 Function \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 \plain\fs20\cf1\cb1 abs \cell\pard \pard\intbl\sb95 absolute value \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 arccos \cell\pard \pard\intbl\sb95 inverse cosine function \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 arcsin \cell\pard \pard\intbl\sb95 inverse sine function \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 arctan \cell\pard \pard\intbl\sb95 inverse tangent function \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 ceiling \cell\pard \pard\intbl\sb95 lowest integer above a real number \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 char \cell\pard \pard\intbl\sb95 integer to character conversion \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 charrep \cell\pard \pard\intbl\sb95 character to integer conversion \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 cos \cell\pard \pard\intbl\sb95 cosine function \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 cosh \cell\pard \pard\intbl\sb95 hyperbolic cosine function \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 exp \cell\pard \pard\intbl\sb95 exponential function \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 floor \cell\pard \pard\intbl\sb95 next higher integer above a real number \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 ln \cell\pard \pard\intbl\sb95 natural logarithm \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 log \cell\pard \pard\intbl\sb95 logarithm base 10 \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 not \cell\pard \pard\intbl\sb95 opposite of a boolean value \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 opposite \cell\pard \pard\intbl\sb95 opposite of a number \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 reciprocal \cell\pard \pard\intbl\sb95 reciprocal of a number \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 sin \cell\pard \pard\intbl\sb95 sine function \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 sinh \cell\pard \pard\intbl\sb95 hyperbolic sine function \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 sqrt \cell\pard \pard\intbl\sb95 square root of a number \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 tan \cell\pard \pard\intbl\sb95 tangent function \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 tanh \cell\pard \pard\intbl\sb95 hyperbolic tangent function \cell\intbl\row
\trowd\trgaph175\trleft-6 \cellx1665\cellx5795\pard\intbl\sb95 type \cell\pard \pard\intbl\sb95 representative atom of same type \cell\intbl\row
\pard\sb95 \line

\par \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    f A = EACH f A \line
   shape f A = shape A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0157}
{\up $}{\footnote\pard\plain{\up $} unequal}
{\up #}{\footnote\pard\plain{\up #} LT7UC9}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 unequal\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} logic operation, unequal;unequal}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul logic operation\plain\fs20\cf1\cb1 {\v logic operation}
\par \pard\sb95 \b Property:  \uldb \plain\uldb\fs20\cf1\cb1 predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A unequal B   A ~= B   unequal A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 equal\plain\fs20\cf1\cb1 {\v TKZHRR}, \uldb diverse\plain\fs20\cf1\cb1 {\v 19T6FZO}, \uldb notin\plain\fs20\cf1\cb1 {\v 7KLHCD}\line

\par The operation 
\par \pard\keep\sb95 \f1\fs16      2 3 4 ~= [2,3,4] \line
o \line
 \line
     Null ~= '' \line
o \line
 \line
     2 (3 4) ~= (2 3) 4 \line
l \line
 \line
     unequal (2 3) (2 3) (2 3) \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      unequal IS OPERATION A \{\- not equal A \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0158}
{\up $}{\footnote\pard\plain{\up $} up}
{\up #}{\footnote\pard\plain{\up #} RJ2SO4}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 up\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} comparison operation, up;up}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul comparison operation\plain\fs20\cf1\cb1 {\v comparison operation}
\par \pard\sb95 \b Properties:  \uldb \plain\uldb\fs20\cf1\cb1 binary\plain\fs20\cf1\cb1 {\v 3YC1_U4}, \uldb predicate\plain\fs20\cf1\cb1 {\v QJ_HSO}
\par \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 A up B   up A B    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 lte\plain\fs20\cf1\cb1 {\v 1ZNC14K}\line

\par The operation \i up\plain\fs20\cf1\cb1  is used to do a lexicographic comparison of two arrays returning \i true\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  is lexicographically less than or equal to \i B\plain\fs20\cf1\cb1  and \i false\plain\fs20\cf1\cb1  otherwise.  If \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  are atoms of the same type, then their values are compared using \i <=\plain\fs20\cf1\cb1 , otherwise \i A\plain\fs20\cf1\cb1  is viewed as less than \i B\plain\fs20\cf1\cb1  if \i A\plain\fs20\cf1\cb1  has a lower type than \i B\plain\fs20\cf1\cb1 .  The types are ordered lowest to highest by \i boolean\plain\fs20\cf1\cb1 , \i integer\plain\fs20\cf1\cb1 , \i real\plain\fs20\cf1\cb1 , \i character\plain\fs20\cf1\cb1 , \i phrase\plain\fs20\cf1\cb1 , and \i fault\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 If one of \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  is not atomic then the list of items of \i A\plain\fs20\cf1\cb1  are compared lexicographically to those of \i B\plain\fs20\cf1\cb1 .  The comparison is based on the first position where the items differ, and the result is the lexicographic comparison of the two items.  If the lists of items agree up to the point where one is exhausted, then the array with the shorter list precedes the longer one.  \line

\par If \i A\plain\fs20\cf1\cb1  and \i B\plain\fs20\cf1\cb1  are arrays with the same list of items, then the comparison is decided by comparing their shapes lexicographically.  
\par \pard\keep\sb95 \f1\fs16      2 up 1.5 \line
l \line
      \line
     [2] up 3 \line
1 \line
 \line
     5 up 3 4 5 \line
o \line
 \line
     tell 10 up tell 2 3 \line
l \line
 \line
     (2 2 reshape 'abcd') up (1 4 reshape 'abcd') \line
o\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The first example indicates that 2 precedes 1.5 because the two atoms are of different type and type integer precedes type real.  The second example is \i true\plain\fs20\cf1\cb1  because the lists of items differ in the first item, and 2 precedes 3.  In the third example the lists of items differ in the first item and 5 does not precede 3.  In the fourth example, the arrays differ in the first item and the \i up\plain\fs20\cf1\cb1  comparison of 0 and 0 0 is \i true\plain\fs20\cf1\cb1  because they agree in the first item and 0 is shorter.  In the final example, the result is \i false\plain\fs20\cf1\cb1  because the items are the same and the \i up\plain\fs20\cf1\cb1  comparison of 2 2 and 1 4 is \i false\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    (A up B) and (A ~= B) ==> not (B up A) \line
   A = B ==> A up B \line
   (A up B) and (B up A) <==> A = B \line
\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definitions\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      sortup IS SORT up \line
 \line
     gradeup IS GRADE up\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0159}
{\up $}{\footnote\pard\plain{\up $} update}
{\up #}{\footnote\pard\plain{\up #} 4AIR_VK}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 update\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} evaluation operation, update;update}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 update Nm I A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 updateall\plain\fs20\cf1\cb1 {\v I.4L_C}, \uldb deepupdate\plain\fs20\cf1\cb1 {\v 5IR4_G}, \uldb place\plain\fs20\cf1\cb1 {\v TVU4TK}\line

\par The operation \i update\plain\fs20\cf1\cb1  provides the semantics of the \i Nm@I := A\plain\fs20\cf1\cb1  form of assignment expression.  \i Nm\plain\fs20\cf1\cb1  must be an existing variable represented by a string, phrase or a cast.  \i I\plain\fs20\cf1\cb1  is the address of the location to be updated.  \i A\plain\fs20\cf1\cb1  is the array to be placed in the variable.  
\par \pard\keep\sb95 \f1\fs16      X := 3 4 5; update "X 0 8 \line
8 4 5 \line
     update !X 2 "goodbye \line
8 4 goodbye\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The major purpose of \i update\plain\fs20\cf1\cb1  is to allow a selective update at one location in the array associated with a global variable without forcing a copy.  By passing the name of the variable to the operation that is using \i update\plain\fs20\cf1\cb1 , rather than its value, no sharing of the internal data is made and hence the update can be done in place.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:015a}
{\up $}{\footnote\pard\plain{\up $} updateall}
{\up #}{\footnote\pard\plain{\up #} I.4L_C}
\pard\keepn\sb95 \b\fs25 updateall\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} evaluation operation, updateall;updateall}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 updateall Nm I A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 update\plain\fs20\cf1\cb1 {\v 4AIR_VK}, \uldb deepupdate\plain\fs20\cf1\cb1 {\v 5IR4_G}, \uldb placeall\plain\fs20\cf1\cb1 {\v 1_2.DUD}\line

\par The operation \i updateall\plain\fs20\cf1\cb1  provides the semantics of the \i Nm#I := A\plain\fs20\cf1\cb1  form of assignment expression.  \i Nm\plain\fs20\cf1\cb1  must be an existing variable represented by a string, phrase or a cast.  \i I\plain\fs20\cf1\cb1  is the array of addresses of the locations to be updated.  \i A\plain\fs20\cf1\cb1  is the array of values to be placed in the variable.  
\par \pard\keep\sb95 \f1\fs16      X := 3 4 5; \line
     updateall "X (0 2) (8 10) \line
8 4 10 \line
     updateall !X (1 2) ("hello "goodbye) \line
8 hello goodbye\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The major purpose of \i updateall\plain\fs20\cf1\cb1  is to allow a selective update at several locations in the array associated with a global variable without forcing a copy.  By passing the name of the variable to the operation that is using \i update\plain\fs20\cf1\cb1 , rather than its value, no sharing of the internal data is made, and hence the update can be done in place.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:015b}
{\up $}{\footnote\pard\plain{\up $} user primitives}
{\up #}{\footnote\pard\plain{\up #} DV7MJ4}
\pard\keepn\sb95 \b\fs25 user primitives\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} system operation, user primitives;user primitives}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 <defined for each primitive>    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 calldllfun\plain\fs20\cf1\cb1 {\v 201S2GS}\line

\par The Nial Tools software packages for Windows and for Unix provide a capability to extend the Q'Nial interpreters provided with each package by adding new user written primitives corresponding to expressions, operations and transformers. The new routines are written in "C" to meet the abstract machine interface for the Q'Nial interpreter.\line

\par This requires that the licensee have a C compiler that can produce object modules compatible with the object files provided with the package. The extended interpreter is built by linking the user written routines with object files.\line

\par \pard\sb95 This approach to extending Nial is appropriate if the new primitive is called frequently and one wants to avoid the overhead of using a DLL interface (under Windows) or the \i callc\plain\fs20\cf1\cb1  operation (under Unix).\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:015c}
{\up $}{\footnote\pard\plain{\up $} vacate}
{\up #}{\footnote\pard\plain{\up #} 4B0Q_VK}
\pard\keepn\sb95 \b\fs25 vacate\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} reshaping operation, vacate;vacate}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul reshaping operation\plain\fs20\cf1\cb1 {\v reshaping operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 vacate A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 reshape\plain\fs20\cf1\cb1 {\v 3I4D_MA}, \uldb void\plain\fs20\cf1\cb1 {\v QDA_QY}\line

\par The operation \i vacate\plain\fs20\cf1\cb1  is a renaming of the operation \i (0 reshape)\plain\fs20\cf1\cb1 .  It is used in Version 4 of Array Theory to produce an empty array with the same prototype as its argument. In Version 6 of Array Theory it always returns \i Null\plain\fs20\cf1\cb1 .
\par \pard\keep\sb95 \f1\fs16      vacate 3 (4 5)= Null \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16 vacate is OPERATION A ( 0 reshape A )\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    vacate A = Null \line
   vacate A = void first A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:015d}
{\up $}{\footnote\pard\plain{\up $} valence}
{\up #}{\footnote\pard\plain{\up #} MQJNXM}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 valence\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} measurement operation, valence;valence}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul measurement operation\plain\fs20\cf1\cb1 {\v measurement operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 valence A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 shape\plain\fs20\cf1\cb1 {\v TYQ56K}, \uldb tally\plain\fs20\cf1\cb1 {\v 5JEH.UN}\line

\par The operation \i valence\plain\fs20\cf1\cb1  returns an integer indicating the number of axes of \i A\plain\fs20\cf1\cb1 .  If \i A\plain\fs20\cf1\cb1  is a single, list or table, the result is 0, 1 or 2 respectively.  
\par \pard\keep\sb95 \f1\fs16      valence 3 \line
0 \line
 \line
     valence 4 5 6 \line
1 \line
 \line
     valence tell 2 3 \line
2 \line
 \line
     valence (0 0 0 0 1 1 0 1 reshape 3) \line
8\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      valence IS OPERATION A (tally shape A) \plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    shape valence A = Null \line
   tally valence A = 1 \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:015e}
{\up $}{\footnote\pard\plain{\up $} value}
{\up #}{\footnote\pard\plain{\up #} 5JGH_30}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 value\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} evaluation operation, value;value}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul evaluation operation\plain\fs20\cf1\cb1 {\v evaluation operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 value Nm    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 assign\plain\fs20\cf1\cb1 {\v GIPGUZ}, \uldb eval\plain\fs20\cf1\cb1 {\v 40OE2Q}\line

\par The operation \i value\plain\fs20\cf1\cb1  provides the semantics of \i value of a variable\plain\fs20\cf1\cb1  that is implicit whenever a variable is used in a value context.  The argument \i Nm\plain\fs20\cf1\cb1  is either a string or phrase denoting a variable or it is the cast of a variable.  The result is the value of the variable.  If \i Nm\plain\fs20\cf1\cb1  is a string or phrase, the value is sought in the environment at the point of application of \i value\plain\fs20\cf1\cb1 .  If \i Nm\plain\fs20\cf1\cb1  is a cast, the value is sought in the environment where the cast was created.  The major use of \i value\plain\fs20\cf1\cb1  is in conjunction with \i assign\plain\fs20\cf1\cb1  which allows arbitrary variables to be stored and later retrieved using \i value\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      X := 3 4 5 ; value "X = value !X \line
l\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:015f}
{\up $}{\footnote\pard\plain{\up $} variable}
{\up #}{\footnote\pard\plain{\up #} 4QO4_OO}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 variable\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} syntax, variable;variable}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul syntax\plain\fs20\cf1\cb1 {\v syntax}
\par \pard\sb95 \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 assign expression\plain\fs20\cf1\cb1 {\v LWL7E5}, \uldb local environment\plain\fs20\cf1\cb1 {\v BN.OFR}, \uldb vars\plain\fs20\cf1\cb1 {\v 1CMLZGM}, \uldb role\plain\fs20\cf1\cb1 {\v QD__TZ}, \uldb indexing\plain\fs20\cf1\cb1 {\v 2MDYZ6S}, \uldb scope of a variable\plain\fs20\cf1\cb1 {\v 42GY_XT}\line

\par A \b variable\plain\fs20\cf1\cb1  is a name associated with an array value.  Its syntactic form is that of an identifier.  
\par \pard\keep\sb95 \f1\fs16      variable ::= identifier \line
 \line
     indexed-variable ::= \line
          variable @ primary-expression \line
        | variable @@ primary-expression \line
        | variable # primary-expression \line
        | variable | primary-expression\plain\fs20\cf1\cb1 \line

\par \pard\sb95 A variable is given an association with an array value by its use on the left side of an assign-expression, its appearance in a local or nonlocal declaration, its designation as a variable in an external-declaration or its use as the first argument of the operation assign.  \line

\par When a variable is used as a primary-expression, its meaning is the array value associated with the identifier.  If the variable exists but has not been assigned, it will have as its default value the fault \i ?no_value\plain\fs20\cf1\cb1 .  If an identifier is mentioned as a primary-expression but has not yet been given an association, a parse error will occur with the fault \i ?undefined identifier:\plain\fs20\cf1\cb1 .  \line

\par \pard\sb95 \line

\par \b Role of a Variable \plain\fs20\cf1\cb1 \line

\par A variable gives a name to the result of a computation.  If the same result is needed later in the program, the named variable can be used, thereby avoiding the necessity of repeating the computation.  A variable can be assigned different array values throughout the computation.  \line

\par Although an identifier can be of any length up to 80 characters, a compromise is usually made between choosing explicit variable names and choosing brief names to avoid unnecessary typing.  An identifier used as a variable cannot be a Q'Nial reserved word.  In a local environment, a variable identifier can be chosen the same as a predefined or user-defined global definition name.  Such a choice makes the global use of the name unavailable in the local context.  \line

\par \pard\sb95 In any context, an identifier can name only one of: a variable, an array- expression, an operation-expression, or a transformer-expression.  During one session, the role of a name, i.e.  the class of syntactic object it names, cannot be changed.  \line

\par \line

\par \b Indexed Variable \plain\fs20\cf1\cb1 \line

\par An \b indexed variable\plain\fs20\cf1\cb1  is a variable for which a part of the associated array value is referenced.  An \b index\plain\fs20\cf1\cb1  is the value of the primary-expression within an indexed-variable which specifies the location or locations of the part or parts of the array that are selected.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0160}
{\up $}{\footnote\pard\plain{\up $} vars}
{\up #}{\footnote\pard\plain{\up #} 1CMLZGM}
\pard\keepn\sb95 \b\fs25 vars\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} system expression, vars;vars}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Vars    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 symbols\plain\fs20\cf1\cb1 {\v 1KUXMUU}, \uldb exprs\plain\fs20\cf1\cb1 {\v 7BUDLI}, \uldb ops\plain\fs20\cf1\cb1 {\v 1_E74DI}, \uldb trs\plain\fs20\cf1\cb1 {\v 1_E79FI}\line

\par The expression \i Vars\plain\fs20\cf1\cb1  returns a list of phrases giving the names of all user variables in the workspace.  \line

\par \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      Vars IS \{\-  \line
        Names Roles := pack symbols 0;  \line
        "var match Roles sublist Names \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0161}
{\up $}{\footnote\pard\plain{\up $} version}
{\up #}{\footnote\pard\plain{\up #} 4NLJMF}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 version\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} constant expression, version;version}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul constant expression\plain\fs20\cf1\cb1 {\v constant expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Version    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 copyright\plain\fs20\cf1\cb1 {\v 2.MC.X4}, \uldb system\plain\fs20\cf1\cb1 {\v .FDS.I}\line

\par The expression \i Version\plain\fs20\cf1\cb1  returns a string containing the release and version number of Q'Nial.  
\par \pard\keep\sb95 \f1\fs16      Version \line
Q'Nial for Windows Version 6.2 June 5, 1997\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0162}
{\up $}{\footnote\pard\plain{\up $} void}
{\up #}{\footnote\pard\plain{\up #} QDA_QY}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 void\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} reshaping operation, void;void}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul reshaping operation\plain\fs20\cf1\cb1 {\v reshaping operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 void A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 reshape\plain\fs20\cf1\cb1 {\v 3I4D_MA}, \uldb vacate\plain\fs20\cf1\cb1 {\v 4B0Q_VK}\line

\par The operation \i void\plain\fs20\cf1\cb1  is an obsolete operation that has the same effect as the operation \i (0 reshape)\plain\fs20\cf1\cb1 .  It is used in Version 4 of Array Theory to produce an empty array with A as its prototype. In Version 6 of Array Theory it always returns \i Null\plain\fs20\cf1\cb1 .
\par \pard\keep\sb95 \f1\fs16      void 3 (4 5) = Null \line
l\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16 void is OPERATION A ( 0 reshape solitary A )\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Equations\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16    void A = Null \line
   vacate A = void first A \line
\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0163}
{\up $}{\footnote\pard\plain{\up $} watch}
{\up #}{\footnote\pard\plain{\up #} U2JGTN}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 watch\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} system operation, watch;watch}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system operation\plain\fs20\cf1\cb1 {\v system operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 watch Var Expr    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 debugging\plain\fs20\cf1\cb1 {\v PP0_XH}, \uldb watchlist\plain\fs20\cf1\cb1 {\v J.SR_V}\line

\par The operation \i watch\plain\fs20\cf1\cb1  provides a means to watch when a variable has its value changed.  The first argument to \i watch\plain\fs20\cf1\cb1  is a variable reference expressed as a cast.  For a global variable \i X\plain\fs20\cf1\cb1 , the cast is \i !X\plain\fs20\cf1\cb1 ; for a local variable \i Y\plain\fs20\cf1\cb1  in definition \i G\plain\fs20\cf1\cb1 , the cast is \i !G:Y\plain\fs20\cf1\cb1 .  \line

\par The second argument is a string of program text to be executed when the variable is changed.  If it is empty then it indicates that the watch should be removed.  The program text can display the value being set, execute a break, or take some other action.  \line

\par \pard\sb95 The result of \i watch\plain\fs20\cf1\cb1  is the variable reference and the previous watch expression if any.  This can be used to restore the watch setting by storing it and using it as the argument to \i watch\plain\fs20\cf1\cb1  at a later time.  
\par \pard\keep\sb95 \f1\fs16      X gets count 5; \line
 \line
     watch !x 'write ''X changed to: '' X' \line
+------------------++ \line
|+---+------------+|| \line
||100|2 7926 42354||| \line
|+---+------------+|| \line
+------------------++ \line
 \line
     X gets 'abc' \line
+--------------+---+ \line
|X changed to: |abc| \line
+--------------+---+ \line
abc \line
 \line
     X gets 3 4 5 6 \line
+--------------+-------+ \line
|X changed to: |3 4 5 6| \line
+--------------+-------+ \line
3 4 5 6 \line
 \line
     foo is op A \{\- B gets count A; reverse B \'7d \line
 \line
     watch !foo:b  'write ''B in foo changed to: '' B' \line
+--------------------------------------++ \line
|+---+--------------------------------+|| \line
||100|+--+------------+--------------+||| \line
||   ||50|2 7926 42470|23 7798 7798 B|||| \line
||   |+--+------------+--------------+||| \line
|+---+--------------------------------+|| \line
+--------------------------------------++ \line
 \line
     watchlist \line
+-----------------------------+----------------------------------------+ \line
|+--+------------------------+|+------+-------------------------------+| \line
||!X|write 'X changed to: ' X|||!FOO:B|write 'B in foo changed to: ' B|| \line
|+--+------------------------+|+------+-------------------------------+| \line
+-----------------------------+----------------------------------------+ \line
 \line
     watch !x '' \line
+------------------+------------------------+ \line
|+---+------------+|write 'X changed to: ' X| \line
||100|2 7926 42354||                        | \line
|+---+------------+|                        | \line
+------------------+------------------------+ \line
 \line
     watchlist \line
+----------------------------------------+ \line
|+------+-------------------------------+| \line
||!FOO:B|write 'B in foo changed to: ' B|| \line
|+------+-------------------------------+| \line
+----------------------------------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 To clear all watches use: 
\par \pard\keep\sb95 \f1\fs16      EACH first Watchlist EACHLEFT watch ''\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0164}
{\up $}{\footnote\pard\plain{\up $} watchlist}
{\up #}{\footnote\pard\plain{\up #} J.SR_V}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 watchlist\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} system expression, watchlist;watchlist}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul system expression\plain\fs20\cf1\cb1 {\v system expression}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 Watchlist    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 watch\plain\fs20\cf1\cb1 {\v U2JGTN}, \uldb debugging\plain\fs20\cf1\cb1 {\v PP0_XH}\line

\par The execution of \i Watchlist\plain\fs20\cf1\cb1  prints out a list of the variable watches that are in effect.  \line

\par Its main use is to assist in clearing the watches as debugging proceeds.  
\par \pard\keep\sb95 \f1\fs16      Watchlist \line
+-----------------------------+----------------------------------------+ \line
|+--+------------------------+|+------+-------------------------------+| \line
||!X|write 'X changed to: ' X|||!FOO:B|write 'B in foo changed to: ' B|| \line
|+--+------------------------+|+------+-------------------------------+| \line
+-----------------------------+----------------------------------------+ \line
 \line
     watch !x '' \line
+------------------+------------------------+ \line
|+---+------------+|write 'X changed to: ' X| \line
||100|2 7926 42354||                        | \line
|+---+------------+|                        | \line
+------------------+------------------------+ \line
 \line
     watchlist \line
+----------------------------------------+ \line
|+------+-------------------------------+| \line
||!FOO:B|write 'B in foo changed to: ' B|| \line
|+------+-------------------------------+| \line
+----------------------------------------+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 To clear all watches use: 
\par \pard\keep\sb95 \f1\fs16      EACH first Watchlist EACHLEFT watch ''\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0165}
{\up $}{\footnote\pard\plain{\up $} while-loop}
{\up #}{\footnote\pard\plain{\up #} TQAIFP}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 while-loop\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} control structure, while-loop;while-loop}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul control structure\plain\fs20\cf1\cb1 {\v control structure}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 WHILE conditional expression DO expression sequence ENDWHILE    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 repeat-loop\plain\fs20\cf1\cb1 {\v 12OGSY0}, \uldb for-loop\plain\fs20\cf1\cb1 {\v MT.6OU}\line

\par The \i WHILE-loop\plain\fs20\cf1\cb1  notation is used for executing an expression sequence repeatedly as long as a conditional expression returns \i true\plain\fs20\cf1\cb1 .  
\par \pard\keep\sb95 \f1\fs16      F := open Filenm "r; \line
     Lines := ''; \line
     Line := readfile F; \line
     WHILE not isfault Line DO \line
       Lines := Lines append Line; \line
       Line := readfile F; \line
     ENDWHILE;\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0166}
{\up $}{\footnote\pard\plain{\up $} write}
{\up #}{\footnote\pard\plain{\up #} 5JHY020}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 write\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} interactive input/output operation, write;write}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul interactive input/output operation\plain\fs20\cf1\cb1 {\v interactive input/output operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 write A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 writescreen\plain\fs20\cf1\cb1 {\v 9TD.YB}, \uldb writechars\plain\fs20\cf1\cb1 {\v 30680BN}, \uldb read\plain\fs20\cf1\cb1 {\v QD_3IY}\line

\par The operation \i write\plain\fs20\cf1\cb1  displays the picture of an array on the display screen.  The result is the no-expression fault \i ?noexpr\plain\fs20\cf1\cb1 .  The picture displayed depends on the settings of the \i diagram/sketch\plain\fs20\cf1\cb1  and \i decor/nodecor\plain\fs20\cf1\cb1  switches.  The effect of \i write\plain\fs20\cf1\cb1  is the same as applying \i writescreen\plain\fs20\cf1\cb1  to the picture of the array.  
\par \pard\keep\sb95 \f1\fs16      write 3 (4 5); \line
+-+---+ \line
|3|4 5| \line
+-+---+\plain\fs20\cf1\cb1 \line

\par \pard\sb95 \b Definition\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      write IS OPERATION A \{\- writescreen picture A \'7d \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0167}
{\up $}{\footnote\pard\plain{\up $} writearray}
{\up #}{\footnote\pard\plain{\up #} 18CILAO}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 writearray\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} nial direct access file operation, writearray;writearray}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nial direct access file operation\plain\fs20\cf1\cb1 {\v nial direct access file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 writearray F N A    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 writerecord\plain\fs20\cf1\cb1 {\v V4AFRH}, \uldb readarray\plain\fs20\cf1\cb1 {\v 7HVXYZ}, \uldb readrecord\plain\fs20\cf1\cb1 {\v 6J72_OO}, \uldb eraserecord\plain\fs20\cf1\cb1 {\v LE6Z0M}, \uldb writefile\plain\fs20\cf1\cb1 {\v 1DNB1GE}, \uldb filetally\plain\fs20\cf1\cb1 {\v 1E5.ZTN}, \uldb open\plain\fs20\cf1\cb1 {\v 25VR_QX}, \uldb close\plain\fs20\cf1\cb1 {\v TIUC9K}\line

\par The operation \i writearray\plain\fs20\cf1\cb1  writes array \i A\plain\fs20\cf1\cb1  to the direct access file designated by \i F\plain\fs20\cf1\cb1  at component number \i N\plain\fs20\cf1\cb1 .  If a component already exists at that component number and \i A\plain\fs20\cf1\cb1  can fit in the space taken by that component, the existing one is overwritten.  If not, the new component is written at the end of the \i .rec\plain\fs20\cf1\cb1  file and the \i .ndx\plain\fs20\cf1\cb1  file is updated to indicate the starting point for the new component.  The space used by the previous value is recorded for a future compression.  \line

\par \pard\sb95 The second argument \i N\plain\fs20\cf1\cb1  can be a list of numbers, in which case the items of \i A\plain\fs20\cf1\cb1  are written to the components designated by the integers in \i N\plain\fs20\cf1\cb1 .  The file must be open for direct access.  The other direct access file operations, \i readrecord\plain\fs20\cf1\cb1  and \i writerecord\plain\fs20\cf1\cb1 , must not be used on a file that is created using \i writearray\plain\fs20\cf1\cb1 .  However, \i eraserecord\plain\fs20\cf1\cb1  and \i filetally\plain\fs20\cf1\cb1  are used for both kinds of direct access files.  \line

\par After a \i writearray\plain\fs20\cf1\cb1  or \i writerecord\plain\fs20\cf1\cb1 , if the total unused space is a significant amount of the space occupied by the \i .rec\plain\fs20\cf1\cb1  file, the file is compressed with the records being placed in order.  \line

\par \pard\sb95 The content of an array component is placed in the file in a binary form independent of the workspace in which it was created.  Data that is written to a direct access file, erased, and then read in again, may take up more space in the workspace after this process due to lack of sharing of internal representations.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0168}
{\up $}{\footnote\pard\plain{\up $} writechars}
{\up #}{\footnote\pard\plain{\up #} 30680BN}
\pard\keepn\sb95 \b\fs25 writechars\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} interactive input/output operation, writechars;writechars}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul interactive input/output operation\plain\fs20\cf1\cb1 {\v interactive input/output operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 writechars S    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 writescreen\plain\fs20\cf1\cb1 {\v 9TD.YB}, \uldb write\plain\fs20\cf1\cb1 {\v 5JHY020}, \uldb readchar\plain\fs20\cf1\cb1 {\v RSJV13}\line

\par The operation \i writechars\plain\fs20\cf1\cb1  writes \i S\plain\fs20\cf1\cb1  to the screen at the current cursor position, without supplying a trailing "new line" character.  Thus, the cursor is left at the position just after the text.  \i S\plain\fs20\cf1\cb1  may be a string, a phrase or a single character.  The principal use of \i writechars\plain\fs20\cf1\cb1  is in applications where the display screen is managed as a fixed object and scrolling must be avoided.  
\par \pard\keep\sb95 \f1\fs16      writechars 'hello world'\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:0169}
{\up $}{\footnote\pard\plain{\up $} writefield}
{\up #}{\footnote\pard\plain{\up #} 3WBE_SO}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 writefield\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} host direct access file operation, writefield;writefield}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul host direct access file operation\plain\fs20\cf1\cb1 {\v host direct access file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 writefield Filename Start Str    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 writerecord\plain\fs20\cf1\cb1 {\v V4AFRH}, \uldb writearray\plain\fs20\cf1\cb1 {\v 18CILAO}, \uldb filelength\plain\fs20\cf1\cb1 {\v 34SOEI}\line

\par The operation \i writefield\plain\fs20\cf1\cb1  is used to write a character string to a portion of an existing host file.  The first argument is the file name, followed by the integer offset to the beginning of the field to be written and by the string to be written.  The result is the \i ?noexpr\plain\fs20\cf1\cb1  fault.  \line

\par \b Example\plain\fs20\cf1\cb1 
\par \pard\keep\sb95 \f1\fs16      writefield "phonefile 200 'Mike Smith  389-4444'\plain\fs20\cf1\cb1 \line

\par \pard\sb95 In the example, \i writefield\plain\fs20\cf1\cb1  overwrites the contents of file \i phonefile\plain\fs20\cf1\cb1  starting at position 200 by the string given as the third argument.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:016a}
{\up $}{\footnote\pard\plain{\up $} writefile}
{\up #}{\footnote\pard\plain{\up #} 1DNB1GE}
\pard\keepn\sb95 \b\fs25 writefile\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} file operation, writefile;writefile}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul file operation\plain\fs20\cf1\cb1 {\v file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 writefile N S   writefile N S [Eolsw]    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 readfile\plain\fs20\cf1\cb1 {\v 5JAWOA}, \uldb putfile\plain\fs20\cf1\cb1 {\v IMUFEL}, \uldb open\plain\fs20\cf1\cb1 {\v 25VR_QX}, \uldb close\plain\fs20\cf1\cb1 {\v TIUC9K}, \uldb appendfile\plain\fs20\cf1\cb1 {\v 3AAL9Q}\line

\par The operation \i writefile\plain\fs20\cf1\cb1  is used to write the character array \i S\plain\fs20\cf1\cb1  to the file designated by file designator \i N\plain\fs20\cf1\cb1 .  The file designator is an integer returned by \i open\plain\fs20\cf1\cb1 .  The file must have been opened for writing, appending or communication.  \line

\par The argument \i S\plain\fs20\cf1\cb1  may be a character, a string, or an array of characters of any valence.  If it is a character or string, a single record is written to the file.  If it is a table, the rows of the table are written as records to the file.  The appropriate end-of-line indication is added for each record written.  If the argument \i S\plain\fs20\cf1\cb1  is empty, an empty record is written.  \line

\par \pard\sb95 If \i writefile\plain\fs20\cf1\cb1  is successful, the result is the no-expression fault \i ?noexpr\plain\fs20\cf1\cb1 .  If the argument is not a character, string or character table, the fault \i ?not text data\plain\fs20\cf1\cb1  is returned.  \line

\par If the optional third argument is present, it is used to indicate whether the end-of-line indication should be written.  If the third argument is \i o\plain\fs20\cf1\cb1  or \i 0\plain\fs20\cf1\cb1  the indication is omitted; if it is \i l\plain\fs20\cf1\cb1  or \i 1\plain\fs20\cf1\cb1 , the indication is placed in the file.  This form of \i writefile\plain\fs20\cf1\cb1  is used in communications mode to send information to a device driver on the EXTDOS version.  
\par \pard\keep\sb95 \f1\fs16      writefile 5 'a line of text';\page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:016b}
{\up $}{\footnote\pard\plain{\up $} writerecord}
{\up #}{\footnote\pard\plain{\up #} V4AFRH}
\pard\keepn\keep\sb95 \plain\b\fs25\cf1\cb1 writerecord\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} nial direct access file operation, writerecord;writerecord}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul nial direct access file operation\plain\fs20\cf1\cb1 {\v nial direct access file operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 writerecord F N S    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 readrecord\plain\fs20\cf1\cb1 {\v 6J72_OO}, \uldb writearray\plain\fs20\cf1\cb1 {\v 18CILAO}, \uldb readarray\plain\fs20\cf1\cb1 {\v 7HVXYZ}, \uldb eraserecord\plain\fs20\cf1\cb1 {\v LE6Z0M}, \uldb open\plain\fs20\cf1\cb1 {\v 25VR_QX}, \uldb close\plain\fs20\cf1\cb1 {\v TIUC9K}\line

\par The operation \i writerecord\plain\fs20\cf1\cb1  writes string \i S\plain\fs20\cf1\cb1  to the direct access file designated by \i F\plain\fs20\cf1\cb1  at component number \i N\plain\fs20\cf1\cb1 .  \line

\par If a component already exists at that component number and \i S\plain\fs20\cf1\cb1  can fit in the space taken by that component, the existing one is overwritten.  If not, the new component is written at the end of the \i .rec\plain\fs20\cf1\cb1  file and the \i .ndx\plain\fs20\cf1\cb1  file is updated to indicate the starting point for the new component.  \line

\par \pard\sb95 The second argument \i N\plain\fs20\cf1\cb1  can be a list of numbers, in which case the items of \i S\plain\fs20\cf1\cb1  must be strings and are written to the components designated by the integers in \i N\plain\fs20\cf1\cb1 .  The file must be open for direct access.  The other direct access file operations, \i readarray\plain\fs20\cf1\cb1  and \i writearray\plain\fs20\cf1\cb1 , must not be used on a file that is created using \i writerecord\plain\fs20\cf1\cb1 .  However, \i eraserecord\plain\fs20\cf1\cb1  and \i filetally\plain\fs20\cf1\cb1  are used for both kinds of direct access files.  \line

\par \pard\sb95 The data written in the \i .rec\plain\fs20\cf1\cb1  file by \i writerecord\plain\fs20\cf1\cb1  does not contain any end-of-line indications unless they explicitly are part of the strings being written.  \page
{\up +}{\footnote\pard\plain{\up +} BROWSE0002:016c}
{\up $}{\footnote\pard\plain{\up $} writescreen}
{\up #}{\footnote\pard\plain{\up #} 9TD.YB}
\pard\keepn\sb95 \b\fs25 writescreen\plain\fs20\cf1\cb1 
\par \pard {\up K}{\footnote\pard\plain{\up K} interactive input/output operation, writescreen;writescreen}
\uldb \b Class\plain\b\fs20\cf1\cb1 {\v YHPG9B}\plain\fs20\cf1\cb1 :  \ul interactive input/output operation\plain\fs20\cf1\cb1 {\v interactive input/output operation}
\par \pard\sb95 \b Usage: \plain\fs20\cf1\cb1  \f1\fs16 writescreen S    \plain\fs20\cf1\cb1 
\par \b See Also: \uldb \plain\uldb\fs20\cf1\cb1 write\plain\fs20\cf1\cb1 {\v 5JHY020}, \uldb writechars\plain\fs20\cf1\cb1 {\v 30680BN}, \uldb writefile\plain\fs20\cf1\cb1 {\v 1DNB1GE}, \uldb readscreen\plain\fs20\cf1\cb1 {\v F7V7GJ}\line

\par The operation \i writescreen\plain\fs20\cf1\cb1  is used to write character data to the display screen.  The argument \i S\plain\fs20\cf1\cb1  may be a character, a string, or a character table.  If it is a character or string, a single line is displayed.  If it is a table, the rows of the table are written as lines.  If the argument \i S\plain\fs20\cf1\cb1  is empty, an empty line is displayed.  In window mode, the data is written within the bounds of the active window.  \line

\par \pard\sb95 The result of the operation is the no-expression fault \i ?noexpr\plain\fs20\cf1\cb1 .  If the argument is not a character, string or character table, the fault \i ?not text data\plain\fs20\cf1\cb1  is returned.  \line

\par After the text is displayed, the cursor is placed on the line following the last line written.  
\par \pard\keep\sb95 \f1\fs16      writescreen  'End of Manual' ;\plain\fs20\cf1\cb1 \line

\par \pard\sb95 The operation \i writescreen\plain\fs20\cf1\cb1  is similar to the operation \i writefile\plain\fs20\cf1\cb1 .  For most host systems, \i writefile\plain\fs20\cf1\cb1  may be used with the \i standard output device\plain\fs20\cf1\cb1  to get the same effect as a \i writescreen\plain\fs20\cf1\cb1 .  The argument \i S\plain\fs20\cf1\cb1  may be a character, a string, or a character table.  \page
\pard \fs0 }